// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use gio;
use gio_sys;
use glib;
use glib::object::Cast;
use glib::object::IsA;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib::GString;
use glib::StaticType;
use glib::Value;
use glib_sys;
use gobject_sys;
use libc;
use nm_sys;
use std::boxed::Box as Box_;
use std::fmt;
#[cfg(any(feature = "v1_2", feature = "dox"))]
use std::mem;
use std::mem::transmute;
use std::pin::Pin;
use std::ptr;
use ActiveConnection;
use Connection;
#[cfg(any(feature = "v1_16", feature = "dox"))]
use ConnectivityState;
use DeviceCapabilities;
#[cfg(any(feature = "v1_22", feature = "dox"))]
use DeviceInterfaceFlags;
use DeviceState;
use DeviceStateReason;
use DeviceType;
use DhcpConfig;
use IPConfig;
#[cfg(any(feature = "v1_2", feature = "dox"))]
use LldpNeighbor;
#[cfg(any(feature = "v1_2", feature = "dox"))]
use Metered;
use Object;
use RemoteConnection;

glib_wrapper! {
    pub struct Device(Object<nm_sys::NMDevice, nm_sys::NMDeviceClass, DeviceClass>) @extends Object;

    match fn {
        get_type => || nm_sys::nm_device_get_type(),
    }
}

impl Device {
    pub fn disambiguate_names(devices: &[Device]) -> Vec<GString> {
        let num_devices = devices.len() as i32;
        unsafe {
            FromGlibPtrContainer::from_glib_full(nm_sys::nm_device_disambiguate_names(
                devices.to_glib_none().0,
                num_devices,
            ))
        }
    }
}

pub const NONE_DEVICE: Option<&Device> = None;

pub trait DeviceExt: 'static {
    fn connection_compatible<P: IsA<Connection>>(&self, connection: &P) -> Result<(), glib::Error>;

    fn connection_valid<P: IsA<Connection>>(&self, connection: &P) -> bool;

    #[cfg_attr(feature = "v1_22", deprecated)]
    fn delete<P: IsA<gio::Cancellable>>(&self, cancellable: Option<&P>) -> Result<(), glib::Error>;

    fn delete_async<P: IsA<gio::Cancellable>, Q: FnOnce(Result<(), glib::Error>) + Send + 'static>(
        &self,
        cancellable: Option<&P>,
        callback: Q,
    );

    fn delete_async_future(
        &self,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>>;

    #[cfg_attr(feature = "v1_22", deprecated)]
    fn disconnect<P: IsA<gio::Cancellable>>(
        &self,
        cancellable: Option<&P>,
    ) -> Result<(), glib::Error>;

    fn disconnect_async<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
    >(
        &self,
        cancellable: Option<&P>,
        callback: Q,
    );

    fn disconnect_async_future(
        &self,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>>;

    fn filter_connections(&self, connections: &[Connection]) -> Vec<Connection>;

    fn get_active_connection(&self) -> Option<ActiveConnection>;

    #[cfg_attr(feature = "v1_22", deprecated)]
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_applied_connection<P: IsA<gio::Cancellable>>(
        &self,
        flags: u32,
        cancellable: Option<&P>,
    ) -> Result<(Connection, u64), glib::Error>;

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_applied_connection_async<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(Connection, u64), glib::Error>) + Send + 'static,
    >(
        &self,
        flags: u32,
        cancellable: Option<&P>,
        callback: Q,
    );

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_applied_connection_async_future(
        &self,
        flags: u32,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(Connection, u64), glib::Error>> + 'static>>;

    fn get_autoconnect(&self) -> bool;

    fn get_available_connections(&self) -> Vec<RemoteConnection>;

    fn get_capabilities(&self) -> DeviceCapabilities;

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    fn get_connectivity(&self, addr_family: i32) -> ConnectivityState;

    fn get_description(&self) -> Option<GString>;

    fn get_device_type(&self) -> DeviceType;

    fn get_dhcp4_config(&self) -> Option<DhcpConfig>;

    fn get_dhcp6_config(&self) -> Option<DhcpConfig>;

    fn get_driver(&self) -> Option<GString>;

    fn get_driver_version(&self) -> Option<GString>;

    fn get_firmware_missing(&self) -> bool;

    fn get_firmware_version(&self) -> Option<GString>;

    fn get_hw_address(&self) -> Option<GString>;

    fn get_iface(&self) -> Option<GString>;

    #[cfg(any(feature = "v1_22", feature = "dox"))]
    fn get_interface_flags(&self) -> DeviceInterfaceFlags;

    fn get_ip4_config(&self) -> Option<IPConfig>;

    fn get_ip6_config(&self) -> Option<IPConfig>;

    fn get_ip_iface(&self) -> Option<GString>;

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_lldp_neighbors(&self) -> Vec<LldpNeighbor>;

    fn get_managed(&self) -> bool;

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_metered(&self) -> Metered;

    fn get_mtu(&self) -> u32;

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_nm_plugin_missing(&self) -> bool;

    fn get_physical_port_id(&self) -> Option<GString>;

    fn get_product(&self) -> Option<GString>;

    fn get_setting_type(&self) -> glib::types::Type;

    fn get_state(&self) -> DeviceState;

    fn get_state_reason(&self) -> DeviceStateReason;

    fn get_type_description(&self) -> Option<GString>;

    fn get_udi(&self) -> Option<GString>;

    fn get_vendor(&self) -> Option<GString>;

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn is_real(&self) -> bool;

    fn is_software(&self) -> bool;

    #[cfg_attr(feature = "v1_22", deprecated)]
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn reapply<P: IsA<Connection>, Q: IsA<gio::Cancellable>>(
        &self,
        connection: Option<&P>,
        version_id: u64,
        flags: u32,
        cancellable: Option<&Q>,
    ) -> Result<(), glib::Error>;

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn reapply_async<
        P: IsA<Connection>,
        Q: IsA<gio::Cancellable>,
        R: FnOnce(Result<(), glib::Error>) + Send + 'static,
    >(
        &self,
        connection: Option<&P>,
        version_id: u64,
        flags: u32,
        cancellable: Option<&Q>,
        callback: R,
    );

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn reapply_async_future<P: IsA<Connection> + Clone + 'static>(
        &self,
        connection: Option<&P>,
        version_id: u64,
        flags: u32,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>>;

    #[cfg_attr(feature = "v1_22", deprecated)]
    fn set_autoconnect(&self, autoconnect: bool);

    #[cfg_attr(feature = "v1_22", deprecated)]
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn set_managed(&self, managed: bool);

    fn get_property_interface(&self) -> Option<GString>;

    fn get_property_ip_interface(&self) -> Option<GString>;

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    fn get_property_ip4_connectivity(&self) -> ConnectivityState;

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    fn get_property_ip6_connectivity(&self) -> ConnectivityState;

    //fn get_property_lldp_neighbors(&self) -> /*Unimplemented*/Vec<Fundamental: Pointer>;

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_property_real(&self) -> bool;

    fn connect_state_changed<F: Fn(&Self, u32, u32, u32) + 'static>(&self, f: F)
        -> SignalHandlerId;

    fn connect_property_active_connection_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_autoconnect_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_available_connections_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_capabilities_notify<F: Fn(&Self) + 'static>(&self, f: F)
        -> SignalHandlerId;

    fn connect_property_device_type_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_dhcp4_config_notify<F: Fn(&Self) + 'static>(&self, f: F)
        -> SignalHandlerId;

    fn connect_property_dhcp6_config_notify<F: Fn(&Self) + 'static>(&self, f: F)
        -> SignalHandlerId;

    fn connect_property_driver_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_driver_version_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_firmware_missing_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_firmware_version_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_interface_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_22", feature = "dox"))]
    fn connect_property_interface_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_ip_interface_notify<F: Fn(&Self) + 'static>(&self, f: F)
        -> SignalHandlerId;

    fn connect_property_ip4_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    fn connect_property_ip4_connectivity_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_ip6_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    fn connect_property_ip6_connectivity_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_lldp_neighbors_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_managed_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn connect_property_metered_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_mtu_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn connect_property_nm_plugin_missing_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_physical_port_id_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_product_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn connect_property_real_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_state_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_state_reason_notify<F: Fn(&Self) + 'static>(&self, f: F)
        -> SignalHandlerId;

    fn connect_property_udi_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_vendor_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<Device>> DeviceExt for O {
    fn connection_compatible<P: IsA<Connection>>(&self, connection: &P) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = nm_sys::nm_device_connection_compatible(
                self.as_ref().to_glib_none().0,
                connection.as_ref().to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn connection_valid<P: IsA<Connection>>(&self, connection: &P) -> bool {
        unsafe {
            from_glib(nm_sys::nm_device_connection_valid(
                self.as_ref().to_glib_none().0,
                connection.as_ref().to_glib_none().0,
            ))
        }
    }

    fn delete<P: IsA<gio::Cancellable>>(&self, cancellable: Option<&P>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = nm_sys::nm_device_delete(
                self.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn delete_async<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
    >(
        &self,
        cancellable: Option<&P>,
        callback: Q,
    ) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn delete_async_trampoline<
            Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
        >(
            _source_object: *mut gobject_sys::GObject,
            res: *mut gio_sys::GAsyncResult,
            user_data: glib_sys::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let _ = nm_sys::nm_device_delete_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = delete_async_trampoline::<Q>;
        unsafe {
            nm_sys::nm_device_delete_async(
                self.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn delete_async_future(
        &self,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {
        Box_::pin(gio::GioFuture::new(self, move |obj, send| {
            let cancellable = gio::Cancellable::new();
            obj.delete_async(Some(&cancellable), move |res| {
                send.resolve(res);
            });

            cancellable
        }))
    }

    fn disconnect<P: IsA<gio::Cancellable>>(
        &self,
        cancellable: Option<&P>,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = nm_sys::nm_device_disconnect(
                self.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn disconnect_async<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
    >(
        &self,
        cancellable: Option<&P>,
        callback: Q,
    ) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn disconnect_async_trampoline<
            Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
        >(
            _source_object: *mut gobject_sys::GObject,
            res: *mut gio_sys::GAsyncResult,
            user_data: glib_sys::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let _ = nm_sys::nm_device_disconnect_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = disconnect_async_trampoline::<Q>;
        unsafe {
            nm_sys::nm_device_disconnect_async(
                self.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn disconnect_async_future(
        &self,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {
        Box_::pin(gio::GioFuture::new(self, move |obj, send| {
            let cancellable = gio::Cancellable::new();
            obj.disconnect_async(Some(&cancellable), move |res| {
                send.resolve(res);
            });

            cancellable
        }))
    }

    fn filter_connections(&self, connections: &[Connection]) -> Vec<Connection> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(nm_sys::nm_device_filter_connections(
                self.as_ref().to_glib_none().0,
                connections.to_glib_none().0,
            ))
        }
    }

    fn get_active_connection(&self) -> Option<ActiveConnection> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_active_connection(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_applied_connection<P: IsA<gio::Cancellable>>(
        &self,
        flags: u32,
        cancellable: Option<&P>,
    ) -> Result<(Connection, u64), glib::Error> {
        unsafe {
            let mut version_id = mem::MaybeUninit::uninit();
            let mut error = ptr::null_mut();
            let ret = nm_sys::nm_device_get_applied_connection(
                self.as_ref().to_glib_none().0,
                flags,
                version_id.as_mut_ptr(),
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            let version_id = version_id.assume_init();
            if error.is_null() {
                Ok((from_glib_full(ret), version_id))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_applied_connection_async<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(Connection, u64), glib::Error>) + Send + 'static,
    >(
        &self,
        flags: u32,
        cancellable: Option<&P>,
        callback: Q,
    ) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn get_applied_connection_async_trampoline<
            Q: FnOnce(Result<(Connection, u64), glib::Error>) + Send + 'static,
        >(
            _source_object: *mut gobject_sys::GObject,
            res: *mut gio_sys::GAsyncResult,
            user_data: glib_sys::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let mut version_id = mem::MaybeUninit::uninit();
            let ret = nm_sys::nm_device_get_applied_connection_finish(
                _source_object as *mut _,
                res,
                version_id.as_mut_ptr(),
                &mut error,
            );
            let version_id = version_id.assume_init();
            let result = if error.is_null() {
                Ok((from_glib_full(ret), version_id))
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = get_applied_connection_async_trampoline::<Q>;
        unsafe {
            nm_sys::nm_device_get_applied_connection_async(
                self.as_ref().to_glib_none().0,
                flags,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_applied_connection_async_future(
        &self,
        flags: u32,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(Connection, u64), glib::Error>> + 'static>>
    {
        Box_::pin(gio::GioFuture::new(self, move |obj, send| {
            let cancellable = gio::Cancellable::new();
            obj.get_applied_connection_async(flags, Some(&cancellable), move |res| {
                send.resolve(res);
            });

            cancellable
        }))
    }

    fn get_autoconnect(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_device_get_autoconnect(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_available_connections(&self) -> Vec<RemoteConnection> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(nm_sys::nm_device_get_available_connections(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_capabilities(&self) -> DeviceCapabilities {
        unsafe {
            from_glib(nm_sys::nm_device_get_capabilities(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    fn get_connectivity(&self, addr_family: i32) -> ConnectivityState {
        unsafe {
            from_glib(nm_sys::nm_device_get_connectivity(
                self.as_ref().to_glib_none().0,
                addr_family,
            ))
        }
    }

    fn get_description(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_description(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_device_type(&self) -> DeviceType {
        unsafe {
            from_glib(nm_sys::nm_device_get_device_type(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_dhcp4_config(&self) -> Option<DhcpConfig> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_dhcp4_config(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_dhcp6_config(&self) -> Option<DhcpConfig> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_dhcp6_config(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_driver(&self) -> Option<GString> {
        unsafe { from_glib_none(nm_sys::nm_device_get_driver(self.as_ref().to_glib_none().0)) }
    }

    fn get_driver_version(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_driver_version(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_firmware_missing(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_device_get_firmware_missing(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_firmware_version(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_firmware_version(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_hw_address(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_hw_address(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_iface(&self) -> Option<GString> {
        unsafe { from_glib_none(nm_sys::nm_device_get_iface(self.as_ref().to_glib_none().0)) }
    }

    #[cfg(any(feature = "v1_22", feature = "dox"))]
    fn get_interface_flags(&self) -> DeviceInterfaceFlags {
        unsafe {
            from_glib(nm_sys::nm_device_get_interface_flags(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_ip4_config(&self) -> Option<IPConfig> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_ip4_config(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_ip6_config(&self) -> Option<IPConfig> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_ip6_config(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_ip_iface(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_ip_iface(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_lldp_neighbors(&self) -> Vec<LldpNeighbor> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(nm_sys::nm_device_get_lldp_neighbors(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_managed(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_device_get_managed(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_metered(&self) -> Metered {
        unsafe {
            from_glib(nm_sys::nm_device_get_metered(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_mtu(&self) -> u32 {
        unsafe { nm_sys::nm_device_get_mtu(self.as_ref().to_glib_none().0) }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_nm_plugin_missing(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_device_get_nm_plugin_missing(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_physical_port_id(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_physical_port_id(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_product(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_product(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_setting_type(&self) -> glib::types::Type {
        unsafe {
            from_glib(nm_sys::nm_device_get_setting_type(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_state(&self) -> DeviceState {
        unsafe { from_glib(nm_sys::nm_device_get_state(self.as_ref().to_glib_none().0)) }
    }

    fn get_state_reason(&self) -> DeviceStateReason {
        unsafe {
            from_glib(nm_sys::nm_device_get_state_reason(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_type_description(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_type_description(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_udi(&self) -> Option<GString> {
        unsafe { from_glib_none(nm_sys::nm_device_get_udi(self.as_ref().to_glib_none().0)) }
    }

    fn get_vendor(&self) -> Option<GString> {
        unsafe { from_glib_none(nm_sys::nm_device_get_vendor(self.as_ref().to_glib_none().0)) }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn is_real(&self) -> bool {
        unsafe { from_glib(nm_sys::nm_device_is_real(self.as_ref().to_glib_none().0)) }
    }

    fn is_software(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_device_is_software(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn reapply<P: IsA<Connection>, Q: IsA<gio::Cancellable>>(
        &self,
        connection: Option<&P>,
        version_id: u64,
        flags: u32,
        cancellable: Option<&Q>,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = nm_sys::nm_device_reapply(
                self.as_ref().to_glib_none().0,
                connection.map(|p| p.as_ref()).to_glib_none().0,
                version_id,
                flags,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn reapply_async<
        P: IsA<Connection>,
        Q: IsA<gio::Cancellable>,
        R: FnOnce(Result<(), glib::Error>) + Send + 'static,
    >(
        &self,
        connection: Option<&P>,
        version_id: u64,
        flags: u32,
        cancellable: Option<&Q>,
        callback: R,
    ) {
        let user_data: Box_<R> = Box_::new(callback);
        unsafe extern "C" fn reapply_async_trampoline<
            R: FnOnce(Result<(), glib::Error>) + Send + 'static,
        >(
            _source_object: *mut gobject_sys::GObject,
            res: *mut gio_sys::GAsyncResult,
            user_data: glib_sys::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let _ = nm_sys::nm_device_reapply_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<R> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = reapply_async_trampoline::<R>;
        unsafe {
            nm_sys::nm_device_reapply_async(
                self.as_ref().to_glib_none().0,
                connection.map(|p| p.as_ref()).to_glib_none().0,
                version_id,
                flags,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn reapply_async_future<P: IsA<Connection> + Clone + 'static>(
        &self,
        connection: Option<&P>,
        version_id: u64,
        flags: u32,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {
        let connection = connection.map(ToOwned::to_owned);
        Box_::pin(gio::GioFuture::new(self, move |obj, send| {
            let cancellable = gio::Cancellable::new();
            obj.reapply_async(
                connection.as_ref().map(::std::borrow::Borrow::borrow),
                version_id,
                flags,
                Some(&cancellable),
                move |res| {
                    send.resolve(res);
                },
            );

            cancellable
        }))
    }

    fn set_autoconnect(&self, autoconnect: bool) {
        unsafe {
            nm_sys::nm_device_set_autoconnect(
                self.as_ref().to_glib_none().0,
                autoconnect.to_glib(),
            );
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn set_managed(&self, managed: bool) {
        unsafe {
            nm_sys::nm_device_set_managed(self.as_ref().to_glib_none().0, managed.to_glib());
        }
    }

    fn get_property_interface(&self) -> Option<GString> {
        unsafe {
            let mut value = Value::from_type(<GString as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"interface\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `interface` getter")
        }
    }

    fn get_property_ip_interface(&self) -> Option<GString> {
        unsafe {
            let mut value = Value::from_type(<GString as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"ip-interface\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `ip-interface` getter")
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    fn get_property_ip4_connectivity(&self) -> ConnectivityState {
        unsafe {
            let mut value = Value::from_type(<ConnectivityState as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"ip4-connectivity\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `ip4-connectivity` getter")
                .unwrap()
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    fn get_property_ip6_connectivity(&self) -> ConnectivityState {
        unsafe {
            let mut value = Value::from_type(<ConnectivityState as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"ip6-connectivity\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `ip6-connectivity` getter")
                .unwrap()
        }
    }

    //fn get_property_lldp_neighbors(&self) -> /*Unimplemented*/Vec<Fundamental: Pointer> {
    //    unsafe {
    //        let mut value = Value::from_type(</*Unknown type*/ as StaticType>::static_type());
    //        gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"lldp-neighbors\0".as_ptr() as *const _, value.to_glib_none_mut().0);
    //        value.get().expect("Return Value for property `lldp-neighbors` getter")
    //    }
    //}

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_property_real(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"real\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `real` getter")
                .unwrap()
        }
    }

    fn connect_state_changed<F: Fn(&Self, u32, u32, u32) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn state_changed_trampoline<P, F: Fn(&P, u32, u32, u32) + 'static>(
            this: *mut nm_sys::NMDevice,
            new_state: libc::c_uint,
            old_state: libc::c_uint,
            reason: libc::c_uint,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(
                &Device::from_glib_borrow(this).unsafe_cast(),
                new_state,
                old_state,
                reason,
            )
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"state-changed\0".as_ptr() as *const _,
                Some(transmute(state_changed_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_active_connection_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_active_connection_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::active-connection\0".as_ptr() as *const _,
                Some(transmute(
                    notify_active_connection_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_autoconnect_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_autoconnect_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::autoconnect\0".as_ptr() as *const _,
                Some(transmute(notify_autoconnect_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_available_connections_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_available_connections_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::available-connections\0".as_ptr() as *const _,
                Some(transmute(
                    notify_available_connections_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_capabilities_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_capabilities_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::capabilities\0".as_ptr() as *const _,
                Some(transmute(
                    notify_capabilities_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_device_type_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_device_type_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::device-type\0".as_ptr() as *const _,
                Some(transmute(notify_device_type_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_dhcp4_config_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_dhcp4_config_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::dhcp4-config\0".as_ptr() as *const _,
                Some(transmute(
                    notify_dhcp4_config_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_dhcp6_config_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_dhcp6_config_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::dhcp6-config\0".as_ptr() as *const _,
                Some(transmute(
                    notify_dhcp6_config_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_driver_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_driver_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::driver\0".as_ptr() as *const _,
                Some(transmute(notify_driver_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_driver_version_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_driver_version_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::driver-version\0".as_ptr() as *const _,
                Some(transmute(
                    notify_driver_version_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_firmware_missing_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_firmware_missing_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::firmware-missing\0".as_ptr() as *const _,
                Some(transmute(
                    notify_firmware_missing_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_firmware_version_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_firmware_version_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::firmware-version\0".as_ptr() as *const _,
                Some(transmute(
                    notify_firmware_version_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_interface_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_interface_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::interface\0".as_ptr() as *const _,
                Some(transmute(notify_interface_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_22", feature = "dox"))]
    fn connect_property_interface_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_interface_flags_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::interface-flags\0".as_ptr() as *const _,
                Some(transmute(
                    notify_interface_flags_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_ip_interface_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip_interface_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::ip-interface\0".as_ptr() as *const _,
                Some(transmute(
                    notify_ip_interface_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_ip4_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip4_config_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::ip4-config\0".as_ptr() as *const _,
                Some(transmute(notify_ip4_config_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    fn connect_property_ip4_connectivity_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip4_connectivity_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::ip4-connectivity\0".as_ptr() as *const _,
                Some(transmute(
                    notify_ip4_connectivity_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_ip6_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip6_config_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::ip6-config\0".as_ptr() as *const _,
                Some(transmute(notify_ip6_config_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    fn connect_property_ip6_connectivity_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip6_connectivity_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::ip6-connectivity\0".as_ptr() as *const _,
                Some(transmute(
                    notify_ip6_connectivity_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_lldp_neighbors_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_lldp_neighbors_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::lldp-neighbors\0".as_ptr() as *const _,
                Some(transmute(
                    notify_lldp_neighbors_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_managed_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_managed_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::managed\0".as_ptr() as *const _,
                Some(transmute(notify_managed_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn connect_property_metered_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_metered_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::metered\0".as_ptr() as *const _,
                Some(transmute(notify_metered_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_mtu_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mtu_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::mtu\0".as_ptr() as *const _,
                Some(transmute(notify_mtu_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn connect_property_nm_plugin_missing_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_nm_plugin_missing_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::nm-plugin-missing\0".as_ptr() as *const _,
                Some(transmute(
                    notify_nm_plugin_missing_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_physical_port_id_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_physical_port_id_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::physical-port-id\0".as_ptr() as *const _,
                Some(transmute(
                    notify_physical_port_id_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_product_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_product_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::product\0".as_ptr() as *const _,
                Some(transmute(notify_product_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn connect_property_real_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_real_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::real\0".as_ptr() as *const _,
                Some(transmute(notify_real_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_state_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_state_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::state\0".as_ptr() as *const _,
                Some(transmute(notify_state_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_state_reason_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_state_reason_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::state-reason\0".as_ptr() as *const _,
                Some(transmute(
                    notify_state_reason_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_udi_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_udi_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::udi\0".as_ptr() as *const _,
                Some(transmute(notify_udi_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_vendor_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_vendor_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::vendor\0".as_ptr() as *const _,
                Some(transmute(notify_vendor_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }
}

impl fmt::Display for Device {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Device")
    }
}
