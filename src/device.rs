// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::ActiveConnection;
use crate::Connection;
#[cfg(any(feature = "v1_16", feature = "dox"))]
use crate::ConnectivityState;
use crate::DeviceCapabilities;
#[cfg(any(feature = "v1_22", feature = "dox"))]
use crate::DeviceInterfaceFlags;
use crate::DeviceState;
use crate::DeviceStateReason;
use crate::DeviceType;
use crate::DhcpConfig;
use crate::IPConfig;
#[cfg(any(feature = "v1_2", feature = "dox"))]
use crate::LldpNeighbor;
#[cfg(any(feature = "v1_2", feature = "dox"))]
use crate::Metered;
use crate::Object;
use crate::RemoteConnection;
use gio;
use gio_sys;
use glib;
use glib::object::Cast;
use glib::object::IsA;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib::GString;
use glib::StaticType;
use glib::Value;
use glib_sys;
use gobject_sys;
use libc;
use nm_sys;
use std::boxed::Box as Box_;
use std::fmt;
#[cfg(any(feature = "v1_2", feature = "dox"))]
use std::mem;
use std::mem::transmute;
use std::pin::Pin;
use std::ptr;

glib_wrapper! {
    pub struct Device(Object<nm_sys::NMDevice, nm_sys::NMDeviceClass, DeviceClass>) @extends Object;

    match fn {
        get_type => || nm_sys::nm_device_get_type(),
    }
}

impl Device {
    /// Generates a list of short-ish unique presentation names for the
    /// devices in `devices`.
    /// ## `devices`
    /// an array of `Device`
    /// ## `num_devices`
    /// length of `devices`
    ///
    /// # Returns
    ///
    /// the device names
    pub fn disambiguate_names(devices: &[Device]) -> Vec<GString> {
        let num_devices = devices.len() as i32;
        unsafe {
            FromGlibPtrContainer::from_glib_full(nm_sys::nm_device_disambiguate_names(
                devices.to_glib_none().0,
                num_devices,
            ))
        }
    }
}

pub const NONE_DEVICE: Option<&Device> = None;

/// Trait containing all `Device` methods.
///
/// # Implementors
///
/// [`Device6Lowpan`](struct.Device6Lowpan.html), [`DeviceAdsl`](struct.DeviceAdsl.html), [`DeviceBond`](struct.DeviceBond.html), [`DeviceBridge`](struct.DeviceBridge.html), [`DeviceBt`](struct.DeviceBt.html), [`DeviceDummy`](struct.DeviceDummy.html), [`DeviceEthernet`](struct.DeviceEthernet.html), [`DeviceGeneric`](struct.DeviceGeneric.html), [`DeviceIPTunnel`](struct.DeviceIPTunnel.html), [`DeviceInfiniband`](struct.DeviceInfiniband.html), [`DeviceMacsec`](struct.DeviceMacsec.html), [`DeviceMacvlan`](struct.DeviceMacvlan.html), [`DeviceModem`](struct.DeviceModem.html), [`DeviceOlpcMesh`](struct.DeviceOlpcMesh.html), [`DeviceOvsBridge`](struct.DeviceOvsBridge.html), [`DeviceOvsInterface`](struct.DeviceOvsInterface.html), [`DeviceOvsPort`](struct.DeviceOvsPort.html), [`DevicePpp`](struct.DevicePpp.html), [`DeviceTeam`](struct.DeviceTeam.html), [`DeviceTun`](struct.DeviceTun.html), [`DeviceVlan`](struct.DeviceVlan.html), [`DeviceVrf`](struct.DeviceVrf.html), [`DeviceVxlan`](struct.DeviceVxlan.html), [`DeviceWifiP2P`](struct.DeviceWifiP2P.html), [`DeviceWifi`](struct.DeviceWifi.html), [`DeviceWimax`](struct.DeviceWimax.html), [`DeviceWireGuard`](struct.DeviceWireGuard.html), [`DeviceWpan`](struct.DeviceWpan.html), [`Device`](struct.Device.html)
pub trait DeviceExt: 'static {
    /// Validates a given connection for a given `Device` object and returns
    /// whether the connection may be activated with the device. For example if
    /// `self` is a Wi-Fi device that supports only WEP encryption, the connection
    /// will only be valid if it is a Wi-Fi connection which describes a WEP or open
    /// network, and will not be valid if it describes a WPA network, or if it is
    /// an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
    /// device.
    ///
    /// This function does the same as `DeviceExt::connection_valid`, i.e. checking
    /// compatibility of the given device and connection. But, in addition, it sets
    /// GError when FALSE is returned.
    /// ## `connection`
    /// an `Connection` to validate against `self`
    ///
    /// # Returns
    ///
    /// `true` if the connection may be activated with this device, `false`
    /// if is incompatible with the device's capabilities and characteristics.
    fn connection_compatible<P: IsA<Connection>>(&self, connection: &P) -> Result<(), glib::Error>;

    /// Validates a given connection for a given `Device` object and returns
    /// whether the connection may be activated with the device. For example if
    /// `self` is a Wi-Fi device that supports only WEP encryption, the connection
    /// will only be valid if it is a Wi-Fi connection which describes a WEP or open
    /// network, and will not be valid if it describes a WPA network, or if it is
    /// an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
    /// device.
    /// ## `connection`
    /// an `Connection` to validate against `self`
    ///
    /// # Returns
    ///
    /// `true` if the connection may be activated with this device, `false`
    /// if is incompatible with the device's capabilities and characteristics.
    fn connection_valid<P: IsA<Connection>>(&self, connection: &P) -> bool;

    /// Deletes the software device. Hardware devices can't be deleted.
    ///
    /// # Deprecated since 1.22
    ///
    /// Use `DeviceExt::delete_async` or GDBusConnection.
    /// ## `cancellable`
    /// a `gio::Cancellable`, or `None`
    ///
    /// # Returns
    ///
    /// `true` on success, `false` on error, in which case `error`
    /// will be set.
    #[cfg_attr(feature = "v1_22", deprecated)]
    fn delete<P: IsA<gio::Cancellable>>(&self, cancellable: Option<&P>) -> Result<(), glib::Error>;

    /// Asynchronously begins deleting the software device. Hardware devices can't
    /// be deleted.
    /// ## `cancellable`
    /// a `gio::Cancellable`, or `None`
    /// ## `callback`
    /// callback to be called when delete operation completes
    /// ## `user_data`
    /// caller-specific data passed to `callback`
    fn delete_async<P: IsA<gio::Cancellable>, Q: FnOnce(Result<(), glib::Error>) + Send + 'static>(
        &self,
        cancellable: Option<&P>,
        callback: Q,
    );

    fn delete_async_future(
        &self,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>>;

    /// Disconnects the device if currently connected, and prevents the device from
    /// automatically connecting to networks until the next manual network connection
    /// request.
    ///
    /// # Deprecated since 1.22
    ///
    /// Use `DeviceExt::disconnect_async` or GDBusConnection.
    /// ## `cancellable`
    /// a `gio::Cancellable`, or `None`
    ///
    /// # Returns
    ///
    /// `true` on success, `false` on error, in which case `error` will be set.
    #[cfg_attr(feature = "v1_22", deprecated)]
    fn disconnect<P: IsA<gio::Cancellable>>(
        &self,
        cancellable: Option<&P>,
    ) -> Result<(), glib::Error>;

    /// Asynchronously begins disconnecting the device if currently connected, and
    /// prevents the device from automatically connecting to networks until the next
    /// manual network connection request.
    /// ## `cancellable`
    /// a `gio::Cancellable`, or `None`
    /// ## `callback`
    /// callback to be called when the disconnect operation completes
    /// ## `user_data`
    /// caller-specific data passed to `callback`
    fn disconnect_async<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
    >(
        &self,
        cancellable: Option<&P>,
        callback: Q,
    );

    fn disconnect_async_future(
        &self,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>>;

    /// Filters a given array of connections for a given `Device` object and returns
    /// connections which may be activated with the device. For example if `self`
    /// is a Wi-Fi device that supports only WEP encryption, the returned array will
    /// contain any Wi-Fi connections in `connections` that allow connection to
    /// unencrypted or WEP-enabled SSIDs. The returned array will not contain
    /// Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
    /// incompatible with the device. To get the full list of connections see
    /// `Client::get_connections`.
    /// ## `connections`
    /// an array of `NMConnections` to filter
    ///
    /// # Returns
    ///
    /// an array of
    /// `NMConnections` that could be activated with the given `self`. The array
    /// should be freed with `glib::PtrArray::unref` when it is no longer required.
    fn filter_connections(&self, connections: &[Connection]) -> Vec<Connection>;

    /// Gets the `ActiveConnection` object which owns this device during activation.
    ///
    /// # Returns
    ///
    /// the `ActiveConnection` or `None` if the device is
    /// not part of an active connection
    fn get_active_connection(&self) -> Option<ActiveConnection>;

    /// Fetch the currently applied connection on the device.
    ///
    /// Feature: `v1_2`
    ///
    ///
    /// # Deprecated since 1.22
    ///
    /// Use `DeviceExt::get_applied_connection_async` or GDBusConnection.
    /// ## `flags`
    /// the flags argument. Currently this value must always be zero.
    /// ## `version_id`
    /// returns the current version id of
    ///  the applied connection
    /// ## `cancellable`
    /// a `gio::Cancellable`, or `None`
    ///
    /// # Returns
    ///
    /// a `Connection` with the currently applied settings
    ///  or `None` on error.
    ///
    /// The connection is as received from D-Bus and might not validate according
    /// to `Connection::verify`.
    #[cfg_attr(feature = "v1_22", deprecated)]
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_applied_connection<P: IsA<gio::Cancellable>>(
        &self,
        flags: u32,
        cancellable: Option<&P>,
    ) -> Result<(Connection, u64), glib::Error>;

    /// Asynchronously begins and gets the currently applied connection.
    ///
    /// Feature: `v1_2`
    ///
    /// ## `flags`
    /// the flags argument. Currently this value must always be zero.
    /// ## `cancellable`
    /// a `gio::Cancellable`, or `None`
    /// ## `callback`
    /// callback to be called when the reapply operation completes
    /// ## `user_data`
    /// caller-specific data passed to `callback`
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_applied_connection_async<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(Connection, u64), glib::Error>) + Send + 'static,
    >(
        &self,
        flags: u32,
        cancellable: Option<&P>,
        callback: Q,
    );

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_applied_connection_async_future(
        &self,
        flags: u32,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(Connection, u64), glib::Error>> + 'static>>;

    /// Whether the `Device` can be autoconnected.
    ///
    /// # Returns
    ///
    /// `true` if the device is allowed to be autoconnected
    fn get_autoconnect(&self) -> bool;

    /// Gets the `NMRemoteConnections` currently known to the daemon that could
    /// be activated on `self`.
    ///
    /// # Returns
    ///
    /// the `glib::PtrArray`
    /// containing `NMRemoteConnections`. This is the internal copy used by
    /// the connection, and must not be modified.
    fn get_available_connections(&self) -> Vec<RemoteConnection>;

    /// Gets the device' capabilities.
    ///
    /// # Returns
    ///
    /// the capabilities
    fn get_capabilities(&self) -> DeviceCapabilities;

    /// The connectivity state of the device for given address family.
    /// Supported address families are `AF_INET` for IPv4, `AF_INET6`
    /// for IPv6 or `AF_UNSPEC` for any.
    ///
    /// Feature: `v1_16`
    ///
    /// ## `addr_family`
    /// network address family
    ///
    /// # Returns
    ///
    /// the current connectivity state
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    fn get_connectivity(&self, addr_family: i32) -> ConnectivityState;

    /// Gets a description of `self`, based on its vendor and product names.
    ///
    /// # Returns
    ///
    /// a description of `self`. If either the vendor or the
    ///  product name is unknown, this returns the interface name.
    fn get_description(&self) -> Option<GString>;

    /// Returns the numeric type of the `Device`, ie Ethernet, Wi-Fi, etc.
    ///
    /// # Returns
    ///
    /// the device type
    fn get_device_type(&self) -> DeviceType;

    /// Gets the current IPv4 `DhcpConfig` associated with the `Device`.
    ///
    /// You can alternatively use `ActiveConnectionExt::get_dhcp4_config`, which also
    /// works with VPN connections.
    ///
    /// # Returns
    ///
    /// the IPv4 `DhcpConfig`, or `None` if the device is
    /// not activated or not using DHCP.
    fn get_dhcp4_config(&self) -> Option<DhcpConfig>;

    /// Gets the current IPv6 `DhcpConfig` associated with the `Device`.
    ///
    /// You can alternatively use `ActiveConnectionExt::get_dhcp6_config`, which also
    /// works with VPN connections.
    ///
    /// # Returns
    ///
    /// the IPv6 `DhcpConfig`, or `None` if the device is
    /// not activated or not using DHCPv6.
    fn get_dhcp6_config(&self) -> Option<DhcpConfig>;

    /// Gets the driver of the `Device`.
    ///
    /// # Returns
    ///
    /// the driver of the device. This is the internal string used by the
    /// device, and must not be modified.
    fn get_driver(&self) -> Option<GString>;

    /// Gets the driver version of the `Device`.
    ///
    /// # Returns
    ///
    /// the version of the device driver. This is the internal string used by the
    /// device, and must not be modified.
    fn get_driver_version(&self) -> Option<GString>;

    /// Indicates that firmware required for the device's operation is likely
    /// to be missing.
    ///
    /// # Returns
    ///
    /// `true` if firmware required for the device's operation is likely
    /// to be missing.
    fn get_firmware_missing(&self) -> bool;

    /// Gets the firmware version of the `Device`.
    ///
    /// # Returns
    ///
    /// the firmware version of the device. This is the internal string used by the
    /// device, and must not be modified.
    fn get_firmware_version(&self) -> Option<GString>;

    /// Gets the current a hardware address (MAC) for the `self`.
    ///
    /// # Returns
    ///
    /// the current MAC of the device, or `None`.
    /// This is the internal string used by the device, and must not be modified.
    fn get_hw_address(&self) -> Option<GString>;

    /// Gets the interface name of the `Device`.
    ///
    /// # Returns
    ///
    /// the interface of the device. This is the internal string used by the
    /// device, and must not be modified.
    fn get_iface(&self) -> Option<GString>;

    /// Gets the interface flags of the device.
    ///
    /// Feature: `v1_22`
    ///
    ///
    /// # Returns
    ///
    /// the flags
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    fn get_interface_flags(&self) -> DeviceInterfaceFlags;

    /// Gets the current IPv4 `IPConfig` associated with the `Device`.
    ///
    /// You can alternatively use `ActiveConnectionExt::get_ip4_config`, which also
    /// works with VPN connections.
    ///
    /// # Returns
    ///
    /// the IPv4 `IPConfig`, or `None` if the device is not
    /// activated.
    fn get_ip4_config(&self) -> Option<IPConfig>;

    /// Gets the current IPv6 `IPConfig` associated with the `Device`.
    ///
    /// You can alternatively use `ActiveConnectionExt::get_ip6_config`, which also
    /// works with VPN connections.
    ///
    /// # Returns
    ///
    /// the IPv6 `IPConfig` or `None` if the device is not activated.
    fn get_ip6_config(&self) -> Option<IPConfig>;

    /// Gets the IP interface name of the `Device` over which IP traffic flows
    /// when the device is in the ACTIVATED state.
    ///
    /// # Returns
    ///
    /// the IP traffic interface of the device. This is the internal string
    /// used by the device, and must not be modified.
    fn get_ip_iface(&self) -> Option<GString>;

    /// Gets the list of neighbors discovered through LLDP.
    ///
    /// Feature: `v1_2`
    ///
    ///
    /// # Returns
    ///
    /// the `glib::PtrArray`
    /// containing `LldpNeighbor`<!-- -->s. This is the internal copy used by the
    /// device and must not be modified. The library never modifies the returned
    /// array and thus it is safe for callers to reference and keep using it.
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_lldp_neighbors(&self) -> Vec<LldpNeighbor>;

    /// Whether the `Device` is managed by NetworkManager.
    ///
    /// # Returns
    ///
    /// `true` if the device is managed by NetworkManager
    fn get_managed(&self) -> bool;

    /// Gets the metered setting of a `Device`.
    ///
    /// Feature: `v1_2`
    ///
    ///
    /// # Returns
    ///
    /// the metered setting.
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_metered(&self) -> Metered;

    /// Gets the MTU of the `Device`.
    ///
    /// # Returns
    ///
    /// the MTU of the device in bytes.
    fn get_mtu(&self) -> u32;

    /// Indicates that the NetworkManager plugin for the device is not installed.
    ///
    /// Feature: `v1_2`
    ///
    ///
    /// # Returns
    ///
    /// `true` if the device plugin not installed.
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_nm_plugin_missing(&self) -> bool;

    /// Gets the physical port ID of the `Device`. If non-`None`, this is
    /// an opaque string that can be used to recognize when
    /// seemingly-unrelated `NMDevices` are actually just different virtual
    /// ports on a single physical port. (Eg, NPAR / SR-IOV.)
    ///
    /// # Returns
    ///
    /// the physical port ID of the device, or `None` if the port
    ///  ID is unknown. This is the internal string used by the device and
    ///  must not be modified.
    fn get_physical_port_id(&self) -> Option<GString>;

    /// Gets the product string of the `Device`.
    ///
    /// # Returns
    ///
    /// the product name of the device. This is the internal string used by the
    /// device, and must not be modified.
    ///
    /// The string is backslash escaped (C escaping) for invalid characters. The escaping
    /// can be reverted with `g_strcompress`, however the result may not be valid UTF-8.
    fn get_product(&self) -> Option<GString>;

    /// Gets the (primary) `Setting` subtype associated with connections
    /// that can be used on `self`.
    ///
    /// # Returns
    ///
    /// `self`'s associated `Setting` type
    fn get_setting_type(&self) -> glib::types::Type;

    /// Gets the current `Device` state.
    ///
    /// # Returns
    ///
    /// the current device state
    fn get_state(&self) -> DeviceState;

    /// Gets the reason for entering the current `Device` state.
    ///
    /// # Returns
    ///
    /// the reason for entering the current device state
    fn get_state_reason(&self) -> DeviceStateReason;

    /// Gets a (non-localized) description of the type of device that
    /// `self` is.
    ///
    /// # Returns
    ///
    /// the type description of the device. This is the internal
    /// string used by the device, and must not be modified.
    fn get_type_description(&self) -> Option<GString>;

    /// Gets the Unique Device Identifier of the `Device`.
    ///
    /// # Returns
    ///
    /// the Unique Device Identifier of the device. This identifier may be
    /// used to gather more information about the device from various operating
    /// system services like udev or sysfs.
    fn get_udi(&self) -> Option<GString>;

    /// Gets the vendor string of the `Device`.
    ///
    /// # Returns
    ///
    /// the vendor name of the device. This is the internal string used by the
    /// device, and must not be modified.
    ///
    /// The string is backslash escaped (C escaping) for invalid characters. The escaping
    /// can be reverted with `g_strcompress`, however the result may not be valid UTF-8.
    fn get_vendor(&self) -> Option<GString>;

    ///
    /// Feature: `v1_2`
    ///
    ///
    /// # Returns
    ///
    /// `true` if the device exists, or `false` if it is a placeholder device
    /// that could be automatically created by NetworkManager if one of its
    /// `Device:available-connections` was activated.
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn is_real(&self) -> bool;

    /// Whether the device is a software device.
    ///
    /// # Returns
    ///
    /// `true` if `self` is a software device, `false` if it is a hardware device.
    fn is_software(&self) -> bool;

    /// Attempts to update device with changes to the currently active connection
    /// made since it was last applied.
    ///
    /// Feature: `v1_2`
    ///
    ///
    /// # Deprecated since 1.22
    ///
    /// Use `DeviceExt::reapply_async` or GDBusConnection.
    /// ## `connection`
    /// the `Connection` to replace the applied
    ///  settings with or `None` to reuse existing
    /// ## `version_id`
    /// zero or the expected version id of the applied connection.
    ///  If specified and the version id mismatches, the call fails without
    ///  modification. This allows to catch concurrent accesses.
    /// ## `flags`
    /// always set this to zero
    /// ## `cancellable`
    /// a `gio::Cancellable`, or `None`
    ///
    /// # Returns
    ///
    /// `true` on success, `false` on error, in which case `error` will be set.
    #[cfg_attr(feature = "v1_22", deprecated)]
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn reapply<P: IsA<Connection>, Q: IsA<gio::Cancellable>>(
        &self,
        connection: Option<&P>,
        version_id: u64,
        flags: u32,
        cancellable: Option<&Q>,
    ) -> Result<(), glib::Error>;

    /// Asynchronously begins an attempt to update device with changes to the
    /// currently active connection made since it was last applied.
    ///
    /// Feature: `v1_2`
    ///
    /// ## `connection`
    /// the `Connection` to replace the applied
    ///  settings with or `None` to reuse existing
    /// ## `version_id`
    /// zero or the expected version id of the applied
    ///  connection. If specified and the version id mismatches, the call
    ///  fails without modification. This allows to catch concurrent
    ///  accesses.
    /// ## `flags`
    /// always set this to zero
    /// ## `cancellable`
    /// a `gio::Cancellable`, or `None`
    /// ## `callback`
    /// callback to be called when the reapply operation completes
    /// ## `user_data`
    /// caller-specific data passed to `callback`
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn reapply_async<
        P: IsA<Connection>,
        Q: IsA<gio::Cancellable>,
        R: FnOnce(Result<(), glib::Error>) + Send + 'static,
    >(
        &self,
        connection: Option<&P>,
        version_id: u64,
        flags: u32,
        cancellable: Option<&Q>,
        callback: R,
    );

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn reapply_async_future<P: IsA<Connection> + Clone + 'static>(
        &self,
        connection: Option<&P>,
        version_id: u64,
        flags: u32,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>>;

    /// Enables or disables automatic activation of the `Device`.
    ///
    /// # Deprecated since 1.22
    ///
    /// Use the async command `Client::dbus_set_property` on
    /// `ObjectExt::get_path`, `NM_DBUS_INTERFACE_DEVICE` to set "AutoConnect" property to a "(b)" value.
    /// This function is deprecated because it calls a synchronous D-Bus method
    /// and modifies the content of the NMClient cache client side.
    /// ## `autoconnect`
    /// `true` to enable autoconnecting
    #[cfg_attr(feature = "v1_22", deprecated)]
    fn set_autoconnect(&self, autoconnect: bool);

    /// Enables or disables management of `Device` by NetworkManager.
    ///
    /// Feature: `v1_2`
    ///
    ///
    /// # Deprecated since 1.22
    ///
    /// Use the async command `Client::dbus_set_property` on
    /// `ObjectExt::get_path`, interface `NM_DBUS_INTERFACE_DEVICE` to set the
    /// "Managed" property to a "(b)" boolean value.
    /// This function is deprecated because it calls a synchronous D-Bus method
    /// and modifies the content of the NMClient cache client side. Also, it does
    /// not emit a property changed signal.
    /// ## `managed`
    /// `true` to make the device managed by NetworkManager.
    #[cfg_attr(feature = "v1_22", deprecated)]
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn set_managed(&self, managed: bool);

    /// The interface of the device.
    fn get_property_interface(&self) -> Option<GString>;

    /// The IP interface of the device which should be used for all IP-related
    /// operations like addressing and routing.
    fn get_property_ip_interface(&self) -> Option<GString>;

    /// The IPv4 connectivity state of the device.
    ///
    /// Feature: `v1_16`
    ///
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    fn get_property_ip4_connectivity(&self) -> ConnectivityState;

    /// The IPv6 connectivity state of the device.
    ///
    /// Feature: `v1_16`
    ///
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    fn get_property_ip6_connectivity(&self) -> ConnectivityState;

    //fn get_property_lldp_neighbors(&self) -> /*Unimplemented*/Vec<Fundamental: Pointer>;

    /// Whether the device is real or is a placeholder device that could
    /// be created automatically by NetworkManager if one of its
    /// `Device:available-connections` was activated.
    ///
    /// Feature: `v1_2`
    ///
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_property_real(&self) -> bool;

    /// Notifies the state change of a `Device`.
    /// ## `new_state`
    /// the new state of the device
    /// ## `old_state`
    /// the previous state of the device
    /// ## `reason`
    /// the reason describing the state change
    fn connect_state_changed<F: Fn(&Self, u32, u32, u32) + 'static>(&self, f: F)
        -> SignalHandlerId;

    fn connect_property_active_connection_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_autoconnect_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_available_connections_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_capabilities_notify<F: Fn(&Self) + 'static>(&self, f: F)
        -> SignalHandlerId;

    fn connect_property_device_type_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_dhcp4_config_notify<F: Fn(&Self) + 'static>(&self, f: F)
        -> SignalHandlerId;

    fn connect_property_dhcp6_config_notify<F: Fn(&Self) + 'static>(&self, f: F)
        -> SignalHandlerId;

    fn connect_property_driver_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_driver_version_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_firmware_missing_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_firmware_version_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[cfg(any(feature = "v1_24", feature = "dox"))]
    fn connect_property_hw_address_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_interface_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_22", feature = "dox"))]
    fn connect_property_interface_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_ip_interface_notify<F: Fn(&Self) + 'static>(&self, f: F)
        -> SignalHandlerId;

    fn connect_property_ip4_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    fn connect_property_ip4_connectivity_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_ip6_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    fn connect_property_ip6_connectivity_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_lldp_neighbors_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_managed_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn connect_property_metered_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_mtu_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn connect_property_nm_plugin_missing_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_physical_port_id_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_product_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn connect_property_real_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_state_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_state_reason_notify<F: Fn(&Self) + 'static>(&self, f: F)
        -> SignalHandlerId;

    fn connect_property_udi_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_vendor_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<Device>> DeviceExt for O {
    fn connection_compatible<P: IsA<Connection>>(&self, connection: &P) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = nm_sys::nm_device_connection_compatible(
                self.as_ref().to_glib_none().0,
                connection.as_ref().to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn connection_valid<P: IsA<Connection>>(&self, connection: &P) -> bool {
        unsafe {
            from_glib(nm_sys::nm_device_connection_valid(
                self.as_ref().to_glib_none().0,
                connection.as_ref().to_glib_none().0,
            ))
        }
    }

    fn delete<P: IsA<gio::Cancellable>>(&self, cancellable: Option<&P>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = nm_sys::nm_device_delete(
                self.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn delete_async<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
    >(
        &self,
        cancellable: Option<&P>,
        callback: Q,
    ) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn delete_async_trampoline<
            Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
        >(
            _source_object: *mut gobject_sys::GObject,
            res: *mut gio_sys::GAsyncResult,
            user_data: glib_sys::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let _ = nm_sys::nm_device_delete_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = delete_async_trampoline::<Q>;
        unsafe {
            nm_sys::nm_device_delete_async(
                self.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn delete_async_future(
        &self,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {
        Box_::pin(gio::GioFuture::new(self, move |obj, send| {
            let cancellable = gio::Cancellable::new();
            obj.delete_async(Some(&cancellable), move |res| {
                send.resolve(res);
            });

            cancellable
        }))
    }

    fn disconnect<P: IsA<gio::Cancellable>>(
        &self,
        cancellable: Option<&P>,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = nm_sys::nm_device_disconnect(
                self.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn disconnect_async<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
    >(
        &self,
        cancellable: Option<&P>,
        callback: Q,
    ) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn disconnect_async_trampoline<
            Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
        >(
            _source_object: *mut gobject_sys::GObject,
            res: *mut gio_sys::GAsyncResult,
            user_data: glib_sys::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let _ = nm_sys::nm_device_disconnect_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = disconnect_async_trampoline::<Q>;
        unsafe {
            nm_sys::nm_device_disconnect_async(
                self.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn disconnect_async_future(
        &self,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {
        Box_::pin(gio::GioFuture::new(self, move |obj, send| {
            let cancellable = gio::Cancellable::new();
            obj.disconnect_async(Some(&cancellable), move |res| {
                send.resolve(res);
            });

            cancellable
        }))
    }

    fn filter_connections(&self, connections: &[Connection]) -> Vec<Connection> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(nm_sys::nm_device_filter_connections(
                self.as_ref().to_glib_none().0,
                connections.to_glib_none().0,
            ))
        }
    }

    fn get_active_connection(&self) -> Option<ActiveConnection> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_active_connection(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_applied_connection<P: IsA<gio::Cancellable>>(
        &self,
        flags: u32,
        cancellable: Option<&P>,
    ) -> Result<(Connection, u64), glib::Error> {
        unsafe {
            let mut version_id = mem::MaybeUninit::uninit();
            let mut error = ptr::null_mut();
            let ret = nm_sys::nm_device_get_applied_connection(
                self.as_ref().to_glib_none().0,
                flags,
                version_id.as_mut_ptr(),
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            let version_id = version_id.assume_init();
            if error.is_null() {
                Ok((from_glib_full(ret), version_id))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_applied_connection_async<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(Connection, u64), glib::Error>) + Send + 'static,
    >(
        &self,
        flags: u32,
        cancellable: Option<&P>,
        callback: Q,
    ) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn get_applied_connection_async_trampoline<
            Q: FnOnce(Result<(Connection, u64), glib::Error>) + Send + 'static,
        >(
            _source_object: *mut gobject_sys::GObject,
            res: *mut gio_sys::GAsyncResult,
            user_data: glib_sys::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let mut version_id = mem::MaybeUninit::uninit();
            let ret = nm_sys::nm_device_get_applied_connection_finish(
                _source_object as *mut _,
                res,
                version_id.as_mut_ptr(),
                &mut error,
            );
            let version_id = version_id.assume_init();
            let result = if error.is_null() {
                Ok((from_glib_full(ret), version_id))
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = get_applied_connection_async_trampoline::<Q>;
        unsafe {
            nm_sys::nm_device_get_applied_connection_async(
                self.as_ref().to_glib_none().0,
                flags,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_applied_connection_async_future(
        &self,
        flags: u32,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(Connection, u64), glib::Error>> + 'static>>
    {
        Box_::pin(gio::GioFuture::new(self, move |obj, send| {
            let cancellable = gio::Cancellable::new();
            obj.get_applied_connection_async(flags, Some(&cancellable), move |res| {
                send.resolve(res);
            });

            cancellable
        }))
    }

    fn get_autoconnect(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_device_get_autoconnect(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_available_connections(&self) -> Vec<RemoteConnection> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(nm_sys::nm_device_get_available_connections(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_capabilities(&self) -> DeviceCapabilities {
        unsafe {
            from_glib(nm_sys::nm_device_get_capabilities(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    fn get_connectivity(&self, addr_family: i32) -> ConnectivityState {
        unsafe {
            from_glib(nm_sys::nm_device_get_connectivity(
                self.as_ref().to_glib_none().0,
                addr_family,
            ))
        }
    }

    fn get_description(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_description(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_device_type(&self) -> DeviceType {
        unsafe {
            from_glib(nm_sys::nm_device_get_device_type(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_dhcp4_config(&self) -> Option<DhcpConfig> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_dhcp4_config(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_dhcp6_config(&self) -> Option<DhcpConfig> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_dhcp6_config(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_driver(&self) -> Option<GString> {
        unsafe { from_glib_none(nm_sys::nm_device_get_driver(self.as_ref().to_glib_none().0)) }
    }

    fn get_driver_version(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_driver_version(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_firmware_missing(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_device_get_firmware_missing(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_firmware_version(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_firmware_version(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_hw_address(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_hw_address(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_iface(&self) -> Option<GString> {
        unsafe { from_glib_none(nm_sys::nm_device_get_iface(self.as_ref().to_glib_none().0)) }
    }

    #[cfg(any(feature = "v1_22", feature = "dox"))]
    fn get_interface_flags(&self) -> DeviceInterfaceFlags {
        unsafe {
            from_glib(nm_sys::nm_device_get_interface_flags(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_ip4_config(&self) -> Option<IPConfig> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_ip4_config(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_ip6_config(&self) -> Option<IPConfig> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_ip6_config(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_ip_iface(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_ip_iface(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_lldp_neighbors(&self) -> Vec<LldpNeighbor> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(nm_sys::nm_device_get_lldp_neighbors(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_managed(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_device_get_managed(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_metered(&self) -> Metered {
        unsafe {
            from_glib(nm_sys::nm_device_get_metered(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_mtu(&self) -> u32 {
        unsafe { nm_sys::nm_device_get_mtu(self.as_ref().to_glib_none().0) }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_nm_plugin_missing(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_device_get_nm_plugin_missing(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_physical_port_id(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_physical_port_id(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_product(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_product(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_setting_type(&self) -> glib::types::Type {
        unsafe {
            from_glib(nm_sys::nm_device_get_setting_type(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_state(&self) -> DeviceState {
        unsafe { from_glib(nm_sys::nm_device_get_state(self.as_ref().to_glib_none().0)) }
    }

    fn get_state_reason(&self) -> DeviceStateReason {
        unsafe {
            from_glib(nm_sys::nm_device_get_state_reason(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_type_description(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_device_get_type_description(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_udi(&self) -> Option<GString> {
        unsafe { from_glib_none(nm_sys::nm_device_get_udi(self.as_ref().to_glib_none().0)) }
    }

    fn get_vendor(&self) -> Option<GString> {
        unsafe { from_glib_none(nm_sys::nm_device_get_vendor(self.as_ref().to_glib_none().0)) }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn is_real(&self) -> bool {
        unsafe { from_glib(nm_sys::nm_device_is_real(self.as_ref().to_glib_none().0)) }
    }

    fn is_software(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_device_is_software(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn reapply<P: IsA<Connection>, Q: IsA<gio::Cancellable>>(
        &self,
        connection: Option<&P>,
        version_id: u64,
        flags: u32,
        cancellable: Option<&Q>,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = nm_sys::nm_device_reapply(
                self.as_ref().to_glib_none().0,
                connection.map(|p| p.as_ref()).to_glib_none().0,
                version_id,
                flags,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn reapply_async<
        P: IsA<Connection>,
        Q: IsA<gio::Cancellable>,
        R: FnOnce(Result<(), glib::Error>) + Send + 'static,
    >(
        &self,
        connection: Option<&P>,
        version_id: u64,
        flags: u32,
        cancellable: Option<&Q>,
        callback: R,
    ) {
        let user_data: Box_<R> = Box_::new(callback);
        unsafe extern "C" fn reapply_async_trampoline<
            R: FnOnce(Result<(), glib::Error>) + Send + 'static,
        >(
            _source_object: *mut gobject_sys::GObject,
            res: *mut gio_sys::GAsyncResult,
            user_data: glib_sys::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let _ = nm_sys::nm_device_reapply_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<R> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = reapply_async_trampoline::<R>;
        unsafe {
            nm_sys::nm_device_reapply_async(
                self.as_ref().to_glib_none().0,
                connection.map(|p| p.as_ref()).to_glib_none().0,
                version_id,
                flags,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn reapply_async_future<P: IsA<Connection> + Clone + 'static>(
        &self,
        connection: Option<&P>,
        version_id: u64,
        flags: u32,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {
        let connection = connection.map(ToOwned::to_owned);
        Box_::pin(gio::GioFuture::new(self, move |obj, send| {
            let cancellable = gio::Cancellable::new();
            obj.reapply_async(
                connection.as_ref().map(::std::borrow::Borrow::borrow),
                version_id,
                flags,
                Some(&cancellable),
                move |res| {
                    send.resolve(res);
                },
            );

            cancellable
        }))
    }

    fn set_autoconnect(&self, autoconnect: bool) {
        unsafe {
            nm_sys::nm_device_set_autoconnect(
                self.as_ref().to_glib_none().0,
                autoconnect.to_glib(),
            );
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn set_managed(&self, managed: bool) {
        unsafe {
            nm_sys::nm_device_set_managed(self.as_ref().to_glib_none().0, managed.to_glib());
        }
    }

    fn get_property_interface(&self) -> Option<GString> {
        unsafe {
            let mut value = Value::from_type(<GString as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"interface\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `interface` getter")
        }
    }

    fn get_property_ip_interface(&self) -> Option<GString> {
        unsafe {
            let mut value = Value::from_type(<GString as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"ip-interface\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `ip-interface` getter")
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    fn get_property_ip4_connectivity(&self) -> ConnectivityState {
        unsafe {
            let mut value = Value::from_type(<ConnectivityState as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"ip4-connectivity\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `ip4-connectivity` getter")
                .unwrap()
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    fn get_property_ip6_connectivity(&self) -> ConnectivityState {
        unsafe {
            let mut value = Value::from_type(<ConnectivityState as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"ip6-connectivity\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `ip6-connectivity` getter")
                .unwrap()
        }
    }

    //fn get_property_lldp_neighbors(&self) -> /*Unimplemented*/Vec<Fundamental: Pointer> {
    //    unsafe {
    //        let mut value = Value::from_type(</*Unknown type*/ as StaticType>::static_type());
    //        gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"lldp-neighbors\0".as_ptr() as *const _, value.to_glib_none_mut().0);
    //        value.get().expect("Return Value for property `lldp-neighbors` getter")
    //    }
    //}

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_property_real(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"real\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `real` getter")
                .unwrap()
        }
    }

    fn connect_state_changed<F: Fn(&Self, u32, u32, u32) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn state_changed_trampoline<P, F: Fn(&P, u32, u32, u32) + 'static>(
            this: *mut nm_sys::NMDevice,
            new_state: libc::c_uint,
            old_state: libc::c_uint,
            reason: libc::c_uint,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(
                &Device::from_glib_borrow(this).unsafe_cast_ref(),
                new_state,
                old_state,
                reason,
            )
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"state-changed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    state_changed_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_active_connection_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_active_connection_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::active-connection\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_active_connection_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_autoconnect_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_autoconnect_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::autoconnect\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_autoconnect_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_available_connections_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_available_connections_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::available-connections\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_available_connections_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_capabilities_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_capabilities_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::capabilities\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_capabilities_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_device_type_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_device_type_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::device-type\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_device_type_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_dhcp4_config_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_dhcp4_config_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::dhcp4-config\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_dhcp4_config_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_dhcp6_config_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_dhcp6_config_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::dhcp6-config\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_dhcp6_config_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_driver_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_driver_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::driver\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_driver_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_driver_version_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_driver_version_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::driver-version\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_driver_version_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_firmware_missing_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_firmware_missing_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::firmware-missing\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_firmware_missing_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_firmware_version_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_firmware_version_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::firmware-version\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_firmware_version_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_24", feature = "dox"))]
    fn connect_property_hw_address_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_hw_address_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::hw-address\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_hw_address_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_interface_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_interface_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::interface\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_interface_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_22", feature = "dox"))]
    fn connect_property_interface_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_interface_flags_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::interface-flags\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_interface_flags_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_ip_interface_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip_interface_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::ip-interface\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_ip_interface_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_ip4_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip4_config_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::ip4-config\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_ip4_config_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    fn connect_property_ip4_connectivity_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip4_connectivity_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::ip4-connectivity\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_ip4_connectivity_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_ip6_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip6_config_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::ip6-config\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_ip6_config_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    fn connect_property_ip6_connectivity_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip6_connectivity_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::ip6-connectivity\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_ip6_connectivity_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_lldp_neighbors_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_lldp_neighbors_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::lldp-neighbors\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_lldp_neighbors_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_managed_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_managed_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::managed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_managed_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn connect_property_metered_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_metered_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::metered\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_metered_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_mtu_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mtu_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::mtu\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_mtu_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn connect_property_nm_plugin_missing_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_nm_plugin_missing_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::nm-plugin-missing\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_nm_plugin_missing_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_physical_port_id_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_physical_port_id_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::physical-port-id\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_physical_port_id_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_product_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_product_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::product\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_product_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn connect_property_real_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_real_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::real\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_real_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_state_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_state_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::state\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_state_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_state_reason_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_state_reason_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::state-reason\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_state_reason_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_udi_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_udi_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::udi\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_udi_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_vendor_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_vendor_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMDevice,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Device>,
        {
            let f: &F = &*(f as *const F);
            f(&Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::vendor\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_vendor_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl fmt::Display for Device {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Device")
    }
}
