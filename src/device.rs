// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files
// DO NOT EDIT

use crate::ActiveConnection;
use crate::Connection;
#[cfg(any(feature = "v1_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
use crate::ConnectivityState;
use crate::DeviceCapabilities;
#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
use crate::DeviceInterfaceFlags;
use crate::DeviceState;
use crate::DeviceStateReason;
use crate::DeviceType;
use crate::DhcpConfig;
use crate::IPConfig;
#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
use crate::LldpNeighbor;
#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
use crate::Metered;
use crate::Object;
use crate::RemoteConnection;
use glib::object::Cast;
use glib::object::IsA;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib::StaticType;
use std::boxed::Box as Box_;
use std::fmt;
#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
use std::mem;
use std::mem::transmute;
use std::pin::Pin;
use std::ptr;

glib::wrapper! {
    #[doc(alias = "NMDevice")]
    pub struct Device(Object<ffi::NMDevice, ffi::NMDeviceClass>) @extends Object;

    match fn {
        type_ => || ffi::nm_device_get_type(),
    }
}

impl Device {
    pub const NONE: Option<&'static Device> = None;

    /// Generates a list of short-ish unique presentation names for the
    /// devices in `devices`.
    /// ## `devices`
    /// an array of [`Device`][crate::Device]
    ///
    /// # Returns
    ///
    /// the device names
    #[doc(alias = "nm_device_disambiguate_names")]
    pub fn disambiguate_names(devices: &[Device]) -> Vec<glib::GString> {
        let num_devices = devices.len() as i32;
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::nm_device_disambiguate_names(
                devices.to_glib_none().0,
                num_devices,
            ))
        }
    }
}

/// Trait containing all [`struct@Device`] methods.
///
/// # Implementors
///
/// [`Device6Lowpan`][struct@crate::Device6Lowpan], [`DeviceAdsl`][struct@crate::DeviceAdsl], [`DeviceBond`][struct@crate::DeviceBond], [`DeviceBridge`][struct@crate::DeviceBridge], [`DeviceBt`][struct@crate::DeviceBt], [`DeviceDummy`][struct@crate::DeviceDummy], [`DeviceEthernet`][struct@crate::DeviceEthernet], [`DeviceGeneric`][struct@crate::DeviceGeneric], [`DeviceIPTunnel`][struct@crate::DeviceIPTunnel], [`DeviceInfiniband`][struct@crate::DeviceInfiniband], [`DeviceMacsec`][struct@crate::DeviceMacsec], [`DeviceMacvlan`][struct@crate::DeviceMacvlan], [`DeviceModem`][struct@crate::DeviceModem], [`DeviceOlpcMesh`][struct@crate::DeviceOlpcMesh], [`DeviceOvsBridge`][struct@crate::DeviceOvsBridge], [`DeviceOvsInterface`][struct@crate::DeviceOvsInterface], [`DeviceOvsPort`][struct@crate::DeviceOvsPort], [`DevicePpp`][struct@crate::DevicePpp], [`DeviceTeam`][struct@crate::DeviceTeam], [`DeviceTun`][struct@crate::DeviceTun], [`DeviceVlan`][struct@crate::DeviceVlan], [`DeviceVrf`][struct@crate::DeviceVrf], [`DeviceVxlan`][struct@crate::DeviceVxlan], [`DeviceWifiP2P`][struct@crate::DeviceWifiP2P], [`DeviceWifi`][struct@crate::DeviceWifi], [`DeviceWimax`][struct@crate::DeviceWimax], [`DeviceWireGuard`][struct@crate::DeviceWireGuard], [`DeviceWpan`][struct@crate::DeviceWpan], [`Device`][struct@crate::Device]
pub trait DeviceExt: 'static {
    /// Validates a given connection for a given [`Device`][crate::Device] object and returns
    /// whether the connection may be activated with the device. For example if
    /// `self` is a Wi-Fi device that supports only WEP encryption, the connection
    /// will only be valid if it is a Wi-Fi connection which describes a WEP or open
    /// network, and will not be valid if it describes a WPA network, or if it is
    /// an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
    /// device.
    ///
    /// This function does the same as [`connection_valid()`][Self::connection_valid()], i.e. checking
    /// compatibility of the given device and connection. But, in addition, it sets
    /// GError when FALSE is returned.
    /// ## `connection`
    /// an [`Connection`][crate::Connection] to validate against `self`
    ///
    /// # Returns
    ///
    /// [`true`] if the connection may be activated with this device, [`false`]
    /// if is incompatible with the device's capabilities and characteristics.
    #[doc(alias = "nm_device_connection_compatible")]
    fn connection_compatible(&self, connection: &impl IsA<Connection>) -> Result<(), glib::Error>;

    /// Validates a given connection for a given [`Device`][crate::Device] object and returns
    /// whether the connection may be activated with the device. For example if
    /// `self` is a Wi-Fi device that supports only WEP encryption, the connection
    /// will only be valid if it is a Wi-Fi connection which describes a WEP or open
    /// network, and will not be valid if it describes a WPA network, or if it is
    /// an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
    /// device.
    /// ## `connection`
    /// an [`Connection`][crate::Connection] to validate against `self`
    ///
    /// # Returns
    ///
    /// [`true`] if the connection may be activated with this device, [`false`]
    /// if is incompatible with the device's capabilities and characteristics.
    #[doc(alias = "nm_device_connection_valid")]
    fn connection_valid(&self, connection: &impl IsA<Connection>) -> bool;

    /// Deletes the software device. Hardware devices can't be deleted.
    ///
    /// # Deprecated since 1.22
    ///
    /// Use [`delete_async()`][Self::delete_async()] or GDBusConnection.
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable], or [`None`]
    ///
    /// # Returns
    ///
    /// [`true`] on success, [`false`] on error, in which case `error`
    /// will be set.
    #[cfg_attr(feature = "v1_22", deprecated = "Since 1.22")]
    #[doc(alias = "nm_device_delete")]
    fn delete(&self, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error>;

    /// Asynchronously begins deleting the software device. Hardware devices can't
    /// be deleted.
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable], or [`None`]
    /// ## `callback`
    /// callback to be called when delete operation completes
    #[doc(alias = "nm_device_delete_async")]
    fn delete_async<P: FnOnce(Result<(), glib::Error>) + 'static>(
        &self,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    );

    fn delete_future(
        &self,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>>;

    /// Disconnects the device if currently connected, and prevents the device from
    /// automatically connecting to networks until the next manual network connection
    /// request.
    ///
    /// # Deprecated since 1.22
    ///
    /// Use [`disconnect_async()`][Self::disconnect_async()] or GDBusConnection.
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable], or [`None`]
    ///
    /// # Returns
    ///
    /// [`true`] on success, [`false`] on error, in which case `error` will be set.
    #[cfg_attr(feature = "v1_22", deprecated = "Since 1.22")]
    #[doc(alias = "nm_device_disconnect")]
    fn disconnect(
        &self,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
    ) -> Result<(), glib::Error>;

    /// Asynchronously begins disconnecting the device if currently connected, and
    /// prevents the device from automatically connecting to networks until the next
    /// manual network connection request.
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable], or [`None`]
    /// ## `callback`
    /// callback to be called when the disconnect operation completes
    #[doc(alias = "nm_device_disconnect_async")]
    fn disconnect_async<P: FnOnce(Result<(), glib::Error>) + 'static>(
        &self,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    );

    fn disconnect_future(
        &self,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>>;

    /// Filters a given array of connections for a given [`Device`][crate::Device] object and returns
    /// connections which may be activated with the device. For example if `self`
    /// is a Wi-Fi device that supports only WEP encryption, the returned array will
    /// contain any Wi-Fi connections in `connections` that allow connection to
    /// unencrypted or WEP-enabled SSIDs. The returned array will not contain
    /// Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
    /// incompatible with the device. To get the full list of connections see
    /// [`Client::connections()`][crate::Client::connections()].
    /// ## `connections`
    /// an array of `NMConnections` to filter
    ///
    /// # Returns
    ///
    /// an array of
    /// `NMConnections` that could be activated with the given `self`. The array
    /// should be freed with `g_ptr_array_unref()` when it is no longer required.
    ///
    /// WARNING: the transfer annotation for this function may not work correctly
    ///  with bindings. See https://gitlab.gnome.org/GNOME/gobject-introspection/-/issues/305.
    ///  You can filter the list yourself with [`connection_valid()`][Self::connection_valid()].
    #[doc(alias = "nm_device_filter_connections")]
    fn filter_connections(&self, connections: &[Connection]) -> Vec<Connection>;

    /// Gets the [`ActiveConnection`][crate::ActiveConnection] object which owns this device during activation.
    ///
    /// # Returns
    ///
    /// the [`ActiveConnection`][crate::ActiveConnection] or [`None`] if the device is
    /// not part of an active connection
    #[doc(alias = "nm_device_get_active_connection")]
    #[doc(alias = "get_active_connection")]
    fn active_connection(&self) -> Option<ActiveConnection>;

    /// Fetch the currently applied connection on the device.
    ///
    /// # Deprecated since 1.22
    ///
    /// Use [`applied_connection_async()`][Self::applied_connection_async()] or GDBusConnection.
    /// ## `flags`
    /// the flags argument. Currently, this value must always be zero.
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable], or [`None`]
    ///
    /// # Returns
    ///
    /// a `NMConnection` with the currently applied settings
    ///  or [`None`] on error.
    ///
    /// The connection is as received from D-Bus and might not validate according
    /// to [`ConnectionExt::verify()`][crate::prelude::ConnectionExt::verify()].
    ///
    /// ## `version_id`
    /// returns the current version id of
    ///  the applied connection
    #[cfg_attr(feature = "v1_22", deprecated = "Since 1.22")]
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_device_get_applied_connection")]
    #[doc(alias = "get_applied_connection")]
    fn applied_connection(
        &self,
        flags: u32,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
    ) -> Result<(Connection, u64), glib::Error>;

    /// Asynchronously begins and gets the currently applied connection.
    /// ## `flags`
    /// the flags argument. Currently, this value must always be zero.
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable], or [`None`]
    /// ## `callback`
    /// callback to be called when the reapply operation completes
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_device_get_applied_connection_async")]
    #[doc(alias = "get_applied_connection_async")]
    fn applied_connection_async<P: FnOnce(Result<(Connection, u64), glib::Error>) + 'static>(
        &self,
        flags: u32,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    );

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn applied_connection_future(
        &self,
        flags: u32,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(Connection, u64), glib::Error>> + 'static>>;

    /// Whether the [`Device`][crate::Device] can be autoconnected.
    ///
    /// # Returns
    ///
    /// [`true`] if the device is allowed to be autoconnected
    #[doc(alias = "nm_device_get_autoconnect")]
    #[doc(alias = "get_autoconnect")]
    fn is_autoconnect(&self) -> bool;

    /// Gets the `NMRemoteConnections` currently known to the daemon that could
    /// be activated on `self`.
    ///
    /// # Returns
    ///
    /// the [`glib::PtrArray`][crate::glib::PtrArray]
    /// containing `NMRemoteConnections`. This is the internal copy used by
    /// the connection, and must not be modified.
    #[doc(alias = "nm_device_get_available_connections")]
    #[doc(alias = "get_available_connections")]
    fn available_connections(&self) -> Vec<RemoteConnection>;

    /// Gets the device' capabilities.
    ///
    /// # Returns
    ///
    /// the capabilities
    #[doc(alias = "nm_device_get_capabilities")]
    #[doc(alias = "get_capabilities")]
    fn capabilities(&self) -> DeviceCapabilities;

    /// The connectivity state of the device for given address family.
    /// Supported address families are `AF_INET` for IPv4, `AF_INET6`
    /// for IPv6 or `AF_UNSPEC` for any.
    /// ## `addr_family`
    /// network address family
    ///
    /// # Returns
    ///
    /// the current connectivity state
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    #[doc(alias = "nm_device_get_connectivity")]
    #[doc(alias = "get_connectivity")]
    fn connectivity(&self, addr_family: i32) -> ConnectivityState;

    /// Gets a description of `self`, based on its vendor and product names.
    ///
    /// # Returns
    ///
    /// a description of `self`. If either the vendor or the
    ///  product name is unknown, this returns the interface name.
    #[doc(alias = "nm_device_get_description")]
    #[doc(alias = "get_description")]
    fn description(&self) -> Option<glib::GString>;

    /// Returns the numeric type of the [`Device`][crate::Device], ie Ethernet, Wi-Fi, etc.
    ///
    /// # Returns
    ///
    /// the device type
    #[doc(alias = "nm_device_get_device_type")]
    #[doc(alias = "get_device_type")]
    fn device_type(&self) -> DeviceType;

    /// Gets the current IPv4 [`DhcpConfig`][crate::DhcpConfig] associated with the [`Device`][crate::Device].
    ///
    /// You can alternatively use [`ActiveConnectionExt::dhcp4_config()`][crate::prelude::ActiveConnectionExt::dhcp4_config()], which also
    /// works with VPN connections.
    ///
    /// # Returns
    ///
    /// the IPv4 [`DhcpConfig`][crate::DhcpConfig], or [`None`] if the device is
    /// not activated or not using DHCP.
    #[doc(alias = "nm_device_get_dhcp4_config")]
    #[doc(alias = "get_dhcp4_config")]
    fn dhcp4_config(&self) -> Option<DhcpConfig>;

    /// Gets the current IPv6 [`DhcpConfig`][crate::DhcpConfig] associated with the [`Device`][crate::Device].
    ///
    /// You can alternatively use [`ActiveConnectionExt::dhcp6_config()`][crate::prelude::ActiveConnectionExt::dhcp6_config()], which also
    /// works with VPN connections.
    ///
    /// # Returns
    ///
    /// the IPv6 [`DhcpConfig`][crate::DhcpConfig], or [`None`] if the device is
    /// not activated or not using DHCPv6.
    #[doc(alias = "nm_device_get_dhcp6_config")]
    #[doc(alias = "get_dhcp6_config")]
    fn dhcp6_config(&self) -> Option<DhcpConfig>;

    /// Gets the driver of the [`Device`][crate::Device].
    ///
    /// # Returns
    ///
    /// the driver of the device. This is the internal string used by the
    /// device, and must not be modified.
    #[doc(alias = "nm_device_get_driver")]
    #[doc(alias = "get_driver")]
    fn driver(&self) -> Option<glib::GString>;

    /// Gets the driver version of the [`Device`][crate::Device].
    ///
    /// # Returns
    ///
    /// the version of the device driver. This is the internal string used by the
    /// device, and must not be modified.
    #[doc(alias = "nm_device_get_driver_version")]
    #[doc(alias = "get_driver_version")]
    fn driver_version(&self) -> Option<glib::GString>;

    /// Indicates that firmware required for the device's operation is likely
    /// to be missing.
    ///
    /// # Returns
    ///
    /// [`true`] if firmware required for the device's operation is likely
    /// to be missing.
    #[doc(alias = "nm_device_get_firmware_missing")]
    #[doc(alias = "get_firmware_missing")]
    fn is_firmware_missing(&self) -> bool;

    /// Gets the firmware version of the [`Device`][crate::Device].
    ///
    /// # Returns
    ///
    /// the firmware version of the device. This is the internal string used by the
    /// device, and must not be modified.
    #[doc(alias = "nm_device_get_firmware_version")]
    #[doc(alias = "get_firmware_version")]
    fn firmware_version(&self) -> Option<glib::GString>;

    /// Gets the current a hardware address (MAC) for the `self`.
    ///
    /// # Returns
    ///
    /// the current MAC of the device, or [`None`].
    /// This is the internal string used by the device, and must not be modified.
    #[doc(alias = "nm_device_get_hw_address")]
    #[doc(alias = "get_hw_address")]
    fn hw_address(&self) -> Option<glib::GString>;

    /// Gets the interface name of the [`Device`][crate::Device].
    ///
    /// # Returns
    ///
    /// the interface of the device. This is the internal string used by the
    /// device, and must not be modified.
    #[doc(alias = "nm_device_get_iface")]
    #[doc(alias = "get_iface")]
    fn iface(&self) -> Option<glib::GString>;

    /// Gets the interface flags of the device.
    ///
    /// # Returns
    ///
    /// the flags
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
    #[doc(alias = "nm_device_get_interface_flags")]
    #[doc(alias = "get_interface_flags")]
    fn interface_flags(&self) -> DeviceInterfaceFlags;

    /// Gets the current IPv4 [`IPConfig`][crate::IPConfig] associated with the [`Device`][crate::Device].
    ///
    /// You can alternatively use [`ActiveConnectionExt::ip4_config()`][crate::prelude::ActiveConnectionExt::ip4_config()], which also
    /// works with VPN connections.
    ///
    /// # Returns
    ///
    /// the IPv4 [`IPConfig`][crate::IPConfig], or [`None`] if the device is not
    /// activated.
    #[doc(alias = "nm_device_get_ip4_config")]
    #[doc(alias = "get_ip4_config")]
    fn ip4_config(&self) -> Option<IPConfig>;

    /// Gets the current IPv6 [`IPConfig`][crate::IPConfig] associated with the [`Device`][crate::Device].
    ///
    /// You can alternatively use [`ActiveConnectionExt::ip6_config()`][crate::prelude::ActiveConnectionExt::ip6_config()], which also
    /// works with VPN connections.
    ///
    /// # Returns
    ///
    /// the IPv6 [`IPConfig`][crate::IPConfig] or [`None`] if the device is not activated.
    #[doc(alias = "nm_device_get_ip6_config")]
    #[doc(alias = "get_ip6_config")]
    fn ip6_config(&self) -> Option<IPConfig>;

    /// Gets the IP interface name of the [`Device`][crate::Device] over which IP traffic flows
    /// when the device is in the ACTIVATED state.
    ///
    /// # Returns
    ///
    /// the IP traffic interface of the device. This is the internal string
    /// used by the device, and must not be modified.
    #[doc(alias = "nm_device_get_ip_iface")]
    #[doc(alias = "get_ip_iface")]
    fn ip_iface(&self) -> Option<glib::GString>;

    /// Gets the list of neighbors discovered through LLDP.
    ///
    /// # Returns
    ///
    /// the [`glib::PtrArray`][crate::glib::PtrArray]
    /// containing [`LldpNeighbor`][crate::LldpNeighbor]<!-- -->s. This is the internal copy used by the
    /// device and must not be modified. The library never modifies the returned
    /// array and thus it is safe for callers to reference and keep using it.
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_device_get_lldp_neighbors")]
    #[doc(alias = "get_lldp_neighbors")]
    fn lldp_neighbors(&self) -> Vec<LldpNeighbor>;

    /// Whether the [`Device`][crate::Device] is managed by NetworkManager.
    ///
    /// # Returns
    ///
    /// [`true`] if the device is managed by NetworkManager
    #[doc(alias = "nm_device_get_managed")]
    #[doc(alias = "get_managed")]
    fn is_managed(&self) -> bool;

    /// Gets the metered setting of a [`Device`][crate::Device].
    ///
    /// # Returns
    ///
    /// the metered setting.
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_device_get_metered")]
    #[doc(alias = "get_metered")]
    fn metered(&self) -> Metered;

    /// Gets the MTU of the [`Device`][crate::Device].
    ///
    /// # Returns
    ///
    /// the MTU of the device in bytes.
    #[doc(alias = "nm_device_get_mtu")]
    #[doc(alias = "get_mtu")]
    fn mtu(&self) -> u32;

    /// Indicates that the NetworkManager plugin for the device is not installed.
    ///
    /// # Returns
    ///
    /// [`true`] if the device plugin not installed.
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_device_get_nm_plugin_missing")]
    #[doc(alias = "get_nm_plugin_missing")]
    fn is_nm_plugin_missing(&self) -> bool;

    /// Gets the path of the [`Device`][crate::Device] as exposed by the udev property ID_PATH.
    ///
    /// # Returns
    ///
    /// the path of the device.
    ///
    /// The string is backslash escaped (C escaping) for invalid characters. The escaping
    /// can be reverted with `g_strcompress()`, however the result may not be valid UTF-8.
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_device_get_path")]
    #[doc(alias = "get_path")]
    fn path(&self) -> Option<glib::GString>;

    /// Gets the physical port ID of the [`Device`][crate::Device]. If non-[`None`], this is
    /// an opaque string that can be used to recognize when
    /// seemingly-unrelated `NMDevices` are actually just different virtual
    /// ports on a single physical port. (Eg, NPAR / SR-IOV.)
    ///
    /// # Returns
    ///
    /// the physical port ID of the device, or [`None`] if the port
    ///  ID is unknown. This is the internal string used by the device and
    ///  must not be modified.
    #[doc(alias = "nm_device_get_physical_port_id")]
    #[doc(alias = "get_physical_port_id")]
    fn physical_port_id(&self) -> Option<glib::GString>;

    /// Gets the devices currently set as port of `self`.
    ///
    /// # Returns
    ///
    /// the [`glib::PtrArray`][crate::glib::PtrArray] containing `NMDevices` that
    /// are slaves of `self`. This is the internal copy used by the device and
    /// must not be modified.
    #[cfg(any(feature = "v1_34", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_34")))]
    #[doc(alias = "nm_device_get_ports")]
    #[doc(alias = "get_ports")]
    fn ports(&self) -> Vec<Device>;

    /// Gets the product string of the [`Device`][crate::Device].
    ///
    /// # Returns
    ///
    /// the product name of the device. This is the internal string used by the
    /// device, and must not be modified.
    ///
    /// The string is backslash escaped (C escaping) for invalid characters. The escaping
    /// can be reverted with `g_strcompress()`, however the result may not be valid UTF-8.
    #[doc(alias = "nm_device_get_product")]
    #[doc(alias = "get_product")]
    fn product(&self) -> Option<glib::GString>;

    /// Gets the (primary) [`Setting`][crate::Setting] subtype associated with connections
    /// that can be used on `self`.
    ///
    /// # Returns
    ///
    /// `self`'s associated [`Setting`][crate::Setting] type
    #[doc(alias = "nm_device_get_setting_type")]
    #[doc(alias = "get_setting_type")]
    fn setting_type(&self) -> glib::types::Type;

    /// Gets the current [`Device`][crate::Device] state.
    ///
    /// # Returns
    ///
    /// the current device state
    #[doc(alias = "nm_device_get_state")]
    #[doc(alias = "get_state")]
    fn state(&self) -> DeviceState;

    /// Gets the reason for entering the current [`Device`][crate::Device] state.
    ///
    /// # Returns
    ///
    /// the reason for entering the current device state
    #[doc(alias = "nm_device_get_state_reason")]
    #[doc(alias = "get_state_reason")]
    fn state_reason(&self) -> DeviceStateReason;

    /// Gets a (non-localized) description of the type of device that
    /// `self` is.
    ///
    /// # Returns
    ///
    /// the type description of the device. This is the internal
    /// string used by the device, and must not be modified.
    #[doc(alias = "nm_device_get_type_description")]
    #[doc(alias = "get_type_description")]
    fn type_description(&self) -> Option<glib::GString>;

    /// Gets the Unique Device Identifier of the [`Device`][crate::Device].
    ///
    /// # Returns
    ///
    /// the Unique Device Identifier of the device. This identifier may be
    /// used to gather more information about the device from various operating
    /// system services like udev or sysfs.
    #[doc(alias = "nm_device_get_udi")]
    #[doc(alias = "get_udi")]
    fn udi(&self) -> Option<glib::GString>;

    /// Gets the vendor string of the [`Device`][crate::Device].
    ///
    /// # Returns
    ///
    /// the vendor name of the device. This is the internal string used by the
    /// device, and must not be modified.
    ///
    /// The string is backslash escaped (C escaping) for invalid characters. The escaping
    /// can be reverted with `g_strcompress()`, however the result may not be valid UTF-8.
    #[doc(alias = "nm_device_get_vendor")]
    #[doc(alias = "get_vendor")]
    fn vendor(&self) -> Option<glib::GString>;

    ///
    /// # Returns
    ///
    /// [`true`] if the device exists, or [`false`] if it is a placeholder device
    /// that could be automatically created by NetworkManager if one of its
    /// `property::Device::available-connections` was activated.
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_device_is_real")]
    fn is_real(&self) -> bool;

    /// Whether the device is a software device.
    ///
    /// # Returns
    ///
    /// [`true`] if `self` is a software device, [`false`] if it is a hardware device.
    #[doc(alias = "nm_device_is_software")]
    fn is_software(&self) -> bool;

    /// Attempts to update device with changes to the currently active connection
    /// made since it was last applied.
    ///
    /// # Deprecated since 1.22
    ///
    /// Use [`reapply_async()`][Self::reapply_async()] or GDBusConnection.
    /// ## `connection`
    /// the [`Connection`][crate::Connection] to replace the applied
    ///  settings with or [`None`] to reuse existing
    /// ## `version_id`
    /// zero or the expected version id of the applied connection.
    ///  If specified and the version id mismatches, the call fails without
    ///  modification. This allows to catch concurrent accesses.
    /// ## `flags`
    /// always set this to zero
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable], or [`None`]
    ///
    /// # Returns
    ///
    /// [`true`] on success, [`false`] on error, in which case `error` will be set.
    #[cfg_attr(feature = "v1_22", deprecated = "Since 1.22")]
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_device_reapply")]
    fn reapply(
        &self,
        connection: Option<&impl IsA<Connection>>,
        version_id: u64,
        flags: u32,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
    ) -> Result<(), glib::Error>;

    /// Asynchronously begins an attempt to update device with changes to the
    /// currently active connection made since it was last applied.
    /// ## `connection`
    /// the [`Connection`][crate::Connection] to replace the applied
    ///  settings with or [`None`] to reuse existing
    /// ## `version_id`
    /// zero or the expected version id of the applied
    ///  connection. If specified and the version id mismatches, the call
    ///  fails without modification. This allows to catch concurrent
    ///  accesses.
    /// ## `flags`
    /// always set this to zero
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable], or [`None`]
    /// ## `callback`
    /// callback to be called when the reapply operation completes
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_device_reapply_async")]
    fn reapply_async<P: FnOnce(Result<(), glib::Error>) + 'static>(
        &self,
        connection: Option<&impl IsA<Connection>>,
        version_id: u64,
        flags: u32,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    );

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn reapply_future(
        &self,
        connection: Option<&(impl IsA<Connection> + Clone + 'static)>,
        version_id: u64,
        flags: u32,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>>;

    /// Enables or disables automatic activation of the [`Device`][crate::Device].
    ///
    /// # Deprecated since 1.22
    ///
    /// Use the async command [`Client::dbus_set_property()`][crate::Client::dbus_set_property()] on
    /// [`ObjectExt::path()`][crate::prelude::ObjectExt::path()], `NM_DBUS_INTERFACE_DEVICE` to set "Autoconnect" property to a "(b)" value.
    /// This function is deprecated because it calls a synchronous D-Bus method
    /// and modifies the content of the NMClient cache client side.
    /// ## `autoconnect`
    /// [`true`] to enable autoconnecting
    #[cfg_attr(feature = "v1_22", deprecated = "Since 1.22")]
    #[doc(alias = "nm_device_set_autoconnect")]
    fn set_autoconnect(&self, autoconnect: bool);

    /// Enables or disables management of [`Device`][crate::Device] by NetworkManager.
    ///
    /// # Deprecated since 1.22
    ///
    /// Use the async command [`Client::dbus_set_property()`][crate::Client::dbus_set_property()] on
    /// [`ObjectExt::path()`][crate::prelude::ObjectExt::path()], interface `NM_DBUS_INTERFACE_DEVICE` to set the
    /// "Managed" property to a "(b)" boolean value.
    /// This function is deprecated because it calls a synchronous D-Bus method
    /// and modifies the content of the NMClient cache client side. Also, it does
    /// not emit a property changed signal.
    /// ## `managed`
    /// [`true`] to make the device managed by NetworkManager.
    #[cfg_attr(feature = "v1_22", deprecated = "Since 1.22")]
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_device_set_managed")]
    fn set_managed(&self, managed: bool);

    /// The interface of the device.
    fn interface(&self) -> Option<glib::GString>;

    /// The IP interface of the device which should be used for all IP-related
    /// operations like addressing and routing.
    #[doc(alias = "ip-interface")]
    fn ip_interface(&self) -> Option<glib::GString>;

    /// The IPv4 connectivity state of the device.
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    #[doc(alias = "ip4-connectivity")]
    fn ip4_connectivity(&self) -> ConnectivityState;

    /// The IPv6 connectivity state of the device.
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    #[doc(alias = "ip6-connectivity")]
    fn ip6_connectivity(&self) -> ConnectivityState;

    //#[doc(alias = "lldp-neighbors")]
    //fn get_property_lldp_neighbors(&self) -> /*Unimplemented*/Vec<Basic: Pointer>;

    /// Notifies the state change of a [`Device`][crate::Device].
    /// ## `new_state`
    /// the new state of the device
    /// ## `old_state`
    /// the previous state of the device
    /// ## `reason`
    /// the reason describing the state change
    #[doc(alias = "state-changed")]
    fn connect_state_changed<F: Fn(&Self, u32, u32, u32) + 'static>(&self, f: F)
        -> SignalHandlerId;

    #[doc(alias = "active-connection")]
    fn connect_active_connection_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "autoconnect")]
    fn connect_autoconnect_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "available-connections")]
    fn connect_available_connections_notify<F: Fn(&Self) + 'static>(&self, f: F)
        -> SignalHandlerId;

    #[doc(alias = "capabilities")]
    fn connect_capabilities_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "device-type")]
    fn connect_device_type_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "dhcp4-config")]
    fn connect_dhcp4_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "dhcp6-config")]
    fn connect_dhcp6_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "driver")]
    fn connect_driver_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "driver-version")]
    fn connect_driver_version_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "firmware-missing")]
    fn connect_firmware_missing_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "firmware-version")]
    fn connect_firmware_version_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_24", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_24")))]
    #[doc(alias = "hw-address")]
    fn connect_hw_address_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "interface")]
    fn connect_interface_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_22", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
    #[doc(alias = "interface-flags")]
    fn connect_interface_flags_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "ip-interface")]
    fn connect_ip_interface_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "ip4-config")]
    fn connect_ip4_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    #[doc(alias = "ip4-connectivity")]
    fn connect_ip4_connectivity_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "ip6-config")]
    fn connect_ip6_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    #[doc(alias = "ip6-connectivity")]
    fn connect_ip6_connectivity_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "lldp-neighbors")]
    fn connect_lldp_neighbors_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "managed")]
    fn connect_managed_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "metered")]
    fn connect_metered_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "mtu")]
    fn connect_mtu_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm-plugin-missing")]
    fn connect_nm_plugin_missing_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "physical-port-id")]
    fn connect_physical_port_id_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_34", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_34")))]
    #[doc(alias = "ports")]
    fn connect_ports_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "product")]
    fn connect_product_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "real")]
    fn connect_real_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "state")]
    fn connect_state_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "state-reason")]
    fn connect_state_reason_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "udi")]
    fn connect_udi_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "vendor")]
    fn connect_vendor_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<Device>> DeviceExt for O {
    fn connection_compatible(&self, connection: &impl IsA<Connection>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok = ffi::nm_device_connection_compatible(
                self.as_ref().to_glib_none().0,
                connection.as_ref().to_glib_none().0,
                &mut error,
            );
            assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn connection_valid(&self, connection: &impl IsA<Connection>) -> bool {
        unsafe {
            from_glib(ffi::nm_device_connection_valid(
                self.as_ref().to_glib_none().0,
                connection.as_ref().to_glib_none().0,
            ))
        }
    }

    fn delete(&self, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok = ffi::nm_device_delete(
                self.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn delete_async<P: FnOnce(Result<(), glib::Error>) + 'static>(
        &self,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    ) {
        let main_context = glib::MainContext::ref_thread_default();
        let is_main_context_owner = main_context.is_owner();
        let has_acquired_main_context = (!is_main_context_owner)
            .then(|| main_context.acquire().ok())
            .flatten();
        assert!(
            is_main_context_owner || has_acquired_main_context.is_some(),
            "Async operations only allowed if the thread is owning the MainContext"
        );

        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> =
            Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn delete_async_trampoline<
            P: FnOnce(Result<(), glib::Error>) + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let _ = ffi::nm_device_delete_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> =
                Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = delete_async_trampoline::<P>;
        unsafe {
            ffi::nm_device_delete_async(
                self.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn delete_future(
        &self,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.delete_async(Some(cancellable), move |res| {
                send.resolve(res);
            });
        }))
    }

    fn disconnect(
        &self,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok = ffi::nm_device_disconnect(
                self.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn disconnect_async<P: FnOnce(Result<(), glib::Error>) + 'static>(
        &self,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    ) {
        let main_context = glib::MainContext::ref_thread_default();
        let is_main_context_owner = main_context.is_owner();
        let has_acquired_main_context = (!is_main_context_owner)
            .then(|| main_context.acquire().ok())
            .flatten();
        assert!(
            is_main_context_owner || has_acquired_main_context.is_some(),
            "Async operations only allowed if the thread is owning the MainContext"
        );

        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> =
            Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn disconnect_async_trampoline<
            P: FnOnce(Result<(), glib::Error>) + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let _ = ffi::nm_device_disconnect_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> =
                Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = disconnect_async_trampoline::<P>;
        unsafe {
            ffi::nm_device_disconnect_async(
                self.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn disconnect_future(
        &self,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.disconnect_async(Some(cancellable), move |res| {
                send.resolve(res);
            });
        }))
    }

    fn filter_connections(&self, connections: &[Connection]) -> Vec<Connection> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::nm_device_filter_connections(
                self.as_ref().to_glib_none().0,
                connections.to_glib_none().0,
            ))
        }
    }

    fn active_connection(&self) -> Option<ActiveConnection> {
        unsafe {
            from_glib_none(ffi::nm_device_get_active_connection(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn applied_connection(
        &self,
        flags: u32,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
    ) -> Result<(Connection, u64), glib::Error> {
        unsafe {
            let mut version_id = mem::MaybeUninit::uninit();
            let mut error = ptr::null_mut();
            let ret = ffi::nm_device_get_applied_connection(
                self.as_ref().to_glib_none().0,
                flags,
                version_id.as_mut_ptr(),
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok((from_glib_full(ret), version_id.assume_init()))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn applied_connection_async<P: FnOnce(Result<(Connection, u64), glib::Error>) + 'static>(
        &self,
        flags: u32,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    ) {
        let main_context = glib::MainContext::ref_thread_default();
        let is_main_context_owner = main_context.is_owner();
        let has_acquired_main_context = (!is_main_context_owner)
            .then(|| main_context.acquire().ok())
            .flatten();
        assert!(
            is_main_context_owner || has_acquired_main_context.is_some(),
            "Async operations only allowed if the thread is owning the MainContext"
        );

        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> =
            Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn applied_connection_async_trampoline<
            P: FnOnce(Result<(Connection, u64), glib::Error>) + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let mut version_id = mem::MaybeUninit::uninit();
            let ret = ffi::nm_device_get_applied_connection_finish(
                _source_object as *mut _,
                res,
                version_id.as_mut_ptr(),
                &mut error,
            );
            let result = if error.is_null() {
                Ok((from_glib_full(ret), version_id.assume_init()))
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> =
                Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = applied_connection_async_trampoline::<P>;
        unsafe {
            ffi::nm_device_get_applied_connection_async(
                self.as_ref().to_glib_none().0,
                flags,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn applied_connection_future(
        &self,
        flags: u32,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(Connection, u64), glib::Error>> + 'static>>
    {
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.applied_connection_async(flags, Some(cancellable), move |res| {
                send.resolve(res);
            });
        }))
    }

    fn is_autoconnect(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_device_get_autoconnect(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn available_connections(&self) -> Vec<RemoteConnection> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::nm_device_get_available_connections(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn capabilities(&self) -> DeviceCapabilities {
        unsafe {
            from_glib(ffi::nm_device_get_capabilities(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    fn connectivity(&self, addr_family: i32) -> ConnectivityState {
        unsafe {
            from_glib(ffi::nm_device_get_connectivity(
                self.as_ref().to_glib_none().0,
                addr_family,
            ))
        }
    }

    fn description(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::nm_device_get_description(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn device_type(&self) -> DeviceType {
        unsafe {
            from_glib(ffi::nm_device_get_device_type(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn dhcp4_config(&self) -> Option<DhcpConfig> {
        unsafe {
            from_glib_none(ffi::nm_device_get_dhcp4_config(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn dhcp6_config(&self) -> Option<DhcpConfig> {
        unsafe {
            from_glib_none(ffi::nm_device_get_dhcp6_config(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn driver(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::nm_device_get_driver(self.as_ref().to_glib_none().0)) }
    }

    fn driver_version(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::nm_device_get_driver_version(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn is_firmware_missing(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_device_get_firmware_missing(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn firmware_version(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::nm_device_get_firmware_version(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn hw_address(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::nm_device_get_hw_address(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn iface(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::nm_device_get_iface(self.as_ref().to_glib_none().0)) }
    }

    #[cfg(any(feature = "v1_22", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
    fn interface_flags(&self) -> DeviceInterfaceFlags {
        unsafe {
            from_glib(ffi::nm_device_get_interface_flags(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn ip4_config(&self) -> Option<IPConfig> {
        unsafe {
            from_glib_none(ffi::nm_device_get_ip4_config(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn ip6_config(&self) -> Option<IPConfig> {
        unsafe {
            from_glib_none(ffi::nm_device_get_ip6_config(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn ip_iface(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::nm_device_get_ip_iface(self.as_ref().to_glib_none().0)) }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn lldp_neighbors(&self) -> Vec<LldpNeighbor> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::nm_device_get_lldp_neighbors(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn is_managed(&self) -> bool {
        unsafe { from_glib(ffi::nm_device_get_managed(self.as_ref().to_glib_none().0)) }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn metered(&self) -> Metered {
        unsafe { from_glib(ffi::nm_device_get_metered(self.as_ref().to_glib_none().0)) }
    }

    fn mtu(&self) -> u32 {
        unsafe { ffi::nm_device_get_mtu(self.as_ref().to_glib_none().0) }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn is_nm_plugin_missing(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_device_get_nm_plugin_missing(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    fn path(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::nm_device_get_path(self.as_ref().to_glib_none().0)) }
    }

    fn physical_port_id(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::nm_device_get_physical_port_id(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_34", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_34")))]
    fn ports(&self) -> Vec<Device> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::nm_device_get_ports(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn product(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::nm_device_get_product(self.as_ref().to_glib_none().0)) }
    }

    fn setting_type(&self) -> glib::types::Type {
        unsafe {
            from_glib(ffi::nm_device_get_setting_type(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn state(&self) -> DeviceState {
        unsafe { from_glib(ffi::nm_device_get_state(self.as_ref().to_glib_none().0)) }
    }

    fn state_reason(&self) -> DeviceStateReason {
        unsafe {
            from_glib(ffi::nm_device_get_state_reason(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn type_description(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::nm_device_get_type_description(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn udi(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::nm_device_get_udi(self.as_ref().to_glib_none().0)) }
    }

    fn vendor(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::nm_device_get_vendor(self.as_ref().to_glib_none().0)) }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn is_real(&self) -> bool {
        unsafe { from_glib(ffi::nm_device_is_real(self.as_ref().to_glib_none().0)) }
    }

    fn is_software(&self) -> bool {
        unsafe { from_glib(ffi::nm_device_is_software(self.as_ref().to_glib_none().0)) }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn reapply(
        &self,
        connection: Option<&impl IsA<Connection>>,
        version_id: u64,
        flags: u32,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok = ffi::nm_device_reapply(
                self.as_ref().to_glib_none().0,
                connection.map(|p| p.as_ref()).to_glib_none().0,
                version_id,
                flags,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn reapply_async<P: FnOnce(Result<(), glib::Error>) + 'static>(
        &self,
        connection: Option<&impl IsA<Connection>>,
        version_id: u64,
        flags: u32,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    ) {
        let main_context = glib::MainContext::ref_thread_default();
        let is_main_context_owner = main_context.is_owner();
        let has_acquired_main_context = (!is_main_context_owner)
            .then(|| main_context.acquire().ok())
            .flatten();
        assert!(
            is_main_context_owner || has_acquired_main_context.is_some(),
            "Async operations only allowed if the thread is owning the MainContext"
        );

        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> =
            Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn reapply_async_trampoline<
            P: FnOnce(Result<(), glib::Error>) + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let _ = ffi::nm_device_reapply_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> =
                Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = reapply_async_trampoline::<P>;
        unsafe {
            ffi::nm_device_reapply_async(
                self.as_ref().to_glib_none().0,
                connection.map(|p| p.as_ref()).to_glib_none().0,
                version_id,
                flags,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn reapply_future(
        &self,
        connection: Option<&(impl IsA<Connection> + Clone + 'static)>,
        version_id: u64,
        flags: u32,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {
        let connection = connection.map(ToOwned::to_owned);
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.reapply_async(
                connection.as_ref().map(::std::borrow::Borrow::borrow),
                version_id,
                flags,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    fn set_autoconnect(&self, autoconnect: bool) {
        unsafe {
            ffi::nm_device_set_autoconnect(self.as_ref().to_glib_none().0, autoconnect.into_glib());
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn set_managed(&self, managed: bool) {
        unsafe {
            ffi::nm_device_set_managed(self.as_ref().to_glib_none().0, managed.into_glib());
        }
    }

    fn interface(&self) -> Option<glib::GString> {
        glib::ObjectExt::property(self.as_ref(), "interface")
    }

    fn ip_interface(&self) -> Option<glib::GString> {
        glib::ObjectExt::property(self.as_ref(), "ip-interface")
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    fn ip4_connectivity(&self) -> ConnectivityState {
        glib::ObjectExt::property(self.as_ref(), "ip4-connectivity")
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    fn ip6_connectivity(&self) -> ConnectivityState {
        glib::ObjectExt::property(self.as_ref(), "ip6-connectivity")
    }

    //fn get_property_lldp_neighbors(&self) -> /*Unimplemented*/Vec<Basic: Pointer> {
    //    glib::ObjectExt::property(self.as_ref(), "lldp-neighbors")
    //}

    fn connect_state_changed<F: Fn(&Self, u32, u32, u32) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn state_changed_trampoline<
            P: IsA<Device>,
            F: Fn(&P, u32, u32, u32) + 'static,
        >(
            this: *mut ffi::NMDevice,
            new_state: libc::c_uint,
            old_state: libc::c_uint,
            reason: libc::c_uint,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(
                Device::from_glib_borrow(this).unsafe_cast_ref(),
                new_state,
                old_state,
                reason,
            )
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"state-changed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    state_changed_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_active_connection_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_active_connection_trampoline<
            P: IsA<Device>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::active-connection\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_active_connection_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_autoconnect_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_autoconnect_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::autoconnect\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_autoconnect_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_available_connections_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_available_connections_trampoline<
            P: IsA<Device>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::available-connections\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_available_connections_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_capabilities_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_capabilities_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::capabilities\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_capabilities_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_device_type_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_device_type_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::device-type\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_device_type_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_dhcp4_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_dhcp4_config_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::dhcp4-config\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_dhcp4_config_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_dhcp6_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_dhcp6_config_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::dhcp6-config\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_dhcp6_config_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_driver_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_driver_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::driver\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_driver_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_driver_version_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_driver_version_trampoline<
            P: IsA<Device>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::driver-version\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_driver_version_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_firmware_missing_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_firmware_missing_trampoline<
            P: IsA<Device>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::firmware-missing\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_firmware_missing_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_firmware_version_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_firmware_version_trampoline<
            P: IsA<Device>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::firmware-version\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_firmware_version_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_24", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_24")))]
    fn connect_hw_address_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_hw_address_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::hw-address\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_hw_address_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_interface_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_interface_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::interface\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_interface_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_22", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
    fn connect_interface_flags_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_interface_flags_trampoline<
            P: IsA<Device>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::interface-flags\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_interface_flags_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_ip_interface_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip_interface_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::ip-interface\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_ip_interface_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_ip4_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip4_config_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::ip4-config\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_ip4_config_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    fn connect_ip4_connectivity_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip4_connectivity_trampoline<
            P: IsA<Device>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::ip4-connectivity\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_ip4_connectivity_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_ip6_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip6_config_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::ip6-config\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_ip6_config_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    fn connect_ip6_connectivity_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip6_connectivity_trampoline<
            P: IsA<Device>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::ip6-connectivity\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_ip6_connectivity_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_lldp_neighbors_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_lldp_neighbors_trampoline<
            P: IsA<Device>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::lldp-neighbors\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_lldp_neighbors_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_managed_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_managed_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::managed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_managed_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn connect_metered_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_metered_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::metered\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_metered_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_mtu_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mtu_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::mtu\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_mtu_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn connect_nm_plugin_missing_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_nm_plugin_missing_trampoline<
            P: IsA<Device>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::nm-plugin-missing\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_nm_plugin_missing_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_physical_port_id_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_physical_port_id_trampoline<
            P: IsA<Device>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::physical-port-id\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_physical_port_id_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_34", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_34")))]
    fn connect_ports_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ports_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::ports\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_ports_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_product_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_product_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::product\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_product_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    fn connect_real_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_real_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::real\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_real_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_state_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_state_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::state\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_state_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_state_reason_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_state_reason_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::state-reason\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_state_reason_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_udi_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_udi_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::udi\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_udi_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_vendor_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_vendor_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(
            this: *mut ffi::NMDevice,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::vendor\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_vendor_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl fmt::Display for Device {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("Device")
    }
}
