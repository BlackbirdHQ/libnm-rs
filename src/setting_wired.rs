// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files
// DO NOT EDIT

use crate::Setting;
#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
use crate::SettingWiredWakeOnLan;
#[cfg(any(feature = "v1_32", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_32")))]
use crate::Ternary;
use glib::object::Cast;
use glib::object::ObjectType as ObjectType_;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib::StaticType;
use glib::ToValue;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem::transmute;

glib::wrapper! {
    #[doc(alias = "NMSettingWired")]
    pub struct SettingWired(Object<ffi::NMSettingWired, ffi::NMSettingWiredClass>) @extends Setting;

    match fn {
        type_ => || ffi::nm_setting_wired_get_type(),
    }
}

impl SettingWired {
    /// Creates a new [`SettingWired`][crate::SettingWired] object with default values.
    ///
    /// # Returns
    ///
    /// the new empty [`SettingWired`][crate::SettingWired] object
    #[doc(alias = "nm_setting_wired_new")]
    pub fn new() -> SettingWired {
        unsafe { Setting::from_glib_full(ffi::nm_setting_wired_new()).unsafe_cast() }
    }

    /// Adds a new MAC address to the `property::SettingWired::mac-address-blacklist` property.
    /// ## `mac`
    /// the MAC address string (hex-digits-and-colons notation) to blacklist
    ///
    /// # Returns
    ///
    /// [`true`] if the MAC address was added; [`false`] if the MAC address
    /// is invalid or was already present
    #[doc(alias = "nm_setting_wired_add_mac_blacklist_item")]
    pub fn add_mac_blacklist_item(&self, mac: &str) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_wired_add_mac_blacklist_item(
                self.to_glib_none().0,
                mac.to_glib_none().0,
            ))
        }
    }

    /// Add an option to the table. If the key already exists, the value gets
    /// replaced.
    ///
    /// Before 1.32, the function would assert that the key is valid. Since then,
    /// an invalid key gets silently added but renders the profile as invalid.
    /// ## `key`
    /// key name for the option
    /// ## `value`
    /// value for the option
    ///
    /// # Returns
    ///
    /// since 1.32 this always returns [`true`].
    #[doc(alias = "nm_setting_wired_add_s390_option")]
    pub fn add_s390_option(&self, key: &str, value: &str) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_wired_add_s390_option(
                self.to_glib_none().0,
                key.to_glib_none().0,
                value.to_glib_none().0,
            ))
        }
    }

    /// Removes all blacklisted MAC addresses.
    #[doc(alias = "nm_setting_wired_clear_mac_blacklist_items")]
    pub fn clear_mac_blacklist_items(&self) {
        unsafe {
            ffi::nm_setting_wired_clear_mac_blacklist_items(self.to_glib_none().0);
        }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingWired::accept-all-mac-addresses` property of the setting
    #[cfg(any(feature = "v1_32", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_32")))]
    #[doc(alias = "nm_setting_wired_get_accept_all_mac_addresses")]
    #[doc(alias = "get_accept_all_mac_addresses")]
    pub fn accept_all_mac_addresses(&self) -> Ternary {
        unsafe {
            from_glib(ffi::nm_setting_wired_get_accept_all_mac_addresses(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingWired::auto-negotiate` property of the setting
    #[doc(alias = "nm_setting_wired_get_auto_negotiate")]
    #[doc(alias = "get_auto_negotiate")]
    pub fn is_auto_negotiate(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_wired_get_auto_negotiate(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingWired::cloned-mac-address` property of the setting
    #[doc(alias = "nm_setting_wired_get_cloned_mac_address")]
    #[doc(alias = "get_cloned_mac_address")]
    pub fn cloned_mac_address(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::nm_setting_wired_get_cloned_mac_address(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingWired::duplex` property of the setting
    #[doc(alias = "nm_setting_wired_get_duplex")]
    #[doc(alias = "get_duplex")]
    pub fn duplex(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::nm_setting_wired_get_duplex(self.to_glib_none().0)) }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingWired::generate-mac-address-mask` property of the setting
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "nm_setting_wired_get_generate_mac_address_mask")]
    #[doc(alias = "get_generate_mac_address_mask")]
    pub fn generate_mac_address_mask(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::nm_setting_wired_get_generate_mac_address_mask(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingWired::mac-address` property of the setting
    #[doc(alias = "nm_setting_wired_get_mac_address")]
    #[doc(alias = "get_mac_address")]
    pub fn mac_address(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::nm_setting_wired_get_mac_address(self.to_glib_none().0)) }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingWired::mac-address-blacklist` property of the setting
    #[doc(alias = "nm_setting_wired_get_mac_address_blacklist")]
    #[doc(alias = "get_mac_address_blacklist")]
    pub fn mac_address_blacklist(&self) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::nm_setting_wired_get_mac_address_blacklist(
                self.to_glib_none().0,
            ))
        }
    }

    /// ## `idx`
    /// the zero-based index of the MAC address entry
    ///
    /// # Returns
    ///
    /// the blacklisted MAC address string (hex-digits-and-colons notation)
    /// at index `idx`
    #[doc(alias = "nm_setting_wired_get_mac_blacklist_item")]
    #[doc(alias = "get_mac_blacklist_item")]
    pub fn mac_blacklist_item(&self, idx: u32) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::nm_setting_wired_get_mac_blacklist_item(
                self.to_glib_none().0,
                idx,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingWired::mtu` property of the setting
    #[doc(alias = "nm_setting_wired_get_mtu")]
    #[doc(alias = "get_mtu")]
    pub fn mtu(&self) -> u32 {
        unsafe { ffi::nm_setting_wired_get_mtu(self.to_glib_none().0) }
    }

    ///
    /// # Returns
    ///
    /// the number of blacklisted MAC addresses
    #[doc(alias = "nm_setting_wired_get_num_mac_blacklist_items")]
    #[doc(alias = "get_num_mac_blacklist_items")]
    pub fn num_mac_blacklist_items(&self) -> u32 {
        unsafe { ffi::nm_setting_wired_get_num_mac_blacklist_items(self.to_glib_none().0) }
    }

    /// Returns the number of s390-specific options that should be set for this
    /// device when it is activated. This can be used to retrieve each s390
    /// option individually using `nm_setting_wired_get_s390_option()`.
    ///
    /// # Returns
    ///
    /// the number of s390-specific device options
    #[doc(alias = "nm_setting_wired_get_num_s390_options")]
    #[doc(alias = "get_num_s390_options")]
    pub fn num_s390_options(&self) -> u32 {
        unsafe { ffi::nm_setting_wired_get_num_s390_options(self.to_glib_none().0) }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingWired::port` property of the setting
    #[doc(alias = "nm_setting_wired_get_port")]
    #[doc(alias = "get_port")]
    pub fn port(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::nm_setting_wired_get_port(self.to_glib_none().0)) }
    }

    /// Returns the s390 device type this connection should apply to. Will be one
    /// of 'qeth', 'lcs', or 'ctc'.
    ///
    /// # Returns
    ///
    /// the s390 device type
    #[doc(alias = "nm_setting_wired_get_s390_nettype")]
    #[doc(alias = "get_s390_nettype")]
    pub fn s390_nettype(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::nm_setting_wired_get_s390_nettype(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the value associated with the s390-specific option specified by
    /// `key`, if it exists.
    /// ## `key`
    /// the key for which to retrieve the value
    ///
    /// # Returns
    ///
    /// the value, or [`None`] if the key/value pair was never added to the
    /// setting; the value is owned by the setting and must not be modified
    #[doc(alias = "nm_setting_wired_get_s390_option_by_key")]
    #[doc(alias = "get_s390_option_by_key")]
    pub fn s390_option_by_key(&self, key: &str) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::nm_setting_wired_get_s390_option_by_key(
                self.to_glib_none().0,
                key.to_glib_none().0,
            ))
        }
    }

    /// Return the list of s390 subchannels that identify the device that this
    /// connection is applicable to. The connection should only be used in
    /// conjunction with that device.
    ///
    /// # Returns
    ///
    /// array of strings, each specifying
    ///  one subchannel the s390 device uses to communicate to the host.
    #[doc(alias = "nm_setting_wired_get_s390_subchannels")]
    #[doc(alias = "get_s390_subchannels")]
    pub fn s390_subchannels(&self) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::nm_setting_wired_get_s390_subchannels(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingWired::speed` property of the setting
    #[doc(alias = "nm_setting_wired_get_speed")]
    #[doc(alias = "get_speed")]
    pub fn speed(&self) -> u32 {
        unsafe { ffi::nm_setting_wired_get_speed(self.to_glib_none().0) }
    }

    /// Returns a list of valid s390 options.
    ///
    /// The `self` argument is unused and [`None`] may be passed instead.
    ///
    /// # Returns
    ///
    /// a [`None`]-terminated array of strings of valid s390 options.
    #[doc(alias = "nm_setting_wired_get_valid_s390_options")]
    #[doc(alias = "get_valid_s390_options")]
    pub fn valid_s390_options(&self) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::nm_setting_wired_get_valid_s390_options(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the Wake-on-LAN options enabled for the connection
    ///
    /// # Returns
    ///
    /// the Wake-on-LAN options
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_setting_wired_get_wake_on_lan")]
    #[doc(alias = "get_wake_on_lan")]
    pub fn wake_on_lan(&self) -> SettingWiredWakeOnLan {
        unsafe { from_glib(ffi::nm_setting_wired_get_wake_on_lan(self.to_glib_none().0)) }
    }

    /// Returns the Wake-on-LAN password. This only applies to
    /// [`SettingWiredWakeOnLan::MAGIC`][crate::SettingWiredWakeOnLan::MAGIC].
    ///
    /// # Returns
    ///
    /// the Wake-on-LAN setting password, or [`None`] if there is no password.
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_setting_wired_get_wake_on_lan_password")]
    #[doc(alias = "get_wake_on_lan_password")]
    pub fn wake_on_lan_password(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::nm_setting_wired_get_wake_on_lan_password(
                self.to_glib_none().0,
            ))
        }
    }

    /// Removes the MAC address at index `idx` from the blacklist.
    /// ## `idx`
    /// index number of the MAC address
    #[doc(alias = "nm_setting_wired_remove_mac_blacklist_item")]
    pub fn remove_mac_blacklist_item(&self, idx: u32) {
        unsafe {
            ffi::nm_setting_wired_remove_mac_blacklist_item(self.to_glib_none().0, idx);
        }
    }

    /// Removes the MAC address `mac` from the blacklist.
    /// ## `mac`
    /// the MAC address string (hex-digits-and-colons notation) to remove from
    /// the blacklist
    ///
    /// # Returns
    ///
    /// [`true`] if the MAC address was found and removed; [`false`] if it was not.
    #[doc(alias = "nm_setting_wired_remove_mac_blacklist_item_by_value")]
    pub fn remove_mac_blacklist_item_by_value(&self, mac: &str) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_wired_remove_mac_blacklist_item_by_value(
                self.to_glib_none().0,
                mac.to_glib_none().0,
            ))
        }
    }

    /// Remove the s390-specific option referenced by `key` from the internal option
    /// list.
    /// ## `key`
    /// key name for the option to remove
    ///
    /// # Returns
    ///
    /// [`true`] if the option was found and removed from the internal option
    /// list, [`false`] if it was not.
    #[doc(alias = "nm_setting_wired_remove_s390_option")]
    pub fn remove_s390_option(&self, key: &str) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_wired_remove_s390_option(
                self.to_glib_none().0,
                key.to_glib_none().0,
            ))
        }
    }

    /// When [`true`], setup the interface to accept packets for all MAC addresses.
    /// This is enabling the kernel interface flag IFF_PROMISC.
    /// When [`false`], the interface will only accept the packets with the
    /// interface destination mac address or broadcast.
    #[cfg(any(feature = "v1_32", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_32")))]
    #[doc(alias = "accept-all-mac-addresses")]
    pub fn set_accept_all_mac_addresses(&self, accept_all_mac_addresses: Ternary) {
        glib::ObjectExt::set_property(self, "accept-all-mac-addresses", &accept_all_mac_addresses)
    }

    /// When [`true`], enforce auto-negotiation of speed and duplex mode.
    /// If "speed" and "duplex" properties are both specified, only that
    /// single mode will be advertised and accepted during the link
    /// auto-negotiation process: this works only for BASE-T 802.3 specifications
    /// and is useful for enforcing gigabits modes, as in these cases link
    /// negotiation is mandatory.
    /// When [`false`], "speed" and "duplex" properties should be both set or
    /// link configuration will be skipped.
    #[doc(alias = "auto-negotiate")]
    pub fn set_auto_negotiate(&self, auto_negotiate: bool) {
        glib::ObjectExt::set_property(self, "auto-negotiate", &auto_negotiate)
    }

    /// If specified, request that the device use this MAC address instead.
    /// This is known as MAC cloning or spoofing.
    ///
    /// Beside explicitly specifying a MAC address, the special values "preserve", "permanent",
    /// "random" and "stable" are supported.
    /// "preserve" means not to touch the MAC address on activation.
    /// "permanent" means to use the permanent hardware address if the device
    /// has one (otherwise this is treated as "preserve").
    /// "random" creates a random MAC address on each connect.
    /// "stable" creates a hashed MAC address based on connection.stable-id and a
    /// machine dependent key.
    ///
    /// If unspecified, the value can be overwritten via global defaults, see manual
    /// of NetworkManager.conf. If still unspecified, it defaults to "preserve"
    /// (older versions of NetworkManager may use a different default value).
    ///
    /// On D-Bus, this field is expressed as "assigned-mac-address" or the deprecated
    /// "cloned-mac-address".
    #[doc(alias = "cloned-mac-address")]
    pub fn set_cloned_mac_address(&self, cloned_mac_address: Option<&str>) {
        glib::ObjectExt::set_property(self, "cloned-mac-address", &cloned_mac_address)
    }

    /// When a value is set, either "half" or "full", configures the device
    /// to use the specified duplex mode. If "auto-negotiate" is "yes" the
    /// specified duplex mode will be the only one advertised during link
    /// negotiation: this works only for BASE-T 802.3 specifications and is
    /// useful for enforcing gigabits modes, as in these cases link negotiation
    /// is mandatory.
    /// If the value is unset (the default), the link configuration will be
    /// either skipped (if "auto-negotiate" is "no", the default) or will
    /// be auto-negotiated (if "auto-negotiate" is "yes") and the local device
    /// will advertise all the supported duplex modes.
    /// Must be set together with the "speed" property if specified.
    /// Before specifying a duplex mode be sure your device supports it.
    pub fn set_duplex(&self, duplex: Option<&str>) {
        glib::ObjectExt::set_property(self, "duplex", &duplex)
    }

    /// With `property::SettingWired::cloned-mac-address` setting "random" or "stable",
    /// by default all bits of the MAC address are scrambled and a locally-administered,
    /// unicast MAC address is created. This property allows to specify that certain bits
    /// are fixed. Note that the least significant bit of the first MAC address will
    /// always be unset to create a unicast MAC address.
    ///
    /// If the property is [`None`], it is eligible to be overwritten by a default
    /// connection setting. If the value is still [`None`] or an empty string, the
    /// default is to create a locally-administered, unicast MAC address.
    ///
    /// If the value contains one MAC address, this address is used as mask. The set
    /// bits of the mask are to be filled with the current MAC address of the device,
    /// while the unset bits are subject to randomization.
    /// Setting "FE:FF:FF:00:00:00" means to preserve the OUI of the current MAC address
    /// and only randomize the lower 3 bytes using the "random" or "stable" algorithm.
    ///
    /// If the value contains one additional MAC address after the mask,
    /// this address is used instead of the current MAC address to fill the bits
    /// that shall not be randomized. For example, a value of
    /// "FE:FF:FF:00:00:00 68:F7:28:00:00:00" will set the OUI of the MAC address
    /// to 68:F7:28, while the lower bits are randomized. A value of
    /// "02:00:00:00:00:00 00:00:00:00:00:00" will create a fully scrambled
    /// globally-administered, burned-in MAC address.
    ///
    /// If the value contains more than one additional MAC addresses, one of
    /// them is chosen randomly. For example, "02:00:00:00:00:00 00:00:00:00:00:00 02:00:00:00:00:00"
    /// will create a fully scrambled MAC address, randomly locally or globally
    /// administered.
    #[doc(alias = "generate-mac-address-mask")]
    pub fn get_property_generate_mac_address_mask(&self) -> Option<glib::GString> {
        glib::ObjectExt::property(self, "generate-mac-address-mask")
    }

    /// With `property::SettingWired::cloned-mac-address` setting "random" or "stable",
    /// by default all bits of the MAC address are scrambled and a locally-administered,
    /// unicast MAC address is created. This property allows to specify that certain bits
    /// are fixed. Note that the least significant bit of the first MAC address will
    /// always be unset to create a unicast MAC address.
    ///
    /// If the property is [`None`], it is eligible to be overwritten by a default
    /// connection setting. If the value is still [`None`] or an empty string, the
    /// default is to create a locally-administered, unicast MAC address.
    ///
    /// If the value contains one MAC address, this address is used as mask. The set
    /// bits of the mask are to be filled with the current MAC address of the device,
    /// while the unset bits are subject to randomization.
    /// Setting "FE:FF:FF:00:00:00" means to preserve the OUI of the current MAC address
    /// and only randomize the lower 3 bytes using the "random" or "stable" algorithm.
    ///
    /// If the value contains one additional MAC address after the mask,
    /// this address is used instead of the current MAC address to fill the bits
    /// that shall not be randomized. For example, a value of
    /// "FE:FF:FF:00:00:00 68:F7:28:00:00:00" will set the OUI of the MAC address
    /// to 68:F7:28, while the lower bits are randomized. A value of
    /// "02:00:00:00:00:00 00:00:00:00:00:00" will create a fully scrambled
    /// globally-administered, burned-in MAC address.
    ///
    /// If the value contains more than one additional MAC addresses, one of
    /// them is chosen randomly. For example, "02:00:00:00:00:00 00:00:00:00:00:00 02:00:00:00:00:00"
    /// will create a fully scrambled MAC address, randomly locally or globally
    /// administered.
    #[doc(alias = "generate-mac-address-mask")]
    pub fn set_generate_mac_address_mask(&self, generate_mac_address_mask: Option<&str>) {
        glib::ObjectExt::set_property(
            self,
            "generate-mac-address-mask",
            &generate_mac_address_mask,
        )
    }

    /// If specified, this connection will only apply to the Ethernet device
    /// whose permanent MAC address matches. This property does not change the
    /// MAC address of the device (i.e. MAC spoofing).
    #[doc(alias = "mac-address")]
    pub fn set_mac_address(&self, mac_address: Option<&str>) {
        glib::ObjectExt::set_property(self, "mac-address", &mac_address)
    }

    /// If specified, this connection will never apply to the Ethernet device
    /// whose permanent MAC address matches an address in the list. Each MAC
    /// address is in the standard hex-digits-and-colons notation
    /// (00:11:22:33:44:55).
    #[doc(alias = "mac-address-blacklist")]
    pub fn set_mac_address_blacklist(&self, mac_address_blacklist: &[&str]) {
        glib::ObjectExt::set_property(self, "mac-address-blacklist", &mac_address_blacklist)
    }

    /// If non-zero, only transmit packets of the specified size or smaller,
    /// breaking larger packets up into multiple Ethernet frames.
    pub fn set_mtu(&self, mtu: u32) {
        glib::ObjectExt::set_property(self, "mtu", &mtu)
    }

    /// Specific port type to use if the device supports multiple
    /// attachment methods. One of "tp" (Twisted Pair), "aui" (Attachment Unit
    /// Interface), "bnc" (Thin Ethernet) or "mii" (Media Independent Interface).
    /// If the device supports only one port type, this setting is ignored.
    pub fn set_port(&self, port: Option<&str>) {
        glib::ObjectExt::set_property(self, "port", &port)
    }

    /// s390 network device type; one of "qeth", "lcs", or "ctc", representing
    /// the different types of virtual network devices available on s390 systems.
    #[doc(alias = "s390-nettype")]
    pub fn set_s390_nettype(&self, s390_nettype: Option<&str>) {
        glib::ObjectExt::set_property(self, "s390-nettype", &s390_nettype)
    }

    //#[doc(alias = "s390-options")]
    //pub fn s390_options(&self) -> /*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 } {
    //    glib::ObjectExt::property(self, "s390-options")
    //}

    //#[doc(alias = "s390-options")]
    //pub fn set_s390_options(&self, s390_options: /*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }) {
    //    glib::ObjectExt::set_property(self,"s390-options", &s390_options)
    //}

    /// Identifies specific subchannels that this network device uses for
    /// communication with z/VM or s390 host. Like the
    /// `property::SettingWired::mac-address` property for non-z/VM devices, this property
    /// can be used to ensure this connection only applies to the network device
    /// that uses these subchannels. The list should contain exactly 3 strings,
    /// and each string may only be composed of hexadecimal characters and the
    /// period (.) character.
    #[doc(alias = "s390-subchannels")]
    pub fn set_s390_subchannels(&self, s390_subchannels: &[&str]) {
        glib::ObjectExt::set_property(self, "s390-subchannels", &s390_subchannels)
    }

    /// When a value greater than 0 is set, configures the device to use
    /// the specified speed. If "auto-negotiate" is "yes" the specified
    /// speed will be the only one advertised during link negotiation:
    /// this works only for BASE-T 802.3 specifications and is useful for
    /// enforcing gigabit speeds, as in this case link negotiation is
    /// mandatory.
    /// If the value is unset (0, the default), the link configuration will be
    /// either skipped (if "auto-negotiate" is "no", the default) or will
    /// be auto-negotiated (if "auto-negotiate" is "yes") and the local device
    /// will advertise all the supported speeds.
    /// In Mbit/s, ie 100 == 100Mbit/s.
    /// Must be set together with the "duplex" property when non-zero.
    /// Before specifying a speed value be sure your device supports it.
    pub fn set_speed(&self, speed: u32) {
        glib::ObjectExt::set_property(self, "speed", &speed)
    }

    /// The [`SettingWiredWakeOnLan`][crate::SettingWiredWakeOnLan] options to enable. Not all devices support all options.
    /// May be any combination of [`SettingWiredWakeOnLan::PHY`][crate::SettingWiredWakeOnLan::PHY],
    /// [`SettingWiredWakeOnLan::UNICAST`][crate::SettingWiredWakeOnLan::UNICAST], [`SettingWiredWakeOnLan::MULTICAST`][crate::SettingWiredWakeOnLan::MULTICAST],
    /// [`SettingWiredWakeOnLan::BROADCAST`][crate::SettingWiredWakeOnLan::BROADCAST], [`SettingWiredWakeOnLan::ARP`][crate::SettingWiredWakeOnLan::ARP],
    /// [`SettingWiredWakeOnLan::MAGIC`][crate::SettingWiredWakeOnLan::MAGIC] or the special values
    /// [`SettingWiredWakeOnLan::DEFAULT`][crate::SettingWiredWakeOnLan::DEFAULT] (to use global settings) and
    /// [`SettingWiredWakeOnLan::IGNORE`][crate::SettingWiredWakeOnLan::IGNORE] (to disable management of Wake-on-LAN in
    /// NetworkManager).
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "wake-on-lan")]
    pub fn set_wake_on_lan(&self, wake_on_lan: u32) {
        glib::ObjectExt::set_property(self, "wake-on-lan", &wake_on_lan)
    }

    /// If specified, the password used with magic-packet-based
    /// Wake-on-LAN, represented as an Ethernet MAC address. If [`None`],
    /// no password will be required.
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "wake-on-lan-password")]
    pub fn set_wake_on_lan_password(&self, wake_on_lan_password: Option<&str>) {
        glib::ObjectExt::set_property(self, "wake-on-lan-password", &wake_on_lan_password)
    }

    #[cfg(any(feature = "v1_32", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_32")))]
    #[doc(alias = "accept-all-mac-addresses")]
    pub fn connect_accept_all_mac_addresses_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_accept_all_mac_addresses_trampoline<
            F: Fn(&SettingWired) + 'static,
        >(
            this: *mut ffi::NMSettingWired,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::accept-all-mac-addresses\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_accept_all_mac_addresses_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "auto-negotiate")]
    pub fn connect_auto_negotiate_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_auto_negotiate_trampoline<F: Fn(&SettingWired) + 'static>(
            this: *mut ffi::NMSettingWired,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::auto-negotiate\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_auto_negotiate_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "cloned-mac-address")]
    pub fn connect_cloned_mac_address_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_cloned_mac_address_trampoline<
            F: Fn(&SettingWired) + 'static,
        >(
            this: *mut ffi::NMSettingWired,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::cloned-mac-address\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_cloned_mac_address_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "duplex")]
    pub fn connect_duplex_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_duplex_trampoline<F: Fn(&SettingWired) + 'static>(
            this: *mut ffi::NMSettingWired,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::duplex\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_duplex_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "generate-mac-address-mask")]
    pub fn connect_generate_mac_address_mask_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_generate_mac_address_mask_trampoline<
            F: Fn(&SettingWired) + 'static,
        >(
            this: *mut ffi::NMSettingWired,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::generate-mac-address-mask\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_generate_mac_address_mask_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "mac-address")]
    pub fn connect_mac_address_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mac_address_trampoline<F: Fn(&SettingWired) + 'static>(
            this: *mut ffi::NMSettingWired,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::mac-address\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_mac_address_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "mac-address-blacklist")]
    pub fn connect_mac_address_blacklist_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_mac_address_blacklist_trampoline<
            F: Fn(&SettingWired) + 'static,
        >(
            this: *mut ffi::NMSettingWired,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::mac-address-blacklist\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_mac_address_blacklist_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "mtu")]
    pub fn connect_mtu_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mtu_trampoline<F: Fn(&SettingWired) + 'static>(
            this: *mut ffi::NMSettingWired,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::mtu\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_mtu_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "port")]
    pub fn connect_port_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_port_trampoline<F: Fn(&SettingWired) + 'static>(
            this: *mut ffi::NMSettingWired,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::port\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_port_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "s390-nettype")]
    pub fn connect_s390_nettype_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_s390_nettype_trampoline<F: Fn(&SettingWired) + 'static>(
            this: *mut ffi::NMSettingWired,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::s390-nettype\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_s390_nettype_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "s390-options")]
    pub fn connect_s390_options_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_s390_options_trampoline<F: Fn(&SettingWired) + 'static>(
            this: *mut ffi::NMSettingWired,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::s390-options\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_s390_options_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "s390-subchannels")]
    pub fn connect_s390_subchannels_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_s390_subchannels_trampoline<F: Fn(&SettingWired) + 'static>(
            this: *mut ffi::NMSettingWired,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::s390-subchannels\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_s390_subchannels_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "speed")]
    pub fn connect_speed_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_speed_trampoline<F: Fn(&SettingWired) + 'static>(
            this: *mut ffi::NMSettingWired,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::speed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_speed_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "wake-on-lan")]
    pub fn connect_wake_on_lan_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_wake_on_lan_trampoline<F: Fn(&SettingWired) + 'static>(
            this: *mut ffi::NMSettingWired,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::wake-on-lan\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_wake_on_lan_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "wake-on-lan-password")]
    pub fn connect_wake_on_lan_password_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_wake_on_lan_password_trampoline<
            F: Fn(&SettingWired) + 'static,
        >(
            this: *mut ffi::NMSettingWired,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::wake-on-lan-password\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_wake_on_lan_password_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl Default for SettingWired {
    fn default() -> Self {
        Self::new()
    }
}

impl fmt::Display for SettingWired {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("SettingWired")
    }
}
