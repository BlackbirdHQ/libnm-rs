// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files
// DO NOT EDIT

use crate::Setting;
use crate::SettingIPConfig;
use glib::object::Cast;
use glib::object::ObjectType as ObjectType_;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib::StaticType;
use glib::ToValue;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem::transmute;

glib::wrapper! {
    #[doc(alias = "NMSettingIP4Config")]
    pub struct SettingIP4Config(Object<ffi::NMSettingIP4Config, ffi::NMSettingIP4ConfigClass>) @extends SettingIPConfig, Setting;

    match fn {
        type_ => || ffi::nm_setting_ip4_config_get_type(),
    }
}

impl SettingIP4Config {
    /// Creates a new [`SettingIP4Config`][crate::SettingIP4Config] object with default values.
    ///
    /// # Returns
    ///
    /// the new empty [`SettingIP4Config`][crate::SettingIP4Config] object
    #[doc(alias = "nm_setting_ip4_config_new")]
    pub fn new() -> SettingIP4Config {
        unsafe { Setting::from_glib_full(ffi::nm_setting_ip4_config_new()).unsafe_cast() }
    }

    /// Returns the value contained in the `property::SettingIP4Config::dhcp-client-id`
    /// property.
    ///
    /// # Returns
    ///
    /// the configured Client ID to send to the DHCP server when requesting
    /// addresses via DHCP.
    #[doc(alias = "nm_setting_ip4_config_get_dhcp_client_id")]
    #[doc(alias = "get_dhcp_client_id")]
    pub fn dhcp_client_id(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::nm_setting_ip4_config_get_dhcp_client_id(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the value contained in the `property::SettingIP4Config::dhcp-fqdn`
    /// property.
    ///
    /// # Returns
    ///
    /// the configured FQDN to send to the DHCP server
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_setting_ip4_config_get_dhcp_fqdn")]
    #[doc(alias = "get_dhcp_fqdn")]
    pub fn dhcp_fqdn(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::nm_setting_ip4_config_get_dhcp_fqdn(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the value contained in the `property::SettingIP4Config::dhcp_vendor_class_identifier`
    /// property.
    ///
    /// # Returns
    ///
    /// the vendor class identifier option to send to the DHCP server
    #[cfg(any(feature = "v1_28", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_28")))]
    #[doc(alias = "nm_setting_ip4_config_get_dhcp_vendor_class_identifier")]
    #[doc(alias = "get_dhcp_vendor_class_identifier")]
    pub fn dhcp_vendor_class_identifier(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::nm_setting_ip4_config_get_dhcp_vendor_class_identifier(
                self.to_glib_none().0,
            ))
        }
    }

    /// A string sent to the DHCP server to identify the local machine which the
    /// DHCP server may use to customize the DHCP lease and options.
    /// When the property is a hex string ('aa:bb:cc') it is interpreted as a
    /// binary client ID, in which case the first byte is assumed to be the
    /// 'type' field as per RFC 2132 section 9.14 and the remaining bytes may be
    /// an hardware address (e.g. '01:xx:xx:xx:xx:xx:xx' where 1 is the Ethernet
    /// ARP type and the rest is a MAC address).
    /// If the property is not a hex string it is considered as a
    /// non-hardware-address client ID and the 'type' field is set to 0.
    ///
    /// The special values "mac" and "perm-mac" are supported, which use the
    /// current or permanent MAC address of the device to generate a client identifier
    /// with type ethernet (01). Currently, these options only work for ethernet
    /// type of links.
    ///
    /// The special value "ipv6-duid" uses the DUID from "ipv6.dhcp-duid" property as
    /// an RFC4361-compliant client identifier. As IAID it uses "ipv4.dhcp-iaid"
    /// and falls back to "ipv6.dhcp-iaid" if unset.
    ///
    /// The special value "duid" generates a RFC4361-compliant client identifier based
    /// on "ipv4.dhcp-iaid" and uses a DUID generated by hashing /etc/machine-id.
    ///
    /// The special value "stable" is supported to generate a type 0 client identifier based
    /// on the stable-id (see connection.stable-id) and a per-host key. If you set the
    /// stable-id, you may want to include the "${DEVICE}" or "${MAC}" specifier to get a
    /// per-device key.
    ///
    /// If unset, a globally configured default is used. If still unset, the default
    /// depends on the DHCP plugin.
    #[doc(alias = "dhcp-client-id")]
    pub fn set_dhcp_client_id(&self, dhcp_client_id: Option<&str>) {
        glib::ObjectExt::set_property(self, "dhcp-client-id", &dhcp_client_id)
    }

    /// If the `property::SettingIPConfig::dhcp-send-hostname` property is [`true`], then the
    /// specified FQDN will be sent to the DHCP server when acquiring a lease. This
    /// property and `property::SettingIPConfig::dhcp-hostname` are mutually exclusive and
    /// cannot be set at the same time.
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "dhcp-fqdn")]
    pub fn set_dhcp_fqdn(&self, dhcp_fqdn: Option<&str>) {
        glib::ObjectExt::set_property(self, "dhcp-fqdn", &dhcp_fqdn)
    }

    /// The Vendor Class Identifier DHCP option (60).
    /// Special characters in the data string may be escaped using C-style escapes,
    /// nevertheless this property cannot contain nul bytes.
    /// If the per-profile value is unspecified (the default),
    /// a global connection default gets consulted.
    /// If still unspecified, the DHCP option is not sent to the server.
    ///
    /// Since 1.28
    #[doc(alias = "dhcp-vendor-class-identifier")]
    pub fn get_property_dhcp_vendor_class_identifier(&self) -> Option<glib::GString> {
        glib::ObjectExt::property(self, "dhcp-vendor-class-identifier")
    }

    /// The Vendor Class Identifier DHCP option (60).
    /// Special characters in the data string may be escaped using C-style escapes,
    /// nevertheless this property cannot contain nul bytes.
    /// If the per-profile value is unspecified (the default),
    /// a global connection default gets consulted.
    /// If still unspecified, the DHCP option is not sent to the server.
    ///
    /// Since 1.28
    #[doc(alias = "dhcp-vendor-class-identifier")]
    pub fn set_dhcp_vendor_class_identifier(&self, dhcp_vendor_class_identifier: Option<&str>) {
        glib::ObjectExt::set_property(
            self,
            "dhcp-vendor-class-identifier",
            &dhcp_vendor_class_identifier,
        )
    }

    #[doc(alias = "dhcp-client-id")]
    pub fn connect_dhcp_client_id_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_dhcp_client_id_trampoline<
            F: Fn(&SettingIP4Config) + 'static,
        >(
            this: *mut ffi::NMSettingIP4Config,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::dhcp-client-id\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_dhcp_client_id_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "dhcp-fqdn")]
    pub fn connect_dhcp_fqdn_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_dhcp_fqdn_trampoline<F: Fn(&SettingIP4Config) + 'static>(
            this: *mut ffi::NMSettingIP4Config,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::dhcp-fqdn\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_dhcp_fqdn_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "dhcp-vendor-class-identifier")]
    pub fn connect_dhcp_vendor_class_identifier_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_dhcp_vendor_class_identifier_trampoline<
            F: Fn(&SettingIP4Config) + 'static,
        >(
            this: *mut ffi::NMSettingIP4Config,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::dhcp-vendor-class-identifier\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_dhcp_vendor_class_identifier_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl Default for SettingIP4Config {
    fn default() -> Self {
        Self::new()
    }
}

impl fmt::Display for SettingIP4Config {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("SettingIP4Config")
    }
}
