// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::object::Cast;
use glib::object::IsA;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib::Value;
use glib_sys;
use gobject_sys;
use nm_sys;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem::transmute;
use Setting;

glib_wrapper! {
    pub struct SettingPpp(Object<nm_sys::NMSettingPpp, nm_sys::NMSettingPppClass, SettingPppClass>) @extends Setting;

    match fn {
        get_type => || nm_sys::nm_setting_ppp_get_type(),
    }
}

impl SettingPpp {
    pub fn new() -> SettingPpp {
        unsafe { Setting::from_glib_full(nm_sys::nm_setting_ppp_new()).unsafe_cast() }
    }
}

impl Default for SettingPpp {
    fn default() -> Self {
        Self::new()
    }
}

pub const NONE_SETTING_PPP: Option<&SettingPpp> = None;

pub trait SettingPppExt: 'static {
    fn get_baud(&self) -> u32;

    fn get_crtscts(&self) -> bool;

    fn get_lcp_echo_failure(&self) -> u32;

    fn get_lcp_echo_interval(&self) -> u32;

    fn get_mppe_stateful(&self) -> bool;

    fn get_mru(&self) -> u32;

    fn get_mtu(&self) -> u32;

    fn get_no_vj_comp(&self) -> bool;

    fn get_noauth(&self) -> bool;

    fn get_nobsdcomp(&self) -> bool;

    fn get_nodeflate(&self) -> bool;

    fn get_refuse_chap(&self) -> bool;

    fn get_refuse_eap(&self) -> bool;

    fn get_refuse_mschap(&self) -> bool;

    fn get_refuse_mschapv2(&self) -> bool;

    fn get_refuse_pap(&self) -> bool;

    fn get_require_mppe(&self) -> bool;

    fn get_require_mppe_128(&self) -> bool;

    fn set_property_baud(&self, baud: u32);

    fn set_property_crtscts(&self, crtscts: bool);

    fn set_property_lcp_echo_failure(&self, lcp_echo_failure: u32);

    fn set_property_lcp_echo_interval(&self, lcp_echo_interval: u32);

    fn set_property_mppe_stateful(&self, mppe_stateful: bool);

    fn set_property_mru(&self, mru: u32);

    fn set_property_mtu(&self, mtu: u32);

    fn set_property_no_vj_comp(&self, no_vj_comp: bool);

    fn set_property_noauth(&self, noauth: bool);

    fn set_property_nobsdcomp(&self, nobsdcomp: bool);

    fn set_property_nodeflate(&self, nodeflate: bool);

    fn set_property_refuse_chap(&self, refuse_chap: bool);

    fn set_property_refuse_eap(&self, refuse_eap: bool);

    fn set_property_refuse_mschap(&self, refuse_mschap: bool);

    fn set_property_refuse_mschapv2(&self, refuse_mschapv2: bool);

    fn set_property_refuse_pap(&self, refuse_pap: bool);

    fn set_property_require_mppe(&self, require_mppe: bool);

    fn set_property_require_mppe_128(&self, require_mppe_128: bool);

    fn connect_property_baud_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_crtscts_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_lcp_echo_failure_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_lcp_echo_interval_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_mppe_stateful_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_mru_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_mtu_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_no_vj_comp_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_noauth_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_nobsdcomp_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_nodeflate_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_refuse_chap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_refuse_eap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_refuse_mschap_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_refuse_mschapv2_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_refuse_pap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_require_mppe_notify<F: Fn(&Self) + 'static>(&self, f: F)
        -> SignalHandlerId;

    fn connect_property_require_mppe_128_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;
}

impl<O: IsA<SettingPpp>> SettingPppExt for O {
    fn get_baud(&self) -> u32 {
        unsafe { nm_sys::nm_setting_ppp_get_baud(self.as_ref().to_glib_none().0) }
    }

    fn get_crtscts(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_crtscts(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_lcp_echo_failure(&self) -> u32 {
        unsafe { nm_sys::nm_setting_ppp_get_lcp_echo_failure(self.as_ref().to_glib_none().0) }
    }

    fn get_lcp_echo_interval(&self) -> u32 {
        unsafe { nm_sys::nm_setting_ppp_get_lcp_echo_interval(self.as_ref().to_glib_none().0) }
    }

    fn get_mppe_stateful(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_mppe_stateful(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_mru(&self) -> u32 {
        unsafe { nm_sys::nm_setting_ppp_get_mru(self.as_ref().to_glib_none().0) }
    }

    fn get_mtu(&self) -> u32 {
        unsafe { nm_sys::nm_setting_ppp_get_mtu(self.as_ref().to_glib_none().0) }
    }

    fn get_no_vj_comp(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_no_vj_comp(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_noauth(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_noauth(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_nobsdcomp(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_nobsdcomp(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_nodeflate(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_nodeflate(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_refuse_chap(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_refuse_chap(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_refuse_eap(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_refuse_eap(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_refuse_mschap(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_refuse_mschap(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_refuse_mschapv2(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_refuse_mschapv2(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_refuse_pap(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_refuse_pap(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_require_mppe(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_require_mppe(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_require_mppe_128(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_require_mppe_128(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn set_property_baud(&self, baud: u32) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"baud\0".as_ptr() as *const _,
                Value::from(&baud).to_glib_none().0,
            );
        }
    }

    fn set_property_crtscts(&self, crtscts: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"crtscts\0".as_ptr() as *const _,
                Value::from(&crtscts).to_glib_none().0,
            );
        }
    }

    fn set_property_lcp_echo_failure(&self, lcp_echo_failure: u32) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"lcp-echo-failure\0".as_ptr() as *const _,
                Value::from(&lcp_echo_failure).to_glib_none().0,
            );
        }
    }

    fn set_property_lcp_echo_interval(&self, lcp_echo_interval: u32) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"lcp-echo-interval\0".as_ptr() as *const _,
                Value::from(&lcp_echo_interval).to_glib_none().0,
            );
        }
    }

    fn set_property_mppe_stateful(&self, mppe_stateful: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"mppe-stateful\0".as_ptr() as *const _,
                Value::from(&mppe_stateful).to_glib_none().0,
            );
        }
    }

    fn set_property_mru(&self, mru: u32) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"mru\0".as_ptr() as *const _,
                Value::from(&mru).to_glib_none().0,
            );
        }
    }

    fn set_property_mtu(&self, mtu: u32) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"mtu\0".as_ptr() as *const _,
                Value::from(&mtu).to_glib_none().0,
            );
        }
    }

    fn set_property_no_vj_comp(&self, no_vj_comp: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"no-vj-comp\0".as_ptr() as *const _,
                Value::from(&no_vj_comp).to_glib_none().0,
            );
        }
    }

    fn set_property_noauth(&self, noauth: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"noauth\0".as_ptr() as *const _,
                Value::from(&noauth).to_glib_none().0,
            );
        }
    }

    fn set_property_nobsdcomp(&self, nobsdcomp: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"nobsdcomp\0".as_ptr() as *const _,
                Value::from(&nobsdcomp).to_glib_none().0,
            );
        }
    }

    fn set_property_nodeflate(&self, nodeflate: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"nodeflate\0".as_ptr() as *const _,
                Value::from(&nodeflate).to_glib_none().0,
            );
        }
    }

    fn set_property_refuse_chap(&self, refuse_chap: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"refuse-chap\0".as_ptr() as *const _,
                Value::from(&refuse_chap).to_glib_none().0,
            );
        }
    }

    fn set_property_refuse_eap(&self, refuse_eap: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"refuse-eap\0".as_ptr() as *const _,
                Value::from(&refuse_eap).to_glib_none().0,
            );
        }
    }

    fn set_property_refuse_mschap(&self, refuse_mschap: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"refuse-mschap\0".as_ptr() as *const _,
                Value::from(&refuse_mschap).to_glib_none().0,
            );
        }
    }

    fn set_property_refuse_mschapv2(&self, refuse_mschapv2: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"refuse-mschapv2\0".as_ptr() as *const _,
                Value::from(&refuse_mschapv2).to_glib_none().0,
            );
        }
    }

    fn set_property_refuse_pap(&self, refuse_pap: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"refuse-pap\0".as_ptr() as *const _,
                Value::from(&refuse_pap).to_glib_none().0,
            );
        }
    }

    fn set_property_require_mppe(&self, require_mppe: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"require-mppe\0".as_ptr() as *const _,
                Value::from(&require_mppe).to_glib_none().0,
            );
        }
    }

    fn set_property_require_mppe_128(&self, require_mppe_128: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"require-mppe-128\0".as_ptr() as *const _,
                Value::from(&require_mppe_128).to_glib_none().0,
            );
        }
    }

    fn connect_property_baud_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_baud_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::baud\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_baud_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_crtscts_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_crtscts_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::crtscts\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_crtscts_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_lcp_echo_failure_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_lcp_echo_failure_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::lcp-echo-failure\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_lcp_echo_failure_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_lcp_echo_interval_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_lcp_echo_interval_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::lcp-echo-interval\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_lcp_echo_interval_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_mppe_stateful_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_mppe_stateful_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::mppe-stateful\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_mppe_stateful_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_mru_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mru_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::mru\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_mru_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_mtu_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mtu_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::mtu\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_mtu_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_no_vj_comp_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_no_vj_comp_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::no-vj-comp\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_no_vj_comp_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_noauth_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_noauth_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::noauth\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_noauth_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_nobsdcomp_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_nobsdcomp_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::nobsdcomp\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_nobsdcomp_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_nodeflate_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_nodeflate_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::nodeflate\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_nodeflate_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_refuse_chap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_chap_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::refuse-chap\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_refuse_chap_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_refuse_eap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_eap_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::refuse-eap\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_refuse_eap_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_refuse_mschap_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_mschap_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::refuse-mschap\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_refuse_mschap_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_refuse_mschapv2_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_mschapv2_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::refuse-mschapv2\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_refuse_mschapv2_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_refuse_pap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_pap_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::refuse-pap\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_refuse_pap_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_require_mppe_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_require_mppe_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::require-mppe\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_require_mppe_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_require_mppe_128_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_require_mppe_128_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::require-mppe-128\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_require_mppe_128_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl fmt::Display for SettingPpp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "SettingPpp")
    }
}
