// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::object::Cast;
use glib::object::IsA;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib::Value;
use glib_sys;
use gobject_sys;
use nm_sys;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem::transmute;
use crate::Setting;

glib_wrapper! {
    pub struct SettingPpp(Object<nm_sys::NMSettingPpp, nm_sys::NMSettingPppClass, SettingPppClass>) @extends Setting;

    match fn {
        get_type => || nm_sys::nm_setting_ppp_get_type(),
    }
}

impl SettingPpp {
    /// Creates a new `SettingPpp` object with default values.
    ///
    /// # Returns
    ///
    /// the new empty `SettingPpp` object
    pub fn new() -> SettingPpp {
        unsafe { Setting::from_glib_full(nm_sys::nm_setting_ppp_new()).unsafe_cast() }
    }
}

impl Default for SettingPpp {
    fn default() -> Self {
        Self::new()
    }
}

pub const NONE_SETTING_PPP: Option<&SettingPpp> = None;

/// Trait containing all `SettingPpp` methods.
///
/// # Implementors
///
/// [`SettingPpp`](struct.SettingPpp.html)
pub trait SettingPppExt: 'static {
    ///
    /// # Returns
    ///
    /// the `SettingPpp:baud` property of the setting
    fn get_baud(&self) -> u32;

    ///
    /// # Returns
    ///
    /// the `SettingPpp:crtscts` property of the setting
    fn get_crtscts(&self) -> bool;

    ///
    /// # Returns
    ///
    /// the `SettingPpp:lcp-echo-failure` property of the setting
    fn get_lcp_echo_failure(&self) -> u32;

    ///
    /// # Returns
    ///
    /// the `SettingPpp:lcp-echo-interval` property of the setting
    fn get_lcp_echo_interval(&self) -> u32;

    ///
    /// # Returns
    ///
    /// the `SettingPpp:mppe-stateful` property of the setting
    fn get_mppe_stateful(&self) -> bool;

    ///
    /// # Returns
    ///
    /// the `SettingPpp:mru` property of the setting
    fn get_mru(&self) -> u32;

    ///
    /// # Returns
    ///
    /// the `SettingPpp:mtu` property of the setting
    fn get_mtu(&self) -> u32;

    ///
    /// # Returns
    ///
    /// the `SettingPpp:no-vj-comp` property of the setting
    fn get_no_vj_comp(&self) -> bool;

    ///
    /// # Returns
    ///
    /// the `SettingPpp:noauth` property of the setting
    fn get_noauth(&self) -> bool;

    ///
    /// # Returns
    ///
    /// the `SettingPpp:nobsdcomp` property of the setting
    fn get_nobsdcomp(&self) -> bool;

    ///
    /// # Returns
    ///
    /// the `SettingPpp:nodeflate` property of the setting
    fn get_nodeflate(&self) -> bool;

    ///
    /// # Returns
    ///
    /// the `SettingPpp:refuse-chap` property of the setting
    fn get_refuse_chap(&self) -> bool;

    ///
    /// # Returns
    ///
    /// the `SettingPpp:refuse-eap` property of the setting
    fn get_refuse_eap(&self) -> bool;

    ///
    /// # Returns
    ///
    /// the `SettingPpp:refuse-mschap` property of the setting
    fn get_refuse_mschap(&self) -> bool;

    ///
    /// # Returns
    ///
    /// the `SettingPpp:refuse-mschapv2` property of the setting
    fn get_refuse_mschapv2(&self) -> bool;

    ///
    /// # Returns
    ///
    /// the `SettingPpp:refuse-pap` property of the setting
    fn get_refuse_pap(&self) -> bool;

    ///
    /// # Returns
    ///
    /// the `SettingPpp:require-mppe` property of the setting
    fn get_require_mppe(&self) -> bool;

    ///
    /// # Returns
    ///
    /// the `SettingPpp:require-mppe-128` property of the setting
    fn get_require_mppe_128(&self) -> bool;

    /// If non-zero, instruct pppd to set the serial port to the specified
    /// baudrate. This value should normally be left as 0 to automatically
    /// choose the speed.
    fn set_property_baud(&self, baud: u32);

    /// If `true`, specify that pppd should set the serial port to use hardware
    /// flow control with RTS and CTS signals. This value should normally be set
    /// to `false`.
    fn set_property_crtscts(&self, crtscts: bool);

    /// If non-zero, instruct pppd to presume the connection to the peer has
    /// failed if the specified number of LCP echo-requests go unanswered by the
    /// peer. The "lcp-echo-interval" property must also be set to a non-zero
    /// value if this property is used.
    fn set_property_lcp_echo_failure(&self, lcp_echo_failure: u32);

    /// If non-zero, instruct pppd to send an LCP echo-request frame to the peer
    /// every n seconds (where n is the specified value). Note that some PPP
    /// peers will respond to echo requests and some will not, and it is not
    /// possible to autodetect this.
    fn set_property_lcp_echo_interval(&self, lcp_echo_interval: u32);

    /// If `true`, stateful MPPE is used. See pppd documentation for more
    /// information on stateful MPPE.
    fn set_property_mppe_stateful(&self, mppe_stateful: bool);

    /// If non-zero, instruct pppd to request that the peer send packets no
    /// larger than the specified size. If non-zero, the MRU should be between
    /// 128 and 16384.
    fn set_property_mru(&self, mru: u32);

    /// If non-zero, instruct pppd to send packets no larger than the specified
    /// size.
    fn set_property_mtu(&self, mtu: u32);

    /// If `true`, Van Jacobsen TCP header compression will not be requested.
    fn set_property_no_vj_comp(&self, no_vj_comp: bool);

    /// If `true`, do not require the other side (usually the PPP server) to
    /// authenticate itself to the client. If `false`, require authentication
    /// from the remote side. In almost all cases, this should be `true`.
    fn set_property_noauth(&self, noauth: bool);

    /// If `true`, BSD compression will not be requested.
    fn set_property_nobsdcomp(&self, nobsdcomp: bool);

    /// If `true`, "deflate" compression will not be requested.
    fn set_property_nodeflate(&self, nodeflate: bool);

    /// If `true`, the CHAP authentication method will not be used.
    fn set_property_refuse_chap(&self, refuse_chap: bool);

    /// If `true`, the EAP authentication method will not be used.
    fn set_property_refuse_eap(&self, refuse_eap: bool);

    /// If `true`, the MSCHAP authentication method will not be used.
    fn set_property_refuse_mschap(&self, refuse_mschap: bool);

    /// If `true`, the MSCHAPv2 authentication method will not be used.
    fn set_property_refuse_mschapv2(&self, refuse_mschapv2: bool);

    /// If `true`, the PAP authentication method will not be used.
    fn set_property_refuse_pap(&self, refuse_pap: bool);

    /// If `true`, MPPE (Microsoft Point-to-Point Encryption) will be required for
    /// the PPP session. If either 64-bit or 128-bit MPPE is not available the
    /// session will fail. Note that MPPE is not used on mobile broadband
    /// connections.
    fn set_property_require_mppe(&self, require_mppe: bool);

    /// If `true`, 128-bit MPPE (Microsoft Point-to-Point Encryption) will be
    /// required for the PPP session, and the "require-mppe" property must also
    /// be set to `true`. If 128-bit MPPE is not available the session will fail.
    fn set_property_require_mppe_128(&self, require_mppe_128: bool);

    fn connect_property_baud_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_crtscts_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_lcp_echo_failure_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_lcp_echo_interval_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_mppe_stateful_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_mru_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_mtu_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_no_vj_comp_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_noauth_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_nobsdcomp_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_nodeflate_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_refuse_chap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_refuse_eap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_refuse_mschap_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_refuse_mschapv2_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_refuse_pap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_require_mppe_notify<F: Fn(&Self) + 'static>(&self, f: F)
        -> SignalHandlerId;

    fn connect_property_require_mppe_128_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;
}

impl<O: IsA<SettingPpp>> SettingPppExt for O {
    fn get_baud(&self) -> u32 {
        unsafe { nm_sys::nm_setting_ppp_get_baud(self.as_ref().to_glib_none().0) }
    }

    fn get_crtscts(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_crtscts(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_lcp_echo_failure(&self) -> u32 {
        unsafe { nm_sys::nm_setting_ppp_get_lcp_echo_failure(self.as_ref().to_glib_none().0) }
    }

    fn get_lcp_echo_interval(&self) -> u32 {
        unsafe { nm_sys::nm_setting_ppp_get_lcp_echo_interval(self.as_ref().to_glib_none().0) }
    }

    fn get_mppe_stateful(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_mppe_stateful(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_mru(&self) -> u32 {
        unsafe { nm_sys::nm_setting_ppp_get_mru(self.as_ref().to_glib_none().0) }
    }

    fn get_mtu(&self) -> u32 {
        unsafe { nm_sys::nm_setting_ppp_get_mtu(self.as_ref().to_glib_none().0) }
    }

    fn get_no_vj_comp(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_no_vj_comp(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_noauth(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_noauth(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_nobsdcomp(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_nobsdcomp(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_nodeflate(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_nodeflate(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_refuse_chap(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_refuse_chap(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_refuse_eap(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_refuse_eap(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_refuse_mschap(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_refuse_mschap(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_refuse_mschapv2(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_refuse_mschapv2(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_refuse_pap(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_refuse_pap(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_require_mppe(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_require_mppe(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_require_mppe_128(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_ppp_get_require_mppe_128(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn set_property_baud(&self, baud: u32) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"baud\0".as_ptr() as *const _,
                Value::from(&baud).to_glib_none().0,
            );
        }
    }

    fn set_property_crtscts(&self, crtscts: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"crtscts\0".as_ptr() as *const _,
                Value::from(&crtscts).to_glib_none().0,
            );
        }
    }

    fn set_property_lcp_echo_failure(&self, lcp_echo_failure: u32) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"lcp-echo-failure\0".as_ptr() as *const _,
                Value::from(&lcp_echo_failure).to_glib_none().0,
            );
        }
    }

    fn set_property_lcp_echo_interval(&self, lcp_echo_interval: u32) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"lcp-echo-interval\0".as_ptr() as *const _,
                Value::from(&lcp_echo_interval).to_glib_none().0,
            );
        }
    }

    fn set_property_mppe_stateful(&self, mppe_stateful: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"mppe-stateful\0".as_ptr() as *const _,
                Value::from(&mppe_stateful).to_glib_none().0,
            );
        }
    }

    fn set_property_mru(&self, mru: u32) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"mru\0".as_ptr() as *const _,
                Value::from(&mru).to_glib_none().0,
            );
        }
    }

    fn set_property_mtu(&self, mtu: u32) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"mtu\0".as_ptr() as *const _,
                Value::from(&mtu).to_glib_none().0,
            );
        }
    }

    fn set_property_no_vj_comp(&self, no_vj_comp: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"no-vj-comp\0".as_ptr() as *const _,
                Value::from(&no_vj_comp).to_glib_none().0,
            );
        }
    }

    fn set_property_noauth(&self, noauth: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"noauth\0".as_ptr() as *const _,
                Value::from(&noauth).to_glib_none().0,
            );
        }
    }

    fn set_property_nobsdcomp(&self, nobsdcomp: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"nobsdcomp\0".as_ptr() as *const _,
                Value::from(&nobsdcomp).to_glib_none().0,
            );
        }
    }

    fn set_property_nodeflate(&self, nodeflate: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"nodeflate\0".as_ptr() as *const _,
                Value::from(&nodeflate).to_glib_none().0,
            );
        }
    }

    fn set_property_refuse_chap(&self, refuse_chap: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"refuse-chap\0".as_ptr() as *const _,
                Value::from(&refuse_chap).to_glib_none().0,
            );
        }
    }

    fn set_property_refuse_eap(&self, refuse_eap: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"refuse-eap\0".as_ptr() as *const _,
                Value::from(&refuse_eap).to_glib_none().0,
            );
        }
    }

    fn set_property_refuse_mschap(&self, refuse_mschap: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"refuse-mschap\0".as_ptr() as *const _,
                Value::from(&refuse_mschap).to_glib_none().0,
            );
        }
    }

    fn set_property_refuse_mschapv2(&self, refuse_mschapv2: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"refuse-mschapv2\0".as_ptr() as *const _,
                Value::from(&refuse_mschapv2).to_glib_none().0,
            );
        }
    }

    fn set_property_refuse_pap(&self, refuse_pap: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"refuse-pap\0".as_ptr() as *const _,
                Value::from(&refuse_pap).to_glib_none().0,
            );
        }
    }

    fn set_property_require_mppe(&self, require_mppe: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"require-mppe\0".as_ptr() as *const _,
                Value::from(&require_mppe).to_glib_none().0,
            );
        }
    }

    fn set_property_require_mppe_128(&self, require_mppe_128: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"require-mppe-128\0".as_ptr() as *const _,
                Value::from(&require_mppe_128).to_glib_none().0,
            );
        }
    }

    fn connect_property_baud_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_baud_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::baud\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_baud_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_crtscts_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_crtscts_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::crtscts\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_crtscts_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_lcp_echo_failure_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_lcp_echo_failure_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::lcp-echo-failure\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_lcp_echo_failure_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_lcp_echo_interval_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_lcp_echo_interval_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::lcp-echo-interval\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_lcp_echo_interval_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_mppe_stateful_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_mppe_stateful_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::mppe-stateful\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_mppe_stateful_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_mru_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mru_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::mru\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_mru_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_mtu_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mtu_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::mtu\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_mtu_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_no_vj_comp_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_no_vj_comp_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::no-vj-comp\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_no_vj_comp_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_noauth_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_noauth_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::noauth\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_noauth_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_nobsdcomp_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_nobsdcomp_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::nobsdcomp\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_nobsdcomp_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_nodeflate_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_nodeflate_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::nodeflate\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_nodeflate_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_refuse_chap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_chap_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::refuse-chap\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_refuse_chap_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_refuse_eap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_eap_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::refuse-eap\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_refuse_eap_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_refuse_mschap_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_mschap_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::refuse-mschap\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_refuse_mschap_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_refuse_mschapv2_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_mschapv2_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::refuse-mschapv2\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_refuse_mschapv2_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_refuse_pap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_pap_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::refuse-pap\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_refuse_pap_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_require_mppe_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_require_mppe_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::require-mppe\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_require_mppe_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_require_mppe_128_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_require_mppe_128_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSettingPpp,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SettingPpp>,
        {
            let f: &F = &*(f as *const F);
            f(&SettingPpp::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::require-mppe-128\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_require_mppe_128_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl fmt::Display for SettingPpp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "SettingPpp")
    }
}
