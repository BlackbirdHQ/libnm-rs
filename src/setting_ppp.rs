// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files
// DO NOT EDIT

use crate::Setting;
use glib::object::Cast;
use glib::object::ObjectType as ObjectType_;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib::ToValue;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem::transmute;

glib::wrapper! {
    #[doc(alias = "NMSettingPpp")]
    pub struct SettingPpp(Object<ffi::NMSettingPpp, ffi::NMSettingPppClass>) @extends Setting;

    match fn {
        type_ => || ffi::nm_setting_ppp_get_type(),
    }
}

impl SettingPpp {
    /// Creates a new [`SettingPpp`][crate::SettingPpp] object with default values.
    ///
    /// # Returns
    ///
    /// the new empty [`SettingPpp`][crate::SettingPpp] object
    #[doc(alias = "nm_setting_ppp_new")]
    pub fn new() -> SettingPpp {
        unsafe { Setting::from_glib_full(ffi::nm_setting_ppp_new()).unsafe_cast() }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingPpp::baud` property of the setting
    #[doc(alias = "nm_setting_ppp_get_baud")]
    #[doc(alias = "get_baud")]
    pub fn baud(&self) -> u32 {
        unsafe { ffi::nm_setting_ppp_get_baud(self.to_glib_none().0) }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingPpp::crtscts` property of the setting
    #[doc(alias = "nm_setting_ppp_get_crtscts")]
    #[doc(alias = "get_crtscts")]
    pub fn is_crtscts(&self) -> bool {
        unsafe { from_glib(ffi::nm_setting_ppp_get_crtscts(self.to_glib_none().0)) }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingPpp::lcp-echo-failure` property of the setting
    #[doc(alias = "nm_setting_ppp_get_lcp_echo_failure")]
    #[doc(alias = "get_lcp_echo_failure")]
    pub fn lcp_echo_failure(&self) -> u32 {
        unsafe { ffi::nm_setting_ppp_get_lcp_echo_failure(self.to_glib_none().0) }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingPpp::lcp-echo-interval` property of the setting
    #[doc(alias = "nm_setting_ppp_get_lcp_echo_interval")]
    #[doc(alias = "get_lcp_echo_interval")]
    pub fn lcp_echo_interval(&self) -> u32 {
        unsafe { ffi::nm_setting_ppp_get_lcp_echo_interval(self.to_glib_none().0) }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingPpp::mppe-stateful` property of the setting
    #[doc(alias = "nm_setting_ppp_get_mppe_stateful")]
    #[doc(alias = "get_mppe_stateful")]
    pub fn is_mppe_stateful(&self) -> bool {
        unsafe { from_glib(ffi::nm_setting_ppp_get_mppe_stateful(self.to_glib_none().0)) }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingPpp::mru` property of the setting
    #[doc(alias = "nm_setting_ppp_get_mru")]
    #[doc(alias = "get_mru")]
    pub fn mru(&self) -> u32 {
        unsafe { ffi::nm_setting_ppp_get_mru(self.to_glib_none().0) }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingPpp::mtu` property of the setting
    #[doc(alias = "nm_setting_ppp_get_mtu")]
    #[doc(alias = "get_mtu")]
    pub fn mtu(&self) -> u32 {
        unsafe { ffi::nm_setting_ppp_get_mtu(self.to_glib_none().0) }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingPpp::no-vj-comp` property of the setting
    #[doc(alias = "nm_setting_ppp_get_no_vj_comp")]
    #[doc(alias = "get_no_vj_comp")]
    pub fn is_no_vj_comp(&self) -> bool {
        unsafe { from_glib(ffi::nm_setting_ppp_get_no_vj_comp(self.to_glib_none().0)) }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingPpp::noauth` property of the setting
    #[doc(alias = "nm_setting_ppp_get_noauth")]
    #[doc(alias = "get_noauth")]
    pub fn is_noauth(&self) -> bool {
        unsafe { from_glib(ffi::nm_setting_ppp_get_noauth(self.to_glib_none().0)) }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingPpp::nobsdcomp` property of the setting
    #[doc(alias = "nm_setting_ppp_get_nobsdcomp")]
    #[doc(alias = "get_nobsdcomp")]
    pub fn is_nobsdcomp(&self) -> bool {
        unsafe { from_glib(ffi::nm_setting_ppp_get_nobsdcomp(self.to_glib_none().0)) }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingPpp::nodeflate` property of the setting
    #[doc(alias = "nm_setting_ppp_get_nodeflate")]
    #[doc(alias = "get_nodeflate")]
    pub fn is_nodeflate(&self) -> bool {
        unsafe { from_glib(ffi::nm_setting_ppp_get_nodeflate(self.to_glib_none().0)) }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingPpp::refuse-chap` property of the setting
    #[doc(alias = "nm_setting_ppp_get_refuse_chap")]
    #[doc(alias = "get_refuse_chap")]
    pub fn is_refuse_chap(&self) -> bool {
        unsafe { from_glib(ffi::nm_setting_ppp_get_refuse_chap(self.to_glib_none().0)) }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingPpp::refuse-eap` property of the setting
    #[doc(alias = "nm_setting_ppp_get_refuse_eap")]
    #[doc(alias = "get_refuse_eap")]
    pub fn is_refuse_eap(&self) -> bool {
        unsafe { from_glib(ffi::nm_setting_ppp_get_refuse_eap(self.to_glib_none().0)) }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingPpp::refuse-mschap` property of the setting
    #[doc(alias = "nm_setting_ppp_get_refuse_mschap")]
    #[doc(alias = "get_refuse_mschap")]
    pub fn is_refuse_mschap(&self) -> bool {
        unsafe { from_glib(ffi::nm_setting_ppp_get_refuse_mschap(self.to_glib_none().0)) }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingPpp::refuse-mschapv2` property of the setting
    #[doc(alias = "nm_setting_ppp_get_refuse_mschapv2")]
    #[doc(alias = "get_refuse_mschapv2")]
    pub fn is_refuse_mschapv2(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_refuse_mschapv2(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingPpp::refuse-pap` property of the setting
    #[doc(alias = "nm_setting_ppp_get_refuse_pap")]
    #[doc(alias = "get_refuse_pap")]
    pub fn is_refuse_pap(&self) -> bool {
        unsafe { from_glib(ffi::nm_setting_ppp_get_refuse_pap(self.to_glib_none().0)) }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingPpp::require-mppe` property of the setting
    #[doc(alias = "nm_setting_ppp_get_require_mppe")]
    #[doc(alias = "get_require_mppe")]
    pub fn requires_mppe(&self) -> bool {
        unsafe { from_glib(ffi::nm_setting_ppp_get_require_mppe(self.to_glib_none().0)) }
    }

    ///
    /// # Returns
    ///
    /// the `property::SettingPpp::require-mppe-128` property of the setting
    #[doc(alias = "nm_setting_ppp_get_require_mppe_128")]
    #[doc(alias = "get_require_mppe_128")]
    pub fn requires_mppe_128(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_require_mppe_128(
                self.to_glib_none().0,
            ))
        }
    }

    /// If non-zero, instruct pppd to set the serial port to the specified
    /// baudrate. This value should normally be left as 0 to automatically
    /// choose the speed.
    pub fn set_baud(&self, baud: u32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(
                self.as_ptr() as *mut glib::gobject_ffi::GObject,
                b"baud\0".as_ptr() as *const _,
                baud.to_value().to_glib_none().0,
            );
        }
    }

    /// If [`true`], specify that pppd should set the serial port to use hardware
    /// flow control with RTS and CTS signals. This value should normally be set
    /// to [`false`].
    pub fn set_crtscts(&self, crtscts: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(
                self.as_ptr() as *mut glib::gobject_ffi::GObject,
                b"crtscts\0".as_ptr() as *const _,
                crtscts.to_value().to_glib_none().0,
            );
        }
    }

    /// If non-zero, instruct pppd to presume the connection to the peer has
    /// failed if the specified number of LCP echo-requests go unanswered by the
    /// peer. The "lcp-echo-interval" property must also be set to a non-zero
    /// value if this property is used.
    #[doc(alias = "lcp-echo-failure")]
    pub fn set_lcp_echo_failure(&self, lcp_echo_failure: u32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(
                self.as_ptr() as *mut glib::gobject_ffi::GObject,
                b"lcp-echo-failure\0".as_ptr() as *const _,
                lcp_echo_failure.to_value().to_glib_none().0,
            );
        }
    }

    /// If non-zero, instruct pppd to send an LCP echo-request frame to the peer
    /// every n seconds (where n is the specified value). Note that some PPP
    /// peers will respond to echo requests and some will not, and it is not
    /// possible to autodetect this.
    #[doc(alias = "lcp-echo-interval")]
    pub fn set_lcp_echo_interval(&self, lcp_echo_interval: u32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(
                self.as_ptr() as *mut glib::gobject_ffi::GObject,
                b"lcp-echo-interval\0".as_ptr() as *const _,
                lcp_echo_interval.to_value().to_glib_none().0,
            );
        }
    }

    /// If [`true`], stateful MPPE is used. See pppd documentation for more
    /// information on stateful MPPE.
    #[doc(alias = "mppe-stateful")]
    pub fn set_mppe_stateful(&self, mppe_stateful: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(
                self.as_ptr() as *mut glib::gobject_ffi::GObject,
                b"mppe-stateful\0".as_ptr() as *const _,
                mppe_stateful.to_value().to_glib_none().0,
            );
        }
    }

    /// If non-zero, instruct pppd to request that the peer send packets no
    /// larger than the specified size. If non-zero, the MRU should be between
    /// 128 and 16384.
    pub fn set_mru(&self, mru: u32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(
                self.as_ptr() as *mut glib::gobject_ffi::GObject,
                b"mru\0".as_ptr() as *const _,
                mru.to_value().to_glib_none().0,
            );
        }
    }

    /// If non-zero, instruct pppd to send packets no larger than the specified
    /// size.
    pub fn set_mtu(&self, mtu: u32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(
                self.as_ptr() as *mut glib::gobject_ffi::GObject,
                b"mtu\0".as_ptr() as *const _,
                mtu.to_value().to_glib_none().0,
            );
        }
    }

    /// If [`true`], Van Jacobsen TCP header compression will not be requested.
    #[doc(alias = "no-vj-comp")]
    pub fn set_no_vj_comp(&self, no_vj_comp: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(
                self.as_ptr() as *mut glib::gobject_ffi::GObject,
                b"no-vj-comp\0".as_ptr() as *const _,
                no_vj_comp.to_value().to_glib_none().0,
            );
        }
    }

    /// If [`true`], do not require the other side (usually the PPP server) to
    /// authenticate itself to the client. If [`false`], require authentication
    /// from the remote side. In almost all cases, this should be [`true`].
    pub fn set_noauth(&self, noauth: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(
                self.as_ptr() as *mut glib::gobject_ffi::GObject,
                b"noauth\0".as_ptr() as *const _,
                noauth.to_value().to_glib_none().0,
            );
        }
    }

    /// If [`true`], BSD compression will not be requested.
    pub fn set_nobsdcomp(&self, nobsdcomp: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(
                self.as_ptr() as *mut glib::gobject_ffi::GObject,
                b"nobsdcomp\0".as_ptr() as *const _,
                nobsdcomp.to_value().to_glib_none().0,
            );
        }
    }

    /// If [`true`], "deflate" compression will not be requested.
    pub fn set_nodeflate(&self, nodeflate: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(
                self.as_ptr() as *mut glib::gobject_ffi::GObject,
                b"nodeflate\0".as_ptr() as *const _,
                nodeflate.to_value().to_glib_none().0,
            );
        }
    }

    /// If [`true`], the CHAP authentication method will not be used.
    #[doc(alias = "refuse-chap")]
    pub fn set_refuse_chap(&self, refuse_chap: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(
                self.as_ptr() as *mut glib::gobject_ffi::GObject,
                b"refuse-chap\0".as_ptr() as *const _,
                refuse_chap.to_value().to_glib_none().0,
            );
        }
    }

    /// If [`true`], the EAP authentication method will not be used.
    #[doc(alias = "refuse-eap")]
    pub fn set_refuse_eap(&self, refuse_eap: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(
                self.as_ptr() as *mut glib::gobject_ffi::GObject,
                b"refuse-eap\0".as_ptr() as *const _,
                refuse_eap.to_value().to_glib_none().0,
            );
        }
    }

    /// If [`true`], the MSCHAP authentication method will not be used.
    #[doc(alias = "refuse-mschap")]
    pub fn set_refuse_mschap(&self, refuse_mschap: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(
                self.as_ptr() as *mut glib::gobject_ffi::GObject,
                b"refuse-mschap\0".as_ptr() as *const _,
                refuse_mschap.to_value().to_glib_none().0,
            );
        }
    }

    /// If [`true`], the MSCHAPv2 authentication method will not be used.
    #[doc(alias = "refuse-mschapv2")]
    pub fn set_refuse_mschapv2(&self, refuse_mschapv2: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(
                self.as_ptr() as *mut glib::gobject_ffi::GObject,
                b"refuse-mschapv2\0".as_ptr() as *const _,
                refuse_mschapv2.to_value().to_glib_none().0,
            );
        }
    }

    /// If [`true`], the PAP authentication method will not be used.
    #[doc(alias = "refuse-pap")]
    pub fn set_refuse_pap(&self, refuse_pap: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(
                self.as_ptr() as *mut glib::gobject_ffi::GObject,
                b"refuse-pap\0".as_ptr() as *const _,
                refuse_pap.to_value().to_glib_none().0,
            );
        }
    }

    /// If [`true`], MPPE (Microsoft Point-to-Point Encryption) will be required for
    /// the PPP session. If either 64-bit or 128-bit MPPE is not available the
    /// session will fail. Note that MPPE is not used on mobile broadband
    /// connections.
    #[doc(alias = "require-mppe")]
    pub fn set_require_mppe(&self, require_mppe: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(
                self.as_ptr() as *mut glib::gobject_ffi::GObject,
                b"require-mppe\0".as_ptr() as *const _,
                require_mppe.to_value().to_glib_none().0,
            );
        }
    }

    /// If [`true`], 128-bit MPPE (Microsoft Point-to-Point Encryption) will be
    /// required for the PPP session, and the "require-mppe" property must also
    /// be set to [`true`]. If 128-bit MPPE is not available the session will fail.
    #[doc(alias = "require-mppe-128")]
    pub fn set_require_mppe_128(&self, require_mppe_128: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(
                self.as_ptr() as *mut glib::gobject_ffi::GObject,
                b"require-mppe-128\0".as_ptr() as *const _,
                require_mppe_128.to_value().to_glib_none().0,
            );
        }
    }

    #[doc(alias = "baud")]
    pub fn connect_baud_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_baud_trampoline<F: Fn(&SettingPpp) + 'static>(
            this: *mut ffi::NMSettingPpp,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::baud\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_baud_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "crtscts")]
    pub fn connect_crtscts_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_crtscts_trampoline<F: Fn(&SettingPpp) + 'static>(
            this: *mut ffi::NMSettingPpp,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::crtscts\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_crtscts_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "lcp-echo-failure")]
    pub fn connect_lcp_echo_failure_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_lcp_echo_failure_trampoline<F: Fn(&SettingPpp) + 'static>(
            this: *mut ffi::NMSettingPpp,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::lcp-echo-failure\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_lcp_echo_failure_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "lcp-echo-interval")]
    pub fn connect_lcp_echo_interval_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_lcp_echo_interval_trampoline<F: Fn(&SettingPpp) + 'static>(
            this: *mut ffi::NMSettingPpp,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::lcp-echo-interval\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_lcp_echo_interval_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "mppe-stateful")]
    pub fn connect_mppe_stateful_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mppe_stateful_trampoline<F: Fn(&SettingPpp) + 'static>(
            this: *mut ffi::NMSettingPpp,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::mppe-stateful\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_mppe_stateful_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "mru")]
    pub fn connect_mru_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mru_trampoline<F: Fn(&SettingPpp) + 'static>(
            this: *mut ffi::NMSettingPpp,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::mru\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_mru_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "mtu")]
    pub fn connect_mtu_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mtu_trampoline<F: Fn(&SettingPpp) + 'static>(
            this: *mut ffi::NMSettingPpp,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::mtu\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_mtu_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "no-vj-comp")]
    pub fn connect_no_vj_comp_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_no_vj_comp_trampoline<F: Fn(&SettingPpp) + 'static>(
            this: *mut ffi::NMSettingPpp,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::no-vj-comp\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_no_vj_comp_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "noauth")]
    pub fn connect_noauth_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_noauth_trampoline<F: Fn(&SettingPpp) + 'static>(
            this: *mut ffi::NMSettingPpp,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::noauth\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_noauth_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "nobsdcomp")]
    pub fn connect_nobsdcomp_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_nobsdcomp_trampoline<F: Fn(&SettingPpp) + 'static>(
            this: *mut ffi::NMSettingPpp,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::nobsdcomp\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_nobsdcomp_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "nodeflate")]
    pub fn connect_nodeflate_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_nodeflate_trampoline<F: Fn(&SettingPpp) + 'static>(
            this: *mut ffi::NMSettingPpp,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::nodeflate\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_nodeflate_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "refuse-chap")]
    pub fn connect_refuse_chap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_chap_trampoline<F: Fn(&SettingPpp) + 'static>(
            this: *mut ffi::NMSettingPpp,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::refuse-chap\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_refuse_chap_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "refuse-eap")]
    pub fn connect_refuse_eap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_eap_trampoline<F: Fn(&SettingPpp) + 'static>(
            this: *mut ffi::NMSettingPpp,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::refuse-eap\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_refuse_eap_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "refuse-mschap")]
    pub fn connect_refuse_mschap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_mschap_trampoline<F: Fn(&SettingPpp) + 'static>(
            this: *mut ffi::NMSettingPpp,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::refuse-mschap\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_refuse_mschap_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "refuse-mschapv2")]
    pub fn connect_refuse_mschapv2_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_mschapv2_trampoline<F: Fn(&SettingPpp) + 'static>(
            this: *mut ffi::NMSettingPpp,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::refuse-mschapv2\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_refuse_mschapv2_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "refuse-pap")]
    pub fn connect_refuse_pap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_pap_trampoline<F: Fn(&SettingPpp) + 'static>(
            this: *mut ffi::NMSettingPpp,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::refuse-pap\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_refuse_pap_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "require-mppe")]
    pub fn connect_require_mppe_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_require_mppe_trampoline<F: Fn(&SettingPpp) + 'static>(
            this: *mut ffi::NMSettingPpp,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::require-mppe\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_require_mppe_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "require-mppe-128")]
    pub fn connect_require_mppe_128_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_require_mppe_128_trampoline<F: Fn(&SettingPpp) + 'static>(
            this: *mut ffi::NMSettingPpp,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::require-mppe-128\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_require_mppe_128_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl Default for SettingPpp {
    fn default() -> Self {
        Self::new()
    }
}

impl fmt::Display for SettingPpp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("SettingPpp")
    }
}
