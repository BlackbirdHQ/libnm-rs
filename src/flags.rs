// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files
// DO NOT EDIT

use bitflags::bitflags;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::ToValue;
use glib::StaticType;
use glib::Type;
use std::fmt;

#[cfg(any(feature = "v1_10", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "NMActivationStateFlags")]
    pub struct ActivationStateFlags: u32 {
        #[doc(alias = "NM_ACTIVATION_STATE_FLAG_NONE")]
        const NONE = ffi::NM_ACTIVATION_STATE_FLAG_NONE as u32;
        #[doc(alias = "NM_ACTIVATION_STATE_FLAG_IS_MASTER")]
        const IS_MASTER = ffi::NM_ACTIVATION_STATE_FLAG_IS_MASTER as u32;
        #[doc(alias = "NM_ACTIVATION_STATE_FLAG_IS_SLAVE")]
        const IS_SLAVE = ffi::NM_ACTIVATION_STATE_FLAG_IS_SLAVE as u32;
        #[doc(alias = "NM_ACTIVATION_STATE_FLAG_LAYER2_READY")]
        const LAYER2_READY = ffi::NM_ACTIVATION_STATE_FLAG_LAYER2_READY as u32;
        #[doc(alias = "NM_ACTIVATION_STATE_FLAG_IP4_READY")]
        const IP4_READY = ffi::NM_ACTIVATION_STATE_FLAG_IP4_READY as u32;
        #[doc(alias = "NM_ACTIVATION_STATE_FLAG_IP6_READY")]
        const IP6_READY = ffi::NM_ACTIVATION_STATE_FLAG_IP6_READY as u32;
        #[doc(alias = "NM_ACTIVATION_STATE_FLAG_MASTER_HAS_SLAVES")]
        const MASTER_HAS_SLAVES = ffi::NM_ACTIVATION_STATE_FLAG_MASTER_HAS_SLAVES as u32;
        #[doc(alias = "NM_ACTIVATION_STATE_FLAG_LIFETIME_BOUND_TO_PROFILE_VISIBILITY")]
        const LIFETIME_BOUND_TO_PROFILE_VISIBILITY = ffi::NM_ACTIVATION_STATE_FLAG_LIFETIME_BOUND_TO_PROFILE_VISIBILITY as u32;
        #[doc(alias = "NM_ACTIVATION_STATE_FLAG_EXTERNAL")]
        const EXTERNAL = ffi::NM_ACTIVATION_STATE_FLAG_EXTERNAL as u32;
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
impl fmt::Display for ActivationStateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
#[doc(hidden)]
impl IntoGlib for ActivationStateFlags {
    type GlibType = ffi::NMActivationStateFlags;

    fn into_glib(self) -> ffi::NMActivationStateFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
#[doc(hidden)]
impl FromGlib<ffi::NMActivationStateFlags> for ActivationStateFlags {
    unsafe fn from_glib(value: ffi::NMActivationStateFlags) -> Self {
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
impl StaticType for ActivationStateFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_activation_state_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
impl glib::value::ValueType for ActivationStateFlags {
    type Type = Self;
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
unsafe impl<'a> FromValue<'a> for ActivationStateFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
impl ToValue for ActivationStateFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "NMBluetoothCapabilities")]
    pub struct BluetoothCapabilities: u32 {
        #[doc(alias = "NM_BT_CAPABILITY_NONE")]
        const NONE = ffi::NM_BT_CAPABILITY_NONE as u32;
        #[doc(alias = "NM_BT_CAPABILITY_DUN")]
        const DUN = ffi::NM_BT_CAPABILITY_DUN as u32;
        #[doc(alias = "NM_BT_CAPABILITY_NAP")]
        const NAP = ffi::NM_BT_CAPABILITY_NAP as u32;
    }
}

impl fmt::Display for BluetoothCapabilities {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for BluetoothCapabilities {
    type GlibType = ffi::NMBluetoothCapabilities;

    fn into_glib(self) -> ffi::NMBluetoothCapabilities {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMBluetoothCapabilities> for BluetoothCapabilities {
    unsafe fn from_glib(value: ffi::NMBluetoothCapabilities) -> Self {
        Self::from_bits_truncate(value)
    }
}

impl StaticType for BluetoothCapabilities {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_bluetooth_capabilities_get_type()) }
    }
}

impl glib::value::ValueType for BluetoothCapabilities {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for BluetoothCapabilities {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for BluetoothCapabilities {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v1_4", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
    #[doc(alias = "NMCheckpointCreateFlags")]
    pub struct CheckpointCreateFlags: u32 {
        #[doc(alias = "NM_CHECKPOINT_CREATE_FLAG_NONE")]
        const NONE = ffi::NM_CHECKPOINT_CREATE_FLAG_NONE as u32;
        #[doc(alias = "NM_CHECKPOINT_CREATE_FLAG_DESTROY_ALL")]
        const DESTROY_ALL = ffi::NM_CHECKPOINT_CREATE_FLAG_DESTROY_ALL as u32;
        #[doc(alias = "NM_CHECKPOINT_CREATE_FLAG_DELETE_NEW_CONNECTIONS")]
        const DELETE_NEW_CONNECTIONS = ffi::NM_CHECKPOINT_CREATE_FLAG_DELETE_NEW_CONNECTIONS as u32;
        #[doc(alias = "NM_CHECKPOINT_CREATE_FLAG_DISCONNECT_NEW_DEVICES")]
        const DISCONNECT_NEW_DEVICES = ffi::NM_CHECKPOINT_CREATE_FLAG_DISCONNECT_NEW_DEVICES as u32;
        #[doc(alias = "NM_CHECKPOINT_CREATE_FLAG_ALLOW_OVERLAPPING")]
        const ALLOW_OVERLAPPING = ffi::NM_CHECKPOINT_CREATE_FLAG_ALLOW_OVERLAPPING as u32;
        #[doc(alias = "NM_CHECKPOINT_CREATE_FLAG_NO_PRESERVE_EXTERNAL_PORTS")]
        const NO_PRESERVE_EXTERNAL_PORTS = ffi::NM_CHECKPOINT_CREATE_FLAG_NO_PRESERVE_EXTERNAL_PORTS as u32;
    }
}

#[cfg(any(feature = "v1_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
impl fmt::Display for CheckpointCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[cfg(any(feature = "v1_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
#[doc(hidden)]
impl IntoGlib for CheckpointCreateFlags {
    type GlibType = ffi::NMCheckpointCreateFlags;

    fn into_glib(self) -> ffi::NMCheckpointCreateFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
#[doc(hidden)]
impl FromGlib<ffi::NMCheckpointCreateFlags> for CheckpointCreateFlags {
    unsafe fn from_glib(value: ffi::NMCheckpointCreateFlags) -> Self {
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
impl StaticType for CheckpointCreateFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_checkpoint_create_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
impl glib::value::ValueType for CheckpointCreateFlags {
    type Type = Self;
}

#[cfg(any(feature = "v1_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
unsafe impl<'a> FromValue<'a> for CheckpointCreateFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
impl ToValue for CheckpointCreateFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v1_24", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_24")))]
    #[doc(alias = "NMClientInstanceFlags")]
    pub struct ClientInstanceFlags: u32 {
        #[doc(alias = "NM_CLIENT_INSTANCE_FLAGS_NONE")]
        const NONE = ffi::NM_CLIENT_INSTANCE_FLAGS_NONE as u32;
        #[doc(alias = "NM_CLIENT_INSTANCE_FLAGS_NO_AUTO_FETCH_PERMISSIONS")]
        const NO_AUTO_FETCH_PERMISSIONS = ffi::NM_CLIENT_INSTANCE_FLAGS_NO_AUTO_FETCH_PERMISSIONS as u32;
    }
}

#[cfg(any(feature = "v1_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_24")))]
impl fmt::Display for ClientInstanceFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[cfg(any(feature = "v1_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_24")))]
#[doc(hidden)]
impl IntoGlib for ClientInstanceFlags {
    type GlibType = ffi::NMClientInstanceFlags;

    fn into_glib(self) -> ffi::NMClientInstanceFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_24")))]
#[doc(hidden)]
impl FromGlib<ffi::NMClientInstanceFlags> for ClientInstanceFlags {
    unsafe fn from_glib(value: ffi::NMClientInstanceFlags) -> Self {
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_24")))]
impl StaticType for ClientInstanceFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_client_instance_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_24")))]
impl glib::value::ValueType for ClientInstanceFlags {
    type Type = Self;
}

#[cfg(any(feature = "v1_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_24")))]
unsafe impl<'a> FromValue<'a> for ClientInstanceFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_24")))]
impl ToValue for ClientInstanceFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "NMConnectionSerializationFlags")]
    pub struct ConnectionSerializationFlags: u32 {
        #[doc(alias = "NM_CONNECTION_SERIALIZE_ALL")]
        const ALL = ffi::NM_CONNECTION_SERIALIZE_ALL as u32;
        #[doc(alias = "NM_CONNECTION_SERIALIZE_WITH_NON_SECRET")]
        const WITH_NON_SECRET = ffi::NM_CONNECTION_SERIALIZE_WITH_NON_SECRET as u32;
        #[doc(alias = "NM_CONNECTION_SERIALIZE_NO_SECRETS")]
        const NO_SECRETS = ffi::NM_CONNECTION_SERIALIZE_NO_SECRETS as u32;
        #[doc(alias = "NM_CONNECTION_SERIALIZE_WITH_SECRETS")]
        const WITH_SECRETS = ffi::NM_CONNECTION_SERIALIZE_WITH_SECRETS as u32;
        #[doc(alias = "NM_CONNECTION_SERIALIZE_ONLY_SECRETS")]
        const ONLY_SECRETS = ffi::NM_CONNECTION_SERIALIZE_ONLY_SECRETS as u32;
        #[doc(alias = "NM_CONNECTION_SERIALIZE_WITH_SECRETS_AGENT_OWNED")]
        const WITH_SECRETS_AGENT_OWNED = ffi::NM_CONNECTION_SERIALIZE_WITH_SECRETS_AGENT_OWNED as u32;
        #[doc(alias = "NM_CONNECTION_SERIALIZE_WITH_SECRETS_SYSTEM_OWNED")]
        const WITH_SECRETS_SYSTEM_OWNED = ffi::NM_CONNECTION_SERIALIZE_WITH_SECRETS_SYSTEM_OWNED as u32;
        #[doc(alias = "NM_CONNECTION_SERIALIZE_WITH_SECRETS_NOT_SAVED")]
        const WITH_SECRETS_NOT_SAVED = ffi::NM_CONNECTION_SERIALIZE_WITH_SECRETS_NOT_SAVED as u32;
    }
}

impl fmt::Display for ConnectionSerializationFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for ConnectionSerializationFlags {
    type GlibType = ffi::NMConnectionSerializationFlags;

    fn into_glib(self) -> ffi::NMConnectionSerializationFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMConnectionSerializationFlags> for ConnectionSerializationFlags {
    unsafe fn from_glib(value: ffi::NMConnectionSerializationFlags) -> Self {
        Self::from_bits_truncate(value)
    }
}

impl StaticType for ConnectionSerializationFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_connection_serialization_flags_get_type()) }
    }
}

impl glib::value::ValueType for ConnectionSerializationFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ConnectionSerializationFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for ConnectionSerializationFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "NMDeviceCapabilities")]
    pub struct DeviceCapabilities: u32 {
        #[doc(alias = "NM_DEVICE_CAP_NONE")]
        const NONE = ffi::NM_DEVICE_CAP_NONE as u32;
        #[doc(alias = "NM_DEVICE_CAP_NM_SUPPORTED")]
        const NM_SUPPORTED = ffi::NM_DEVICE_CAP_NM_SUPPORTED as u32;
        #[doc(alias = "NM_DEVICE_CAP_CARRIER_DETECT")]
        const CARRIER_DETECT = ffi::NM_DEVICE_CAP_CARRIER_DETECT as u32;
        #[doc(alias = "NM_DEVICE_CAP_IS_SOFTWARE")]
        const IS_SOFTWARE = ffi::NM_DEVICE_CAP_IS_SOFTWARE as u32;
        #[doc(alias = "NM_DEVICE_CAP_SRIOV")]
        const SRIOV = ffi::NM_DEVICE_CAP_SRIOV as u32;
    }
}

impl fmt::Display for DeviceCapabilities {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for DeviceCapabilities {
    type GlibType = ffi::NMDeviceCapabilities;

    fn into_glib(self) -> ffi::NMDeviceCapabilities {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMDeviceCapabilities> for DeviceCapabilities {
    unsafe fn from_glib(value: ffi::NMDeviceCapabilities) -> Self {
        Self::from_bits_truncate(value)
    }
}

impl StaticType for DeviceCapabilities {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_device_capabilities_get_type()) }
    }
}

impl glib::value::ValueType for DeviceCapabilities {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for DeviceCapabilities {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for DeviceCapabilities {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
    #[doc(alias = "NMDeviceInterfaceFlags")]
    pub struct DeviceInterfaceFlags: u32 {
        #[doc(alias = "NM_DEVICE_INTERFACE_FLAG_UP")]
        const UP = ffi::NM_DEVICE_INTERFACE_FLAG_UP as u32;
        #[doc(alias = "NM_DEVICE_INTERFACE_FLAG_LOWER_UP")]
        const LOWER_UP = ffi::NM_DEVICE_INTERFACE_FLAG_LOWER_UP as u32;
        #[doc(alias = "NM_DEVICE_INTERFACE_FLAG_PROMISC")]
        const PROMISC = ffi::NM_DEVICE_INTERFACE_FLAG_PROMISC as u32;
        #[doc(alias = "NM_DEVICE_INTERFACE_FLAG_CARRIER")]
        const CARRIER = ffi::NM_DEVICE_INTERFACE_FLAG_CARRIER as u32;
        #[doc(alias = "NM_DEVICE_INTERFACE_FLAG_LLDP_CLIENT_ENABLED")]
        const LLDP_CLIENT_ENABLED = ffi::NM_DEVICE_INTERFACE_FLAG_LLDP_CLIENT_ENABLED as u32;
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
impl fmt::Display for DeviceInterfaceFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
#[doc(hidden)]
impl IntoGlib for DeviceInterfaceFlags {
    type GlibType = ffi::NMDeviceInterfaceFlags;

    fn into_glib(self) -> ffi::NMDeviceInterfaceFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
#[doc(hidden)]
impl FromGlib<ffi::NMDeviceInterfaceFlags> for DeviceInterfaceFlags {
    unsafe fn from_glib(value: ffi::NMDeviceInterfaceFlags) -> Self {
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
impl StaticType for DeviceInterfaceFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_device_interface_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
impl glib::value::ValueType for DeviceInterfaceFlags {
    type Type = Self;
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
unsafe impl<'a> FromValue<'a> for DeviceInterfaceFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
impl ToValue for DeviceInterfaceFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "NMDeviceModemCapabilities")]
    pub struct DeviceModemCapabilities: u32 {
        #[doc(alias = "NM_DEVICE_MODEM_CAPABILITY_NONE")]
        const NONE = ffi::NM_DEVICE_MODEM_CAPABILITY_NONE as u32;
        #[doc(alias = "NM_DEVICE_MODEM_CAPABILITY_POTS")]
        const POTS = ffi::NM_DEVICE_MODEM_CAPABILITY_POTS as u32;
        #[doc(alias = "NM_DEVICE_MODEM_CAPABILITY_CDMA_EVDO")]
        const CDMA_EVDO = ffi::NM_DEVICE_MODEM_CAPABILITY_CDMA_EVDO as u32;
        #[doc(alias = "NM_DEVICE_MODEM_CAPABILITY_GSM_UMTS")]
        const GSM_UMTS = ffi::NM_DEVICE_MODEM_CAPABILITY_GSM_UMTS as u32;
        #[doc(alias = "NM_DEVICE_MODEM_CAPABILITY_LTE")]
        const LTE = ffi::NM_DEVICE_MODEM_CAPABILITY_LTE as u32;
        #[doc(alias = "NM_DEVICE_MODEM_CAPABILITY_5GNR")]
        const __5GNR = ffi::NM_DEVICE_MODEM_CAPABILITY_5GNR as u32;
    }
}

impl fmt::Display for DeviceModemCapabilities {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for DeviceModemCapabilities {
    type GlibType = ffi::NMDeviceModemCapabilities;

    fn into_glib(self) -> ffi::NMDeviceModemCapabilities {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMDeviceModemCapabilities> for DeviceModemCapabilities {
    unsafe fn from_glib(value: ffi::NMDeviceModemCapabilities) -> Self {
        Self::from_bits_truncate(value)
    }
}

impl StaticType for DeviceModemCapabilities {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_device_modem_capabilities_get_type()) }
    }
}

impl glib::value::ValueType for DeviceModemCapabilities {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for DeviceModemCapabilities {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for DeviceModemCapabilities {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "NMDeviceWifiCapabilities")]
    pub struct DeviceWifiCapabilities: u32 {
        #[doc(alias = "NM_WIFI_DEVICE_CAP_NONE")]
        const NONE = ffi::NM_WIFI_DEVICE_CAP_NONE as u32;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_CIPHER_WEP40")]
        const CIPHER_WEP40 = ffi::NM_WIFI_DEVICE_CAP_CIPHER_WEP40 as u32;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_CIPHER_WEP104")]
        const CIPHER_WEP104 = ffi::NM_WIFI_DEVICE_CAP_CIPHER_WEP104 as u32;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_CIPHER_TKIP")]
        const CIPHER_TKIP = ffi::NM_WIFI_DEVICE_CAP_CIPHER_TKIP as u32;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_CIPHER_CCMP")]
        const CIPHER_CCMP = ffi::NM_WIFI_DEVICE_CAP_CIPHER_CCMP as u32;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_WPA")]
        const WPA = ffi::NM_WIFI_DEVICE_CAP_WPA as u32;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_RSN")]
        const RSN = ffi::NM_WIFI_DEVICE_CAP_RSN as u32;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_AP")]
        const AP = ffi::NM_WIFI_DEVICE_CAP_AP as u32;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_ADHOC")]
        const ADHOC = ffi::NM_WIFI_DEVICE_CAP_ADHOC as u32;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_FREQ_VALID")]
        const FREQ_VALID = ffi::NM_WIFI_DEVICE_CAP_FREQ_VALID as u32;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_FREQ_2GHZ")]
        const FREQ_2GHZ = ffi::NM_WIFI_DEVICE_CAP_FREQ_2GHZ as u32;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_FREQ_5GHZ")]
        const FREQ_5GHZ = ffi::NM_WIFI_DEVICE_CAP_FREQ_5GHZ as u32;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_MESH")]
        const MESH = ffi::NM_WIFI_DEVICE_CAP_MESH as u32;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_IBSS_RSN")]
        const IBSS_RSN = ffi::NM_WIFI_DEVICE_CAP_IBSS_RSN as u32;
    }
}

impl fmt::Display for DeviceWifiCapabilities {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for DeviceWifiCapabilities {
    type GlibType = ffi::NMDeviceWifiCapabilities;

    fn into_glib(self) -> ffi::NMDeviceWifiCapabilities {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMDeviceWifiCapabilities> for DeviceWifiCapabilities {
    unsafe fn from_glib(value: ffi::NMDeviceWifiCapabilities) -> Self {
        Self::from_bits_truncate(value)
    }
}

impl StaticType for DeviceWifiCapabilities {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_device_wifi_capabilities_get_type()) }
    }
}

impl glib::value::ValueType for DeviceWifiCapabilities {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for DeviceWifiCapabilities {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for DeviceWifiCapabilities {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
    #[doc(alias = "NMDhcpHostnameFlags")]
    pub struct DhcpHostnameFlags: u32 {
        #[doc(alias = "NM_DHCP_HOSTNAME_FLAG_NONE")]
        const NONE = ffi::NM_DHCP_HOSTNAME_FLAG_NONE as u32;
        #[doc(alias = "NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE")]
        const FQDN_SERV_UPDATE = ffi::NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE as u32;
        #[doc(alias = "NM_DHCP_HOSTNAME_FLAG_FQDN_ENCODED")]
        const FQDN_ENCODED = ffi::NM_DHCP_HOSTNAME_FLAG_FQDN_ENCODED as u32;
        #[doc(alias = "NM_DHCP_HOSTNAME_FLAG_FQDN_NO_UPDATE")]
        const FQDN_NO_UPDATE = ffi::NM_DHCP_HOSTNAME_FLAG_FQDN_NO_UPDATE as u32;
        #[doc(alias = "NM_DHCP_HOSTNAME_FLAG_FQDN_CLEAR_FLAGS")]
        const FQDN_CLEAR_FLAGS = ffi::NM_DHCP_HOSTNAME_FLAG_FQDN_CLEAR_FLAGS as u32;
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
impl fmt::Display for DhcpHostnameFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
#[doc(hidden)]
impl IntoGlib for DhcpHostnameFlags {
    type GlibType = ffi::NMDhcpHostnameFlags;

    fn into_glib(self) -> ffi::NMDhcpHostnameFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
#[doc(hidden)]
impl FromGlib<ffi::NMDhcpHostnameFlags> for DhcpHostnameFlags {
    unsafe fn from_glib(value: ffi::NMDhcpHostnameFlags) -> Self {
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
impl StaticType for DhcpHostnameFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_dhcp_hostname_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
impl glib::value::ValueType for DhcpHostnameFlags {
    type Type = Self;
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
unsafe impl<'a> FromValue<'a> for DhcpHostnameFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
impl ToValue for DhcpHostnameFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
    #[doc(alias = "NMIPAddressCmpFlags")]
    pub struct IPAddressCmpFlags: u32 {
        #[doc(alias = "NM_IP_ADDRESS_CMP_FLAGS_NONE")]
        const NONE = ffi::NM_IP_ADDRESS_CMP_FLAGS_NONE as u32;
        #[doc(alias = "NM_IP_ADDRESS_CMP_FLAGS_WITH_ATTRS")]
        const WITH_ATTRS = ffi::NM_IP_ADDRESS_CMP_FLAGS_WITH_ATTRS as u32;
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
impl fmt::Display for IPAddressCmpFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
#[doc(hidden)]
impl IntoGlib for IPAddressCmpFlags {
    type GlibType = ffi::NMIPAddressCmpFlags;

    fn into_glib(self) -> ffi::NMIPAddressCmpFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
#[doc(hidden)]
impl FromGlib<ffi::NMIPAddressCmpFlags> for IPAddressCmpFlags {
    unsafe fn from_glib(value: ffi::NMIPAddressCmpFlags) -> Self {
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
impl StaticType for IPAddressCmpFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_ip_address_cmp_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
impl glib::value::ValueType for IPAddressCmpFlags {
    type Type = Self;
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
unsafe impl<'a> FromValue<'a> for IPAddressCmpFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
impl ToValue for IPAddressCmpFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v1_18", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    #[doc(alias = "NMIPRoutingRuleAsStringFlags")]
    pub struct IPRoutingRuleAsStringFlags: u32 {
        #[doc(alias = "NM_IP_ROUTING_RULE_AS_STRING_FLAGS_NONE")]
        const NONE = ffi::NM_IP_ROUTING_RULE_AS_STRING_FLAGS_NONE as u32;
        #[doc(alias = "NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET")]
        const AF_INET = ffi::NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET as u32;
        #[doc(alias = "NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET6")]
        const AF_INET6 = ffi::NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET6 as u32;
        #[doc(alias = "NM_IP_ROUTING_RULE_AS_STRING_FLAGS_VALIDATE")]
        const VALIDATE = ffi::NM_IP_ROUTING_RULE_AS_STRING_FLAGS_VALIDATE as u32;
    }
}

#[cfg(any(feature = "v1_18", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
impl fmt::Display for IPRoutingRuleAsStringFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[cfg(any(feature = "v1_18", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
#[doc(hidden)]
impl IntoGlib for IPRoutingRuleAsStringFlags {
    type GlibType = ffi::NMIPRoutingRuleAsStringFlags;

    fn into_glib(self) -> ffi::NMIPRoutingRuleAsStringFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_18", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
#[doc(hidden)]
impl FromGlib<ffi::NMIPRoutingRuleAsStringFlags> for IPRoutingRuleAsStringFlags {
    unsafe fn from_glib(value: ffi::NMIPRoutingRuleAsStringFlags) -> Self {
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_18", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
impl StaticType for IPRoutingRuleAsStringFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_ip_routing_rule_as_string_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_18", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
impl glib::value::ValueType for IPRoutingRuleAsStringFlags {
    type Type = Self;
}

#[cfg(any(feature = "v1_18", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
unsafe impl<'a> FromValue<'a> for IPRoutingRuleAsStringFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_18", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
impl ToValue for IPRoutingRuleAsStringFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "NMIPTunnelFlags")]
    pub struct IPTunnelFlags: u32 {
        #[doc(alias = "NM_IP_TUNNEL_FLAG_NONE")]
        const NONE = ffi::NM_IP_TUNNEL_FLAG_NONE as u32;
        #[doc(alias = "NM_IP_TUNNEL_FLAG_IP6_IGN_ENCAP_LIMIT")]
        const IP6_IGN_ENCAP_LIMIT = ffi::NM_IP_TUNNEL_FLAG_IP6_IGN_ENCAP_LIMIT as u32;
        #[doc(alias = "NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_TCLASS")]
        const IP6_USE_ORIG_TCLASS = ffi::NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_TCLASS as u32;
        #[doc(alias = "NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_FLOWLABEL")]
        const IP6_USE_ORIG_FLOWLABEL = ffi::NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_FLOWLABEL as u32;
        #[doc(alias = "NM_IP_TUNNEL_FLAG_IP6_MIP6_DEV")]
        const IP6_MIP6_DEV = ffi::NM_IP_TUNNEL_FLAG_IP6_MIP6_DEV as u32;
        #[doc(alias = "NM_IP_TUNNEL_FLAG_IP6_RCV_DSCP_COPY")]
        const IP6_RCV_DSCP_COPY = ffi::NM_IP_TUNNEL_FLAG_IP6_RCV_DSCP_COPY as u32;
        #[doc(alias = "NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_FWMARK")]
        const IP6_USE_ORIG_FWMARK = ffi::NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_FWMARK as u32;
    }
}

impl fmt::Display for IPTunnelFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for IPTunnelFlags {
    type GlibType = ffi::NMIPTunnelFlags;

    fn into_glib(self) -> ffi::NMIPTunnelFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMIPTunnelFlags> for IPTunnelFlags {
    unsafe fn from_glib(value: ffi::NMIPTunnelFlags) -> Self {
        Self::from_bits_truncate(value)
    }
}

impl StaticType for IPTunnelFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_ip_tunnel_flags_get_type()) }
    }
}

impl glib::value::ValueType for IPTunnelFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for IPTunnelFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for IPTunnelFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v1_30", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
    #[doc(alias = "NMKeyfileHandlerFlags")]
    pub struct KeyfileHandlerFlags: u32 {
        #[doc(alias = "NM_KEYFILE_HANDLER_FLAGS_NONE")]
        const NONE = ffi::NM_KEYFILE_HANDLER_FLAGS_NONE as u32;
    }
}

#[cfg(any(feature = "v1_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
impl fmt::Display for KeyfileHandlerFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[cfg(any(feature = "v1_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
#[doc(hidden)]
impl IntoGlib for KeyfileHandlerFlags {
    type GlibType = ffi::NMKeyfileHandlerFlags;

    fn into_glib(self) -> ffi::NMKeyfileHandlerFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
#[doc(hidden)]
impl FromGlib<ffi::NMKeyfileHandlerFlags> for KeyfileHandlerFlags {
    unsafe fn from_glib(value: ffi::NMKeyfileHandlerFlags) -> Self {
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
impl StaticType for KeyfileHandlerFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_keyfile_handler_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
impl glib::value::ValueType for KeyfileHandlerFlags {
    type Type = Self;
}

#[cfg(any(feature = "v1_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
unsafe impl<'a> FromValue<'a> for KeyfileHandlerFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
impl ToValue for KeyfileHandlerFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
    #[doc(alias = "NMManagerReloadFlags")]
    pub struct ManagerReloadFlags: u32 {
        #[doc(alias = "NM_MANAGER_RELOAD_FLAG_CONF")]
        const CONF = ffi::NM_MANAGER_RELOAD_FLAG_CONF as u32;
        #[doc(alias = "NM_MANAGER_RELOAD_FLAG_DNS_RC")]
        const DNS_RC = ffi::NM_MANAGER_RELOAD_FLAG_DNS_RC as u32;
        #[doc(alias = "NM_MANAGER_RELOAD_FLAG_DNS_FULL")]
        const DNS_FULL = ffi::NM_MANAGER_RELOAD_FLAG_DNS_FULL as u32;
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
impl fmt::Display for ManagerReloadFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
#[doc(hidden)]
impl IntoGlib for ManagerReloadFlags {
    type GlibType = ffi::NMManagerReloadFlags;

    fn into_glib(self) -> ffi::NMManagerReloadFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
#[doc(hidden)]
impl FromGlib<ffi::NMManagerReloadFlags> for ManagerReloadFlags {
    unsafe fn from_glib(value: ffi::NMManagerReloadFlags) -> Self {
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
impl StaticType for ManagerReloadFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_manager_reload_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
impl glib::value::ValueType for ManagerReloadFlags {
    type Type = Self;
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
unsafe impl<'a> FromValue<'a> for ManagerReloadFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
impl ToValue for ManagerReloadFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v1_38", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_38")))]
    #[doc(alias = "NMRadioFlags")]
    pub struct RadioFlags: u32 {
        #[doc(alias = "NM_RADIO_FLAG_NONE")]
        const NONE = ffi::NM_RADIO_FLAG_NONE as u32;
        #[doc(alias = "NM_RADIO_FLAG_WLAN_AVAILABLE")]
        const WLAN_AVAILABLE = ffi::NM_RADIO_FLAG_WLAN_AVAILABLE as u32;
        #[doc(alias = "NM_RADIO_FLAG_WWAN_AVAILABLE")]
        const WWAN_AVAILABLE = ffi::NM_RADIO_FLAG_WWAN_AVAILABLE as u32;
    }
}

#[cfg(any(feature = "v1_38", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_38")))]
impl fmt::Display for RadioFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[cfg(any(feature = "v1_38", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_38")))]
#[doc(hidden)]
impl IntoGlib for RadioFlags {
    type GlibType = ffi::NMRadioFlags;

    fn into_glib(self) -> ffi::NMRadioFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_38", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_38")))]
#[doc(hidden)]
impl FromGlib<ffi::NMRadioFlags> for RadioFlags {
    unsafe fn from_glib(value: ffi::NMRadioFlags) -> Self {
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_38", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_38")))]
impl StaticType for RadioFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_radio_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_38", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_38")))]
impl glib::value::ValueType for RadioFlags {
    type Type = Self;
}

#[cfg(any(feature = "v1_38", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_38")))]
unsafe impl<'a> FromValue<'a> for RadioFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_38", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_38")))]
impl ToValue for RadioFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "NMSecretAgentCapabilities")]
    pub struct SecretAgentCapabilities: u32 {
        #[doc(alias = "NM_SECRET_AGENT_CAPABILITY_NONE")]
        const NONE = ffi::NM_SECRET_AGENT_CAPABILITY_NONE as u32;
        #[doc(alias = "NM_SECRET_AGENT_CAPABILITY_VPN_HINTS")]
        const VPN_HINTS = ffi::NM_SECRET_AGENT_CAPABILITY_VPN_HINTS as u32;
        #[doc(alias = "NM_SECRET_AGENT_CAPABILITY_LAST")]
        const LAST = ffi::NM_SECRET_AGENT_CAPABILITY_LAST as u32;
    }
}

impl fmt::Display for SecretAgentCapabilities {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for SecretAgentCapabilities {
    type GlibType = ffi::NMSecretAgentCapabilities;

    fn into_glib(self) -> ffi::NMSecretAgentCapabilities {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSecretAgentCapabilities> for SecretAgentCapabilities {
    unsafe fn from_glib(value: ffi::NMSecretAgentCapabilities) -> Self {
        Self::from_bits_truncate(value)
    }
}

impl StaticType for SecretAgentCapabilities {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_secret_agent_capabilities_get_type()) }
    }
}

impl glib::value::ValueType for SecretAgentCapabilities {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SecretAgentCapabilities {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for SecretAgentCapabilities {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "NMSecretAgentGetSecretsFlags")]
    pub struct SecretAgentGetSecretsFlags: u32 {
        #[doc(alias = "NM_SECRET_AGENT_GET_SECRETS_FLAG_NONE")]
        const NONE = ffi::NM_SECRET_AGENT_GET_SECRETS_FLAG_NONE as u32;
        #[doc(alias = "NM_SECRET_AGENT_GET_SECRETS_FLAG_ALLOW_INTERACTION")]
        const ALLOW_INTERACTION = ffi::NM_SECRET_AGENT_GET_SECRETS_FLAG_ALLOW_INTERACTION as u32;
        #[doc(alias = "NM_SECRET_AGENT_GET_SECRETS_FLAG_REQUEST_NEW")]
        const REQUEST_NEW = ffi::NM_SECRET_AGENT_GET_SECRETS_FLAG_REQUEST_NEW as u32;
        #[doc(alias = "NM_SECRET_AGENT_GET_SECRETS_FLAG_USER_REQUESTED")]
        const USER_REQUESTED = ffi::NM_SECRET_AGENT_GET_SECRETS_FLAG_USER_REQUESTED as u32;
        #[doc(alias = "NM_SECRET_AGENT_GET_SECRETS_FLAG_WPS_PBC_ACTIVE")]
        const WPS_PBC_ACTIVE = ffi::NM_SECRET_AGENT_GET_SECRETS_FLAG_WPS_PBC_ACTIVE as u32;
        #[doc(alias = "NM_SECRET_AGENT_GET_SECRETS_FLAG_ONLY_SYSTEM")]
        const ONLY_SYSTEM = ffi::NM_SECRET_AGENT_GET_SECRETS_FLAG_ONLY_SYSTEM as u32;
        #[doc(alias = "NM_SECRET_AGENT_GET_SECRETS_FLAG_NO_ERRORS")]
        const NO_ERRORS = ffi::NM_SECRET_AGENT_GET_SECRETS_FLAG_NO_ERRORS as u32;
    }
}

impl fmt::Display for SecretAgentGetSecretsFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for SecretAgentGetSecretsFlags {
    type GlibType = ffi::NMSecretAgentGetSecretsFlags;

    fn into_glib(self) -> ffi::NMSecretAgentGetSecretsFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSecretAgentGetSecretsFlags> for SecretAgentGetSecretsFlags {
    unsafe fn from_glib(value: ffi::NMSecretAgentGetSecretsFlags) -> Self {
        Self::from_bits_truncate(value)
    }
}

impl StaticType for SecretAgentGetSecretsFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_secret_agent_get_secrets_flags_get_type()) }
    }
}

impl glib::value::ValueType for SecretAgentGetSecretsFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SecretAgentGetSecretsFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for SecretAgentGetSecretsFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
    #[doc(alias = "NMSetting8021xAuthFlags")]
    pub struct Setting8021xAuthFlags: u32 {
        #[doc(alias = "NM_SETTING_802_1X_AUTH_FLAGS_NONE")]
        const NONE = ffi::NM_SETTING_802_1X_AUTH_FLAGS_NONE as u32;
        #[doc(alias = "NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_0_DISABLE")]
        const TLS_1_0_DISABLE = ffi::NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_0_DISABLE as u32;
        #[doc(alias = "NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_1_DISABLE")]
        const TLS_1_1_DISABLE = ffi::NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_1_DISABLE as u32;
        #[doc(alias = "NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_2_DISABLE")]
        const TLS_1_2_DISABLE = ffi::NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_2_DISABLE as u32;
        #[doc(alias = "NM_SETTING_802_1X_AUTH_FLAGS_ALL")]
        const ALL = ffi::NM_SETTING_802_1X_AUTH_FLAGS_ALL as u32;
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
impl fmt::Display for Setting8021xAuthFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
#[doc(hidden)]
impl IntoGlib for Setting8021xAuthFlags {
    type GlibType = ffi::NMSetting8021xAuthFlags;

    fn into_glib(self) -> ffi::NMSetting8021xAuthFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSetting8021xAuthFlags> for Setting8021xAuthFlags {
    unsafe fn from_glib(value: ffi::NMSetting8021xAuthFlags) -> Self {
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
impl StaticType for Setting8021xAuthFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_802_1x_auth_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
impl glib::value::ValueType for Setting8021xAuthFlags {
    type Type = Self;
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
unsafe impl<'a> FromValue<'a> for Setting8021xAuthFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
impl ToValue for Setting8021xAuthFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "NMSettingDcbFlags")]
    pub struct SettingDcbFlags: u32 {
        #[doc(alias = "NM_SETTING_DCB_FLAG_NONE")]
        const NONE = ffi::NM_SETTING_DCB_FLAG_NONE as u32;
        #[doc(alias = "NM_SETTING_DCB_FLAG_ENABLE")]
        const ENABLE = ffi::NM_SETTING_DCB_FLAG_ENABLE as u32;
        #[doc(alias = "NM_SETTING_DCB_FLAG_ADVERTISE")]
        const ADVERTISE = ffi::NM_SETTING_DCB_FLAG_ADVERTISE as u32;
        #[doc(alias = "NM_SETTING_DCB_FLAG_WILLING")]
        const WILLING = ffi::NM_SETTING_DCB_FLAG_WILLING as u32;
    }
}

impl fmt::Display for SettingDcbFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for SettingDcbFlags {
    type GlibType = ffi::NMSettingDcbFlags;

    fn into_glib(self) -> ffi::NMSettingDcbFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingDcbFlags> for SettingDcbFlags {
    unsafe fn from_glib(value: ffi::NMSettingDcbFlags) -> Self {
        Self::from_bits_truncate(value)
    }
}

impl StaticType for SettingDcbFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_dcb_flags_get_type()) }
    }
}

impl glib::value::ValueType for SettingDcbFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SettingDcbFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for SettingDcbFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "NMSettingSecretFlags")]
    pub struct SettingSecretFlags: u32 {
        #[doc(alias = "NM_SETTING_SECRET_FLAG_NONE")]
        const NONE = ffi::NM_SETTING_SECRET_FLAG_NONE as u32;
        #[doc(alias = "NM_SETTING_SECRET_FLAG_AGENT_OWNED")]
        const AGENT_OWNED = ffi::NM_SETTING_SECRET_FLAG_AGENT_OWNED as u32;
        #[doc(alias = "NM_SETTING_SECRET_FLAG_NOT_SAVED")]
        const NOT_SAVED = ffi::NM_SETTING_SECRET_FLAG_NOT_SAVED as u32;
        #[doc(alias = "NM_SETTING_SECRET_FLAG_NOT_REQUIRED")]
        const NOT_REQUIRED = ffi::NM_SETTING_SECRET_FLAG_NOT_REQUIRED as u32;
    }
}

impl fmt::Display for SettingSecretFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for SettingSecretFlags {
    type GlibType = ffi::NMSettingSecretFlags;

    fn into_glib(self) -> ffi::NMSettingSecretFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingSecretFlags> for SettingSecretFlags {
    unsafe fn from_glib(value: ffi::NMSettingSecretFlags) -> Self {
        Self::from_bits_truncate(value)
    }
}

impl StaticType for SettingSecretFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_secret_flags_get_type()) }
    }
}

impl glib::value::ValueType for SettingSecretFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SettingSecretFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for SettingSecretFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "NMSettingWiredWakeOnLan")]
    pub struct SettingWiredWakeOnLan: u32 {
        #[doc(alias = "NM_SETTING_WIRED_WAKE_ON_LAN_PHY")]
        const PHY = ffi::NM_SETTING_WIRED_WAKE_ON_LAN_PHY as u32;
        #[doc(alias = "NM_SETTING_WIRED_WAKE_ON_LAN_UNICAST")]
        const UNICAST = ffi::NM_SETTING_WIRED_WAKE_ON_LAN_UNICAST as u32;
        #[doc(alias = "NM_SETTING_WIRED_WAKE_ON_LAN_MULTICAST")]
        const MULTICAST = ffi::NM_SETTING_WIRED_WAKE_ON_LAN_MULTICAST as u32;
        #[doc(alias = "NM_SETTING_WIRED_WAKE_ON_LAN_BROADCAST")]
        const BROADCAST = ffi::NM_SETTING_WIRED_WAKE_ON_LAN_BROADCAST as u32;
        #[doc(alias = "NM_SETTING_WIRED_WAKE_ON_LAN_ARP")]
        const ARP = ffi::NM_SETTING_WIRED_WAKE_ON_LAN_ARP as u32;
        #[doc(alias = "NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC")]
        const MAGIC = ffi::NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC as u32;
        #[doc(alias = "NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT")]
        const DEFAULT = ffi::NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT as u32;
        #[doc(alias = "NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE")]
        const IGNORE = ffi::NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE as u32;
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
impl fmt::Display for SettingWiredWakeOnLan {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl IntoGlib for SettingWiredWakeOnLan {
    type GlibType = ffi::NMSettingWiredWakeOnLan;

    fn into_glib(self) -> ffi::NMSettingWiredWakeOnLan {
        self.bits()
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingWiredWakeOnLan> for SettingWiredWakeOnLan {
    unsafe fn from_glib(value: ffi::NMSettingWiredWakeOnLan) -> Self {
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
impl StaticType for SettingWiredWakeOnLan {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_wired_wake_on_lan_get_type()) }
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
impl glib::value::ValueType for SettingWiredWakeOnLan {
    type Type = Self;
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
unsafe impl<'a> FromValue<'a> for SettingWiredWakeOnLan {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
impl ToValue for SettingWiredWakeOnLan {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "NMSettingWirelessSecurityWpsMethod")]
    pub struct SettingWirelessSecurityWpsMethod: u32 {
        #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DEFAULT")]
        const DEFAULT = ffi::NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DEFAULT as u32;
        #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DISABLED")]
        const DISABLED = ffi::NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DISABLED as u32;
        #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_AUTO")]
        const AUTO = ffi::NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_AUTO as u32;
        #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_PBC")]
        const PBC = ffi::NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_PBC as u32;
        #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_PIN")]
        const PIN = ffi::NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_PIN as u32;
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
impl fmt::Display for SettingWirelessSecurityWpsMethod {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
#[doc(hidden)]
impl IntoGlib for SettingWirelessSecurityWpsMethod {
    type GlibType = ffi::NMSettingWirelessSecurityWpsMethod;

    fn into_glib(self) -> ffi::NMSettingWirelessSecurityWpsMethod {
        self.bits()
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingWirelessSecurityWpsMethod> for SettingWirelessSecurityWpsMethod {
    unsafe fn from_glib(value: ffi::NMSettingWirelessSecurityWpsMethod) -> Self {
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
impl StaticType for SettingWirelessSecurityWpsMethod {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_wireless_security_wps_method_get_type()) }
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
impl glib::value::ValueType for SettingWirelessSecurityWpsMethod {
    type Type = Self;
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
unsafe impl<'a> FromValue<'a> for SettingWirelessSecurityWpsMethod {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
impl ToValue for SettingWirelessSecurityWpsMethod {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "NMSettingWirelessWakeOnWLan")]
    pub struct SettingWirelessWakeOnWLan: u32 {
        #[doc(alias = "NM_SETTING_WIRELESS_WAKE_ON_WLAN_ANY")]
        const ANY = ffi::NM_SETTING_WIRELESS_WAKE_ON_WLAN_ANY as u32;
        #[doc(alias = "NM_SETTING_WIRELESS_WAKE_ON_WLAN_DISCONNECT")]
        const DISCONNECT = ffi::NM_SETTING_WIRELESS_WAKE_ON_WLAN_DISCONNECT as u32;
        #[doc(alias = "NM_SETTING_WIRELESS_WAKE_ON_WLAN_MAGIC")]
        const MAGIC = ffi::NM_SETTING_WIRELESS_WAKE_ON_WLAN_MAGIC as u32;
        #[doc(alias = "NM_SETTING_WIRELESS_WAKE_ON_WLAN_GTK_REKEY_FAILURE")]
        const GTK_REKEY_FAILURE = ffi::NM_SETTING_WIRELESS_WAKE_ON_WLAN_GTK_REKEY_FAILURE as u32;
        #[doc(alias = "NM_SETTING_WIRELESS_WAKE_ON_WLAN_EAP_IDENTITY_REQUEST")]
        const EAP_IDENTITY_REQUEST = ffi::NM_SETTING_WIRELESS_WAKE_ON_WLAN_EAP_IDENTITY_REQUEST as u32;
        #[doc(alias = "NM_SETTING_WIRELESS_WAKE_ON_WLAN_4WAY_HANDSHAKE")]
        const __4WAY_HANDSHAKE = ffi::NM_SETTING_WIRELESS_WAKE_ON_WLAN_4WAY_HANDSHAKE as u32;
        #[doc(alias = "NM_SETTING_WIRELESS_WAKE_ON_WLAN_RFKILL_RELEASE")]
        const RFKILL_RELEASE = ffi::NM_SETTING_WIRELESS_WAKE_ON_WLAN_RFKILL_RELEASE as u32;
        #[doc(alias = "NM_SETTING_WIRELESS_WAKE_ON_WLAN_TCP")]
        const TCP = ffi::NM_SETTING_WIRELESS_WAKE_ON_WLAN_TCP as u32;
        #[doc(alias = "NM_SETTING_WIRELESS_WAKE_ON_WLAN_ALL")]
        const ALL = ffi::NM_SETTING_WIRELESS_WAKE_ON_WLAN_ALL as u32;
        #[doc(alias = "NM_SETTING_WIRELESS_WAKE_ON_WLAN_DEFAULT")]
        const DEFAULT = ffi::NM_SETTING_WIRELESS_WAKE_ON_WLAN_DEFAULT as u32;
        #[doc(alias = "NM_SETTING_WIRELESS_WAKE_ON_WLAN_IGNORE")]
        const IGNORE = ffi::NM_SETTING_WIRELESS_WAKE_ON_WLAN_IGNORE as u32;
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
impl fmt::Display for SettingWirelessWakeOnWLan {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl IntoGlib for SettingWirelessWakeOnWLan {
    type GlibType = ffi::NMSettingWirelessWakeOnWLan;

    fn into_glib(self) -> ffi::NMSettingWirelessWakeOnWLan {
        self.bits()
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingWirelessWakeOnWLan> for SettingWirelessWakeOnWLan {
    unsafe fn from_glib(value: ffi::NMSettingWirelessWakeOnWLan) -> Self {
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
impl StaticType for SettingWirelessWakeOnWLan {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_wireless_wake_on_wlan_get_type()) }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
impl glib::value::ValueType for SettingWirelessWakeOnWLan {
    type Type = Self;
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
unsafe impl<'a> FromValue<'a> for SettingWirelessWakeOnWLan {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
impl ToValue for SettingWirelessWakeOnWLan {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    #[doc(alias = "NMSettingsAddConnection2Flags")]
    pub struct SettingsAddConnection2Flags: u32 {
        #[doc(alias = "NM_SETTINGS_ADD_CONNECTION2_FLAG_NONE")]
        const NONE = ffi::NM_SETTINGS_ADD_CONNECTION2_FLAG_NONE as u32;
        #[doc(alias = "NM_SETTINGS_ADD_CONNECTION2_FLAG_TO_DISK")]
        const TO_DISK = ffi::NM_SETTINGS_ADD_CONNECTION2_FLAG_TO_DISK as u32;
        #[doc(alias = "NM_SETTINGS_ADD_CONNECTION2_FLAG_IN_MEMORY")]
        const IN_MEMORY = ffi::NM_SETTINGS_ADD_CONNECTION2_FLAG_IN_MEMORY as u32;
        #[doc(alias = "NM_SETTINGS_ADD_CONNECTION2_FLAG_BLOCK_AUTOCONNECT")]
        const BLOCK_AUTOCONNECT = ffi::NM_SETTINGS_ADD_CONNECTION2_FLAG_BLOCK_AUTOCONNECT as u32;
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
impl fmt::Display for SettingsAddConnection2Flags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
#[doc(hidden)]
impl IntoGlib for SettingsAddConnection2Flags {
    type GlibType = ffi::NMSettingsAddConnection2Flags;

    fn into_glib(self) -> ffi::NMSettingsAddConnection2Flags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingsAddConnection2Flags> for SettingsAddConnection2Flags {
    unsafe fn from_glib(value: ffi::NMSettingsAddConnection2Flags) -> Self {
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
impl StaticType for SettingsAddConnection2Flags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_settings_add_connection2_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
impl glib::value::ValueType for SettingsAddConnection2Flags {
    type Type = Self;
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
unsafe impl<'a> FromValue<'a> for SettingsAddConnection2Flags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
impl ToValue for SettingsAddConnection2Flags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "NMSettingsConnectionFlags")]
    pub struct SettingsConnectionFlags: u32 {
        #[doc(alias = "NM_SETTINGS_CONNECTION_FLAG_NONE")]
        const NONE = ffi::NM_SETTINGS_CONNECTION_FLAG_NONE as u32;
        #[doc(alias = "NM_SETTINGS_CONNECTION_FLAG_UNSAVED")]
        const UNSAVED = ffi::NM_SETTINGS_CONNECTION_FLAG_UNSAVED as u32;
        #[doc(alias = "NM_SETTINGS_CONNECTION_FLAG_NM_GENERATED")]
        const NM_GENERATED = ffi::NM_SETTINGS_CONNECTION_FLAG_NM_GENERATED as u32;
        #[doc(alias = "NM_SETTINGS_CONNECTION_FLAG_VOLATILE")]
        const VOLATILE = ffi::NM_SETTINGS_CONNECTION_FLAG_VOLATILE as u32;
        #[doc(alias = "NM_SETTINGS_CONNECTION_FLAG_EXTERNAL")]
        const EXTERNAL = ffi::NM_SETTINGS_CONNECTION_FLAG_EXTERNAL as u32;
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
impl fmt::Display for SettingsConnectionFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl IntoGlib for SettingsConnectionFlags {
    type GlibType = ffi::NMSettingsConnectionFlags;

    fn into_glib(self) -> ffi::NMSettingsConnectionFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingsConnectionFlags> for SettingsConnectionFlags {
    unsafe fn from_glib(value: ffi::NMSettingsConnectionFlags) -> Self {
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
impl StaticType for SettingsConnectionFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_settings_connection_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
impl glib::value::ValueType for SettingsConnectionFlags {
    type Type = Self;
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
unsafe impl<'a> FromValue<'a> for SettingsConnectionFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
impl ToValue for SettingsConnectionFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "NMSettingsUpdate2Flags")]
    pub struct SettingsUpdate2Flags: u32 {
        #[doc(alias = "NM_SETTINGS_UPDATE2_FLAG_NONE")]
        const NONE = ffi::NM_SETTINGS_UPDATE2_FLAG_NONE as u32;
        #[doc(alias = "NM_SETTINGS_UPDATE2_FLAG_TO_DISK")]
        const TO_DISK = ffi::NM_SETTINGS_UPDATE2_FLAG_TO_DISK as u32;
        #[doc(alias = "NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY")]
        const IN_MEMORY = ffi::NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY as u32;
        #[doc(alias = "NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY_DETACHED")]
        const IN_MEMORY_DETACHED = ffi::NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY_DETACHED as u32;
        #[doc(alias = "NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY_ONLY")]
        const IN_MEMORY_ONLY = ffi::NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY_ONLY as u32;
        #[doc(alias = "NM_SETTINGS_UPDATE2_FLAG_VOLATILE")]
        const VOLATILE = ffi::NM_SETTINGS_UPDATE2_FLAG_VOLATILE as u32;
        #[doc(alias = "NM_SETTINGS_UPDATE2_FLAG_BLOCK_AUTOCONNECT")]
        const BLOCK_AUTOCONNECT = ffi::NM_SETTINGS_UPDATE2_FLAG_BLOCK_AUTOCONNECT as u32;
        #[doc(alias = "NM_SETTINGS_UPDATE2_FLAG_NO_REAPPLY")]
        const NO_REAPPLY = ffi::NM_SETTINGS_UPDATE2_FLAG_NO_REAPPLY as u32;
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
impl fmt::Display for SettingsUpdate2Flags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl IntoGlib for SettingsUpdate2Flags {
    type GlibType = ffi::NMSettingsUpdate2Flags;

    fn into_glib(self) -> ffi::NMSettingsUpdate2Flags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingsUpdate2Flags> for SettingsUpdate2Flags {
    unsafe fn from_glib(value: ffi::NMSettingsUpdate2Flags) -> Self {
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
impl StaticType for SettingsUpdate2Flags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_settings_update2_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
impl glib::value::ValueType for SettingsUpdate2Flags {
    type Type = Self;
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
unsafe impl<'a> FromValue<'a> for SettingsUpdate2Flags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
impl ToValue for SettingsUpdate2Flags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "NMTeamLinkWatcherArpPingFlags")]
    pub struct TeamLinkWatcherArpPingFlags: u32 {
        #[doc(alias = "NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_VALIDATE_ACTIVE")]
        const VALIDATE_ACTIVE = ffi::NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_VALIDATE_ACTIVE as u32;
        #[doc(alias = "NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_VALIDATE_INACTIVE")]
        const VALIDATE_INACTIVE = ffi::NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_VALIDATE_INACTIVE as u32;
        #[doc(alias = "NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_SEND_ALWAYS")]
        const SEND_ALWAYS = ffi::NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_SEND_ALWAYS as u32;
    }
}

impl fmt::Display for TeamLinkWatcherArpPingFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for TeamLinkWatcherArpPingFlags {
    type GlibType = ffi::NMTeamLinkWatcherArpPingFlags;

    fn into_glib(self) -> ffi::NMTeamLinkWatcherArpPingFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMTeamLinkWatcherArpPingFlags> for TeamLinkWatcherArpPingFlags {
    unsafe fn from_glib(value: ffi::NMTeamLinkWatcherArpPingFlags) -> Self {
        Self::from_bits_truncate(value)
    }
}

impl StaticType for TeamLinkWatcherArpPingFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_team_link_watcher_arp_ping_flags_get_type()) }
    }
}

impl glib::value::ValueType for TeamLinkWatcherArpPingFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for TeamLinkWatcherArpPingFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for TeamLinkWatcherArpPingFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "NMVlanFlags")]
    pub struct VlanFlags: u32 {
        #[doc(alias = "NM_VLAN_FLAG_REORDER_HEADERS")]
        const REORDER_HEADERS = ffi::NM_VLAN_FLAG_REORDER_HEADERS as u32;
        #[doc(alias = "NM_VLAN_FLAG_GVRP")]
        const GVRP = ffi::NM_VLAN_FLAG_GVRP as u32;
        #[doc(alias = "NM_VLAN_FLAG_LOOSE_BINDING")]
        const LOOSE_BINDING = ffi::NM_VLAN_FLAG_LOOSE_BINDING as u32;
        #[doc(alias = "NM_VLAN_FLAG_MVRP")]
        const MVRP = ffi::NM_VLAN_FLAG_MVRP as u32;
    }
}

impl fmt::Display for VlanFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for VlanFlags {
    type GlibType = ffi::NMVlanFlags;

    fn into_glib(self) -> ffi::NMVlanFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMVlanFlags> for VlanFlags {
    unsafe fn from_glib(value: ffi::NMVlanFlags) -> Self {
        Self::from_bits_truncate(value)
    }
}

impl StaticType for VlanFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_vlan_flags_get_type()) }
    }
}

impl glib::value::ValueType for VlanFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for VlanFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for VlanFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "NMVpnEditorPluginCapability")]
    pub struct VpnEditorPluginCapability: u32 {
        #[doc(alias = "NM_VPN_EDITOR_PLUGIN_CAPABILITY_NONE")]
        const NONE = ffi::NM_VPN_EDITOR_PLUGIN_CAPABILITY_NONE as u32;
        #[doc(alias = "NM_VPN_EDITOR_PLUGIN_CAPABILITY_IMPORT")]
        const IMPORT = ffi::NM_VPN_EDITOR_PLUGIN_CAPABILITY_IMPORT as u32;
        #[doc(alias = "NM_VPN_EDITOR_PLUGIN_CAPABILITY_EXPORT")]
        const EXPORT = ffi::NM_VPN_EDITOR_PLUGIN_CAPABILITY_EXPORT as u32;
        #[doc(alias = "NM_VPN_EDITOR_PLUGIN_CAPABILITY_IPV6")]
        const IPV6 = ffi::NM_VPN_EDITOR_PLUGIN_CAPABILITY_IPV6 as u32;
    }
}

impl fmt::Display for VpnEditorPluginCapability {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for VpnEditorPluginCapability {
    type GlibType = ffi::NMVpnEditorPluginCapability;

    fn into_glib(self) -> ffi::NMVpnEditorPluginCapability {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMVpnEditorPluginCapability> for VpnEditorPluginCapability {
    unsafe fn from_glib(value: ffi::NMVpnEditorPluginCapability) -> Self {
        Self::from_bits_truncate(value)
    }
}

impl StaticType for VpnEditorPluginCapability {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_vpn_editor_plugin_capability_get_type()) }
    }
}

impl glib::value::ValueType for VpnEditorPluginCapability {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for VpnEditorPluginCapability {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for VpnEditorPluginCapability {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "NM80211ApFlags")]
    pub struct _80211ApFlags: u32 {
        #[doc(alias = "NM_802_11_AP_FLAGS_NONE")]
        const NONE = ffi::NM_802_11_AP_FLAGS_NONE as u32;
        #[doc(alias = "NM_802_11_AP_FLAGS_PRIVACY")]
        const PRIVACY = ffi::NM_802_11_AP_FLAGS_PRIVACY as u32;
        #[doc(alias = "NM_802_11_AP_FLAGS_WPS")]
        const WPS = ffi::NM_802_11_AP_FLAGS_WPS as u32;
        #[doc(alias = "NM_802_11_AP_FLAGS_WPS_PBC")]
        const WPS_PBC = ffi::NM_802_11_AP_FLAGS_WPS_PBC as u32;
        #[doc(alias = "NM_802_11_AP_FLAGS_WPS_PIN")]
        const WPS_PIN = ffi::NM_802_11_AP_FLAGS_WPS_PIN as u32;
    }
}

impl fmt::Display for _80211ApFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for _80211ApFlags {
    type GlibType = ffi::NM80211ApFlags;

    fn into_glib(self) -> ffi::NM80211ApFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NM80211ApFlags> for _80211ApFlags {
    unsafe fn from_glib(value: ffi::NM80211ApFlags) -> Self {
        Self::from_bits_truncate(value)
    }
}

impl StaticType for _80211ApFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_802_11_ap_flags_get_type()) }
    }
}

impl glib::value::ValueType for _80211ApFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for _80211ApFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for _80211ApFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "NM80211ApSecurityFlags")]
    pub struct _80211ApSecurityFlags: u32 {
        #[doc(alias = "NM_802_11_AP_SEC_NONE")]
        const NONE = ffi::NM_802_11_AP_SEC_NONE as u32;
        #[doc(alias = "NM_802_11_AP_SEC_PAIR_WEP40")]
        const PAIR_WEP40 = ffi::NM_802_11_AP_SEC_PAIR_WEP40 as u32;
        #[doc(alias = "NM_802_11_AP_SEC_PAIR_WEP104")]
        const PAIR_WEP104 = ffi::NM_802_11_AP_SEC_PAIR_WEP104 as u32;
        #[doc(alias = "NM_802_11_AP_SEC_PAIR_TKIP")]
        const PAIR_TKIP = ffi::NM_802_11_AP_SEC_PAIR_TKIP as u32;
        #[doc(alias = "NM_802_11_AP_SEC_PAIR_CCMP")]
        const PAIR_CCMP = ffi::NM_802_11_AP_SEC_PAIR_CCMP as u32;
        #[doc(alias = "NM_802_11_AP_SEC_GROUP_WEP40")]
        const GROUP_WEP40 = ffi::NM_802_11_AP_SEC_GROUP_WEP40 as u32;
        #[doc(alias = "NM_802_11_AP_SEC_GROUP_WEP104")]
        const GROUP_WEP104 = ffi::NM_802_11_AP_SEC_GROUP_WEP104 as u32;
        #[doc(alias = "NM_802_11_AP_SEC_GROUP_TKIP")]
        const GROUP_TKIP = ffi::NM_802_11_AP_SEC_GROUP_TKIP as u32;
        #[doc(alias = "NM_802_11_AP_SEC_GROUP_CCMP")]
        const GROUP_CCMP = ffi::NM_802_11_AP_SEC_GROUP_CCMP as u32;
        #[doc(alias = "NM_802_11_AP_SEC_KEY_MGMT_PSK")]
        const KEY_MGMT_PSK = ffi::NM_802_11_AP_SEC_KEY_MGMT_PSK as u32;
        #[doc(alias = "NM_802_11_AP_SEC_KEY_MGMT_802_1X")]
        const KEY_MGMT_802_1X = ffi::NM_802_11_AP_SEC_KEY_MGMT_802_1X as u32;
        #[doc(alias = "NM_802_11_AP_SEC_KEY_MGMT_SAE")]
        const KEY_MGMT_SAE = ffi::NM_802_11_AP_SEC_KEY_MGMT_SAE as u32;
        #[doc(alias = "NM_802_11_AP_SEC_KEY_MGMT_OWE")]
        const KEY_MGMT_OWE = ffi::NM_802_11_AP_SEC_KEY_MGMT_OWE as u32;
        #[doc(alias = "NM_802_11_AP_SEC_KEY_MGMT_OWE_TM")]
        const KEY_MGMT_OWE_TM = ffi::NM_802_11_AP_SEC_KEY_MGMT_OWE_TM as u32;
        #[doc(alias = "NM_802_11_AP_SEC_KEY_MGMT_EAP_SUITE_B_192")]
        const KEY_MGMT_EAP_SUITE_B_192 = ffi::NM_802_11_AP_SEC_KEY_MGMT_EAP_SUITE_B_192 as u32;
    }
}

impl fmt::Display for _80211ApSecurityFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for _80211ApSecurityFlags {
    type GlibType = ffi::NM80211ApSecurityFlags;

    fn into_glib(self) -> ffi::NM80211ApSecurityFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NM80211ApSecurityFlags> for _80211ApSecurityFlags {
    unsafe fn from_glib(value: ffi::NM80211ApSecurityFlags) -> Self {
        Self::from_bits_truncate(value)
    }
}

impl StaticType for _80211ApSecurityFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_802_11_ap_security_flags_get_type()) }
    }
}

impl glib::value::ValueType for _80211ApSecurityFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for _80211ApSecurityFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for _80211ApSecurityFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}
