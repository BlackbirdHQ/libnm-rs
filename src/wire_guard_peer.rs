// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

#[cfg(any(feature = "v1_16", feature = "dox"))]
use glib;
#[cfg(any(feature = "v1_16", feature = "dox"))]
use glib::translate::*;
#[cfg(any(feature = "v1_16", feature = "dox"))]
use glib::GString;
use nm_sys;
#[cfg(any(feature = "v1_16", feature = "dox"))]
use std::ptr;
#[cfg(any(feature = "v1_16", feature = "dox"))]
use SettingCompareFlags;
#[cfg(any(feature = "v1_16", feature = "dox"))]
use SettingSecretFlags;

glib_wrapper! {
    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct WireGuardPeer(Shared<nm_sys::NMWireGuardPeer>);

    match fn {
        ref => |ptr| nm_sys::nm_wireguard_peer_ref(ptr),
        unref => |ptr| nm_sys::nm_wireguard_peer_unref(ptr),
        get_type => || nm_sys::nm_wireguard_peer_get_type(),
    }
}

impl WireGuardPeer {
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn new() -> WireGuardPeer {
        unsafe { from_glib_full(nm_sys::nm_wireguard_peer_new()) }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn append_allowed_ip(&self, allowed_ip: &str, accept_invalid: bool) -> bool {
        unsafe {
            from_glib(nm_sys::nm_wireguard_peer_append_allowed_ip(
                self.to_glib_none().0,
                allowed_ip.to_glib_none().0,
                accept_invalid.to_glib(),
            ))
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn clear_allowed_ips(&self) {
        unsafe {
            nm_sys::nm_wireguard_peer_clear_allowed_ips(self.to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn cmp(&self, b: Option<&WireGuardPeer>, compare_flags: SettingCompareFlags) -> i32 {
        unsafe {
            nm_sys::nm_wireguard_peer_cmp(
                self.to_glib_none().0,
                b.to_glib_none().0,
                compare_flags.to_glib(),
            )
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn get_allowed_ips_len(&self) -> u32 {
        unsafe { nm_sys::nm_wireguard_peer_get_allowed_ips_len(self.to_glib_none().0) }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn get_endpoint(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_wireguard_peer_get_endpoint(
                self.to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn get_persistent_keepalive(&self) -> u16 {
        unsafe { nm_sys::nm_wireguard_peer_get_persistent_keepalive(self.to_glib_none().0) }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn get_preshared_key(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_wireguard_peer_get_preshared_key(
                self.to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn get_preshared_key_flags(&self) -> SettingSecretFlags {
        unsafe {
            from_glib(nm_sys::nm_wireguard_peer_get_preshared_key_flags(
                self.to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn get_public_key(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_wireguard_peer_get_public_key(
                self.to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn is_sealed(&self) -> bool {
        unsafe { from_glib(nm_sys::nm_wireguard_peer_is_sealed(self.to_glib_none().0)) }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn is_valid(
        &self,
        check_non_secrets: bool,
        check_secrets: bool,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = nm_sys::nm_wireguard_peer_is_valid(
                self.to_glib_none().0,
                check_non_secrets.to_glib(),
                check_secrets.to_glib(),
                &mut error,
            );
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn new_clone(&self, with_secrets: bool) -> Option<WireGuardPeer> {
        unsafe {
            from_glib_full(nm_sys::nm_wireguard_peer_new_clone(
                self.to_glib_none().0,
                with_secrets.to_glib(),
            ))
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn remove_allowed_ip(&self, idx: u32) -> bool {
        unsafe {
            from_glib(nm_sys::nm_wireguard_peer_remove_allowed_ip(
                self.to_glib_none().0,
                idx,
            ))
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn seal(&self) {
        unsafe {
            nm_sys::nm_wireguard_peer_seal(self.to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn set_endpoint(&self, endpoint: &str, allow_invalid: bool) -> bool {
        unsafe {
            from_glib(nm_sys::nm_wireguard_peer_set_endpoint(
                self.to_glib_none().0,
                endpoint.to_glib_none().0,
                allow_invalid.to_glib(),
            ))
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn set_persistent_keepalive(&self, persistent_keepalive: u16) {
        unsafe {
            nm_sys::nm_wireguard_peer_set_persistent_keepalive(
                self.to_glib_none().0,
                persistent_keepalive,
            );
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn set_preshared_key(&self, preshared_key: Option<&str>, accept_invalid: bool) -> bool {
        unsafe {
            from_glib(nm_sys::nm_wireguard_peer_set_preshared_key(
                self.to_glib_none().0,
                preshared_key.to_glib_none().0,
                accept_invalid.to_glib(),
            ))
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn set_preshared_key_flags(&self, preshared_key_flags: SettingSecretFlags) {
        unsafe {
            nm_sys::nm_wireguard_peer_set_preshared_key_flags(
                self.to_glib_none().0,
                preshared_key_flags.to_glib(),
            );
        }
    }

    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn set_public_key(&self, public_key: Option<&str>, accept_invalid: bool) -> bool {
        unsafe {
            from_glib(nm_sys::nm_wireguard_peer_set_public_key(
                self.to_glib_none().0,
                public_key.to_glib_none().0,
                accept_invalid.to_glib(),
            ))
        }
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
impl Default for WireGuardPeer {
    fn default() -> Self {
        Self::new()
    }
}
