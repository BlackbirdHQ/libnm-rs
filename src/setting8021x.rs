// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib;
use glib::object::Cast;
use glib::object::IsA;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib::GString;
use glib::StaticType;
use glib::Value;
use glib_sys;
use gobject_sys;
use nm_sys;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem::transmute;
use Setting;
#[cfg(any(feature = "v1_8", feature = "dox"))]
use Setting8021xAuthFlags;
use Setting8021xCKFormat;
use Setting8021xCKScheme;
use SettingSecretFlags;

glib_wrapper! {
    pub struct Setting8021x(Object<nm_sys::NMSetting8021x, nm_sys::NMSetting8021xClass, Setting8021xClass>) @extends Setting;

    match fn {
        get_type => || nm_sys::nm_setting_802_1x_get_type(),
    }
}

impl Setting8021x {
    pub fn new() -> Setting8021x {
        unsafe { Setting::from_glib_full(nm_sys::nm_setting_802_1x_new()).unsafe_cast() }
    }

    //#[cfg(any(feature = "v1_2", feature = "dox"))]
    //pub fn check_cert_scheme(pdata: /*Unimplemented*/Option<Fundamental: Pointer>, length: usize) -> Result<Setting8021xCKScheme, glib::Error> {
    //    unsafe { TODO: call nm_sys:nm_setting_802_1x_check_cert_scheme() }
    //}
}

impl Default for Setting8021x {
    fn default() -> Self {
        Self::new()
    }
}

pub const NONE_SETTING8021X: Option<&Setting8021x> = None;

pub trait Setting8021xExt: 'static {
    fn add_altsubject_match(&self, altsubject_match: &str) -> bool;

    fn add_eap_method(&self, eap: &str) -> bool;

    fn add_phase2_altsubject_match(&self, phase2_altsubject_match: &str) -> bool;

    fn clear_altsubject_matches(&self);

    fn clear_eap_methods(&self);

    fn clear_phase2_altsubject_matches(&self);

    fn get_altsubject_match(&self, i: u32) -> Option<GString>;

    fn get_anonymous_identity(&self) -> Option<GString>;

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn get_auth_timeout(&self) -> i32;

    fn get_ca_cert_blob(&self) -> Option<glib::Bytes>;

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn get_ca_cert_password(&self) -> Option<GString>;

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn get_ca_cert_password_flags(&self) -> SettingSecretFlags;

    fn get_ca_cert_path(&self) -> Option<GString>;

    fn get_ca_cert_scheme(&self) -> Setting8021xCKScheme;

    #[cfg(any(feature = "v1_6", feature = "dox"))]
    fn get_ca_cert_uri(&self) -> Option<GString>;

    fn get_ca_path(&self) -> Option<GString>;

    fn get_client_cert_blob(&self) -> Option<glib::Bytes>;

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn get_client_cert_password(&self) -> Option<GString>;

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn get_client_cert_password_flags(&self) -> SettingSecretFlags;

    fn get_client_cert_path(&self) -> Option<GString>;

    fn get_client_cert_scheme(&self) -> Setting8021xCKScheme;

    #[cfg(any(feature = "v1_6", feature = "dox"))]
    fn get_client_cert_uri(&self) -> Option<GString>;

    #[cfg(any(feature = "v1_24", feature = "dox"))]
    fn get_domain_match(&self) -> Option<GString>;

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_domain_suffix_match(&self) -> Option<GString>;

    fn get_eap_method(&self, i: u32) -> Option<GString>;

    fn get_identity(&self) -> Option<GString>;

    fn get_num_altsubject_matches(&self) -> u32;

    fn get_num_eap_methods(&self) -> u32;

    fn get_num_phase2_altsubject_matches(&self) -> u32;

    #[cfg(any(feature = "v1_22", feature = "dox"))]
    fn get_optional(&self) -> bool;

    fn get_pac_file(&self) -> Option<GString>;

    fn get_password(&self) -> Option<GString>;

    fn get_password_flags(&self) -> SettingSecretFlags;

    fn get_password_raw(&self) -> Option<glib::Bytes>;

    fn get_password_raw_flags(&self) -> SettingSecretFlags;

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn get_phase1_auth_flags(&self) -> Setting8021xAuthFlags;

    fn get_phase1_fast_provisioning(&self) -> Option<GString>;

    fn get_phase1_peaplabel(&self) -> Option<GString>;

    fn get_phase1_peapver(&self) -> Option<GString>;

    fn get_phase2_altsubject_match(&self, i: u32) -> Option<GString>;

    fn get_phase2_auth(&self) -> Option<GString>;

    fn get_phase2_autheap(&self) -> Option<GString>;

    fn get_phase2_ca_cert_blob(&self) -> Option<glib::Bytes>;

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn get_phase2_ca_cert_password(&self) -> Option<GString>;

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn get_phase2_ca_cert_password_flags(&self) -> SettingSecretFlags;

    fn get_phase2_ca_cert_path(&self) -> Option<GString>;

    fn get_phase2_ca_cert_scheme(&self) -> Setting8021xCKScheme;

    #[cfg(any(feature = "v1_6", feature = "dox"))]
    fn get_phase2_ca_cert_uri(&self) -> Option<GString>;

    fn get_phase2_ca_path(&self) -> Option<GString>;

    fn get_phase2_client_cert_blob(&self) -> Option<glib::Bytes>;

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn get_phase2_client_cert_password(&self) -> Option<GString>;

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn get_phase2_client_cert_password_flags(&self) -> SettingSecretFlags;

    fn get_phase2_client_cert_path(&self) -> Option<GString>;

    fn get_phase2_client_cert_scheme(&self) -> Setting8021xCKScheme;

    #[cfg(any(feature = "v1_6", feature = "dox"))]
    fn get_phase2_client_cert_uri(&self) -> Option<GString>;

    #[cfg(any(feature = "v1_24", feature = "dox"))]
    fn get_phase2_domain_match(&self) -> Option<GString>;

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_phase2_domain_suffix_match(&self) -> Option<GString>;

    fn get_phase2_private_key_blob(&self) -> Option<glib::Bytes>;

    fn get_phase2_private_key_format(&self) -> Setting8021xCKFormat;

    fn get_phase2_private_key_password(&self) -> Option<GString>;

    fn get_phase2_private_key_password_flags(&self) -> SettingSecretFlags;

    fn get_phase2_private_key_path(&self) -> Option<GString>;

    fn get_phase2_private_key_scheme(&self) -> Setting8021xCKScheme;

    #[cfg(any(feature = "v1_6", feature = "dox"))]
    fn get_phase2_private_key_uri(&self) -> Option<GString>;

    fn get_phase2_subject_match(&self) -> Option<GString>;

    fn get_pin(&self) -> Option<GString>;

    fn get_pin_flags(&self) -> SettingSecretFlags;

    fn get_private_key_blob(&self) -> Option<glib::Bytes>;

    fn get_private_key_format(&self) -> Setting8021xCKFormat;

    fn get_private_key_password(&self) -> Option<GString>;

    fn get_private_key_password_flags(&self) -> SettingSecretFlags;

    fn get_private_key_path(&self) -> Option<GString>;

    fn get_private_key_scheme(&self) -> Setting8021xCKScheme;

    #[cfg(any(feature = "v1_6", feature = "dox"))]
    fn get_private_key_uri(&self) -> Option<GString>;

    fn get_subject_match(&self) -> Option<GString>;

    fn get_system_ca_certs(&self) -> bool;

    fn remove_altsubject_match(&self, i: u32);

    fn remove_altsubject_match_by_value(&self, altsubject_match: &str) -> bool;

    fn remove_eap_method(&self, i: u32);

    fn remove_eap_method_by_value(&self, eap: &str) -> bool;

    fn remove_phase2_altsubject_match(&self, i: u32);

    fn remove_phase2_altsubject_match_by_value(&self, phase2_altsubject_match: &str) -> bool;

    fn get_property_altsubject_matches(&self) -> Vec<GString>;

    fn set_property_altsubject_matches(&self, altsubject_matches: &[&str]);

    fn set_property_anonymous_identity(&self, anonymous_identity: Option<&str>);

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn set_property_auth_timeout(&self, auth_timeout: i32);

    fn get_property_ca_cert(&self) -> Option<glib::Bytes>;

    fn set_property_ca_cert(&self, ca_cert: Option<&glib::Bytes>);

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn set_property_ca_cert_password(&self, ca_cert_password: Option<&str>);

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn set_property_ca_cert_password_flags(&self, ca_cert_password_flags: SettingSecretFlags);

    fn set_property_ca_path(&self, ca_path: Option<&str>);

    fn get_property_client_cert(&self) -> Option<glib::Bytes>;

    fn set_property_client_cert(&self, client_cert: Option<&glib::Bytes>);

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn set_property_client_cert_password(&self, client_cert_password: Option<&str>);

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn set_property_client_cert_password_flags(
        &self,
        client_cert_password_flags: SettingSecretFlags,
    );

    #[cfg(any(feature = "v1_24", feature = "dox"))]
    fn set_property_domain_match(&self, domain_match: Option<&str>);

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn set_property_domain_suffix_match(&self, domain_suffix_match: Option<&str>);

    fn get_property_eap(&self) -> Vec<GString>;

    fn set_property_eap(&self, eap: &[&str]);

    fn set_property_identity(&self, identity: Option<&str>);

    #[cfg(any(feature = "v1_22", feature = "dox"))]
    fn set_property_optional(&self, optional: bool);

    fn set_property_pac_file(&self, pac_file: Option<&str>);

    fn set_property_password(&self, password: Option<&str>);

    fn set_property_password_flags(&self, password_flags: SettingSecretFlags);

    fn set_property_password_raw(&self, password_raw: Option<&glib::Bytes>);

    fn set_property_password_raw_flags(&self, password_raw_flags: SettingSecretFlags);

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn set_property_phase1_auth_flags(&self, phase1_auth_flags: u32);

    fn set_property_phase1_fast_provisioning(&self, phase1_fast_provisioning: Option<&str>);

    fn set_property_phase1_peaplabel(&self, phase1_peaplabel: Option<&str>);

    fn set_property_phase1_peapver(&self, phase1_peapver: Option<&str>);

    fn get_property_phase2_altsubject_matches(&self) -> Vec<GString>;

    fn set_property_phase2_altsubject_matches(&self, phase2_altsubject_matches: &[&str]);

    fn set_property_phase2_auth(&self, phase2_auth: Option<&str>);

    fn set_property_phase2_autheap(&self, phase2_autheap: Option<&str>);

    fn get_property_phase2_ca_cert(&self) -> Option<glib::Bytes>;

    fn set_property_phase2_ca_cert(&self, phase2_ca_cert: Option<&glib::Bytes>);

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn set_property_phase2_ca_cert_password(&self, phase2_ca_cert_password: Option<&str>);

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn set_property_phase2_ca_cert_password_flags(
        &self,
        phase2_ca_cert_password_flags: SettingSecretFlags,
    );

    fn set_property_phase2_ca_path(&self, phase2_ca_path: Option<&str>);

    fn get_property_phase2_client_cert(&self) -> Option<glib::Bytes>;

    fn set_property_phase2_client_cert(&self, phase2_client_cert: Option<&glib::Bytes>);

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn set_property_phase2_client_cert_password(&self, phase2_client_cert_password: Option<&str>);

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn set_property_phase2_client_cert_password_flags(
        &self,
        phase2_client_cert_password_flags: SettingSecretFlags,
    );

    #[cfg(any(feature = "v1_24", feature = "dox"))]
    fn set_property_phase2_domain_match(&self, phase2_domain_match: Option<&str>);

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn set_property_phase2_domain_suffix_match(&self, phase2_domain_suffix_match: Option<&str>);

    fn get_property_phase2_private_key(&self) -> Option<glib::Bytes>;

    fn set_property_phase2_private_key(&self, phase2_private_key: Option<&glib::Bytes>);

    fn set_property_phase2_private_key_password(&self, phase2_private_key_password: Option<&str>);

    fn set_property_phase2_private_key_password_flags(
        &self,
        phase2_private_key_password_flags: SettingSecretFlags,
    );

    fn set_property_phase2_subject_match(&self, phase2_subject_match: Option<&str>);

    fn set_property_pin(&self, pin: Option<&str>);

    fn set_property_pin_flags(&self, pin_flags: SettingSecretFlags);

    fn get_property_private_key(&self) -> Option<glib::Bytes>;

    fn set_property_private_key(&self, private_key: Option<&glib::Bytes>);

    fn set_property_private_key_password(&self, private_key_password: Option<&str>);

    fn set_property_private_key_password_flags(
        &self,
        private_key_password_flags: SettingSecretFlags,
    );

    fn set_property_subject_match(&self, subject_match: Option<&str>);

    fn set_property_system_ca_certs(&self, system_ca_certs: bool);

    fn connect_property_altsubject_matches_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_anonymous_identity_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn connect_property_auth_timeout_notify<F: Fn(&Self) + 'static>(&self, f: F)
        -> SignalHandlerId;

    fn connect_property_ca_cert_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn connect_property_ca_cert_password_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn connect_property_ca_cert_password_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_ca_path_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_client_cert_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn connect_property_client_cert_password_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn connect_property_client_cert_password_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[cfg(any(feature = "v1_24", feature = "dox"))]
    fn connect_property_domain_match_notify<F: Fn(&Self) + 'static>(&self, f: F)
        -> SignalHandlerId;

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn connect_property_domain_suffix_match_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_eap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_identity_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v1_22", feature = "dox"))]
    fn connect_property_optional_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_pac_file_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_password_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_password_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_password_raw_notify<F: Fn(&Self) + 'static>(&self, f: F)
        -> SignalHandlerId;

    fn connect_property_password_raw_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn connect_property_phase1_auth_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_phase1_fast_provisioning_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_phase1_peaplabel_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_phase1_peapver_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_phase2_altsubject_matches_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_phase2_auth_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_phase2_autheap_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_phase2_ca_cert_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn connect_property_phase2_ca_cert_password_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn connect_property_phase2_ca_cert_password_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_phase2_ca_path_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_phase2_client_cert_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn connect_property_phase2_client_cert_password_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn connect_property_phase2_client_cert_password_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[cfg(any(feature = "v1_24", feature = "dox"))]
    fn connect_property_phase2_domain_match_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn connect_property_phase2_domain_suffix_match_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_phase2_private_key_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_phase2_private_key_password_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_phase2_private_key_password_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_phase2_subject_match_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_pin_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_pin_flags_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_private_key_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_private_key_password_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_private_key_password_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_subject_match_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_system_ca_certs_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;
}

impl<O: IsA<Setting8021x>> Setting8021xExt for O {
    fn add_altsubject_match(&self, altsubject_match: &str) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_802_1x_add_altsubject_match(
                self.as_ref().to_glib_none().0,
                altsubject_match.to_glib_none().0,
            ))
        }
    }

    fn add_eap_method(&self, eap: &str) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_802_1x_add_eap_method(
                self.as_ref().to_glib_none().0,
                eap.to_glib_none().0,
            ))
        }
    }

    fn add_phase2_altsubject_match(&self, phase2_altsubject_match: &str) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_802_1x_add_phase2_altsubject_match(
                self.as_ref().to_glib_none().0,
                phase2_altsubject_match.to_glib_none().0,
            ))
        }
    }

    fn clear_altsubject_matches(&self) {
        unsafe {
            nm_sys::nm_setting_802_1x_clear_altsubject_matches(self.as_ref().to_glib_none().0);
        }
    }

    fn clear_eap_methods(&self) {
        unsafe {
            nm_sys::nm_setting_802_1x_clear_eap_methods(self.as_ref().to_glib_none().0);
        }
    }

    fn clear_phase2_altsubject_matches(&self) {
        unsafe {
            nm_sys::nm_setting_802_1x_clear_phase2_altsubject_matches(
                self.as_ref().to_glib_none().0,
            );
        }
    }

    fn get_altsubject_match(&self, i: u32) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_altsubject_match(
                self.as_ref().to_glib_none().0,
                i,
            ))
        }
    }

    fn get_anonymous_identity(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_anonymous_identity(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn get_auth_timeout(&self) -> i32 {
        unsafe { nm_sys::nm_setting_802_1x_get_auth_timeout(self.as_ref().to_glib_none().0) }
    }

    fn get_ca_cert_blob(&self) -> Option<glib::Bytes> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_ca_cert_blob(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn get_ca_cert_password(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_ca_cert_password(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn get_ca_cert_password_flags(&self) -> SettingSecretFlags {
        unsafe {
            from_glib(nm_sys::nm_setting_802_1x_get_ca_cert_password_flags(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_ca_cert_path(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_ca_cert_path(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_ca_cert_scheme(&self) -> Setting8021xCKScheme {
        unsafe {
            from_glib(nm_sys::nm_setting_802_1x_get_ca_cert_scheme(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_6", feature = "dox"))]
    fn get_ca_cert_uri(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_ca_cert_uri(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_ca_path(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_ca_path(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_client_cert_blob(&self) -> Option<glib::Bytes> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_client_cert_blob(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn get_client_cert_password(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_client_cert_password(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn get_client_cert_password_flags(&self) -> SettingSecretFlags {
        unsafe {
            from_glib(nm_sys::nm_setting_802_1x_get_client_cert_password_flags(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_client_cert_path(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_client_cert_path(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_client_cert_scheme(&self) -> Setting8021xCKScheme {
        unsafe {
            from_glib(nm_sys::nm_setting_802_1x_get_client_cert_scheme(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_6", feature = "dox"))]
    fn get_client_cert_uri(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_client_cert_uri(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_24", feature = "dox"))]
    fn get_domain_match(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_domain_match(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_domain_suffix_match(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_domain_suffix_match(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_eap_method(&self, i: u32) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_eap_method(
                self.as_ref().to_glib_none().0,
                i,
            ))
        }
    }

    fn get_identity(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_identity(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_num_altsubject_matches(&self) -> u32 {
        unsafe {
            nm_sys::nm_setting_802_1x_get_num_altsubject_matches(self.as_ref().to_glib_none().0)
        }
    }

    fn get_num_eap_methods(&self) -> u32 {
        unsafe { nm_sys::nm_setting_802_1x_get_num_eap_methods(self.as_ref().to_glib_none().0) }
    }

    fn get_num_phase2_altsubject_matches(&self) -> u32 {
        unsafe {
            nm_sys::nm_setting_802_1x_get_num_phase2_altsubject_matches(
                self.as_ref().to_glib_none().0,
            )
        }
    }

    #[cfg(any(feature = "v1_22", feature = "dox"))]
    fn get_optional(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_802_1x_get_optional(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_pac_file(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_pac_file(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_password(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_password(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_password_flags(&self) -> SettingSecretFlags {
        unsafe {
            from_glib(nm_sys::nm_setting_802_1x_get_password_flags(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_password_raw(&self) -> Option<glib::Bytes> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_password_raw(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_password_raw_flags(&self) -> SettingSecretFlags {
        unsafe {
            from_glib(nm_sys::nm_setting_802_1x_get_password_raw_flags(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn get_phase1_auth_flags(&self) -> Setting8021xAuthFlags {
        unsafe {
            from_glib(nm_sys::nm_setting_802_1x_get_phase1_auth_flags(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_phase1_fast_provisioning(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_phase1_fast_provisioning(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_phase1_peaplabel(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_phase1_peaplabel(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_phase1_peapver(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_phase1_peapver(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_phase2_altsubject_match(&self, i: u32) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_phase2_altsubject_match(
                self.as_ref().to_glib_none().0,
                i,
            ))
        }
    }

    fn get_phase2_auth(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_phase2_auth(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_phase2_autheap(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_phase2_autheap(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_phase2_ca_cert_blob(&self) -> Option<glib::Bytes> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_phase2_ca_cert_blob(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn get_phase2_ca_cert_password(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_phase2_ca_cert_password(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn get_phase2_ca_cert_password_flags(&self) -> SettingSecretFlags {
        unsafe {
            from_glib(nm_sys::nm_setting_802_1x_get_phase2_ca_cert_password_flags(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_phase2_ca_cert_path(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_phase2_ca_cert_path(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_phase2_ca_cert_scheme(&self) -> Setting8021xCKScheme {
        unsafe {
            from_glib(nm_sys::nm_setting_802_1x_get_phase2_ca_cert_scheme(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_6", feature = "dox"))]
    fn get_phase2_ca_cert_uri(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_phase2_ca_cert_uri(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_phase2_ca_path(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_phase2_ca_path(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_phase2_client_cert_blob(&self) -> Option<glib::Bytes> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_phase2_client_cert_blob(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn get_phase2_client_cert_password(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_phase2_client_cert_password(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn get_phase2_client_cert_password_flags(&self) -> SettingSecretFlags {
        unsafe {
            from_glib(
                nm_sys::nm_setting_802_1x_get_phase2_client_cert_password_flags(
                    self.as_ref().to_glib_none().0,
                ),
            )
        }
    }

    fn get_phase2_client_cert_path(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_phase2_client_cert_path(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_phase2_client_cert_scheme(&self) -> Setting8021xCKScheme {
        unsafe {
            from_glib(nm_sys::nm_setting_802_1x_get_phase2_client_cert_scheme(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_6", feature = "dox"))]
    fn get_phase2_client_cert_uri(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_phase2_client_cert_uri(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_24", feature = "dox"))]
    fn get_phase2_domain_match(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_phase2_domain_match(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn get_phase2_domain_suffix_match(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_phase2_domain_suffix_match(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_phase2_private_key_blob(&self) -> Option<glib::Bytes> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_phase2_private_key_blob(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_phase2_private_key_format(&self) -> Setting8021xCKFormat {
        unsafe {
            from_glib(nm_sys::nm_setting_802_1x_get_phase2_private_key_format(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_phase2_private_key_password(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_phase2_private_key_password(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_phase2_private_key_password_flags(&self) -> SettingSecretFlags {
        unsafe {
            from_glib(
                nm_sys::nm_setting_802_1x_get_phase2_private_key_password_flags(
                    self.as_ref().to_glib_none().0,
                ),
            )
        }
    }

    fn get_phase2_private_key_path(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_phase2_private_key_path(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_phase2_private_key_scheme(&self) -> Setting8021xCKScheme {
        unsafe {
            from_glib(nm_sys::nm_setting_802_1x_get_phase2_private_key_scheme(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_6", feature = "dox"))]
    fn get_phase2_private_key_uri(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_phase2_private_key_uri(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_phase2_subject_match(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_phase2_subject_match(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_pin(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_pin(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_pin_flags(&self) -> SettingSecretFlags {
        unsafe {
            from_glib(nm_sys::nm_setting_802_1x_get_pin_flags(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_private_key_blob(&self) -> Option<glib::Bytes> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_private_key_blob(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_private_key_format(&self) -> Setting8021xCKFormat {
        unsafe {
            from_glib(nm_sys::nm_setting_802_1x_get_private_key_format(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_private_key_password(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_private_key_password(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_private_key_password_flags(&self) -> SettingSecretFlags {
        unsafe {
            from_glib(nm_sys::nm_setting_802_1x_get_private_key_password_flags(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_private_key_path(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_private_key_path(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_private_key_scheme(&self) -> Setting8021xCKScheme {
        unsafe {
            from_glib(nm_sys::nm_setting_802_1x_get_private_key_scheme(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_6", feature = "dox"))]
    fn get_private_key_uri(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_private_key_uri(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_subject_match(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_setting_802_1x_get_subject_match(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_system_ca_certs(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_802_1x_get_system_ca_certs(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn remove_altsubject_match(&self, i: u32) {
        unsafe {
            nm_sys::nm_setting_802_1x_remove_altsubject_match(self.as_ref().to_glib_none().0, i);
        }
    }

    fn remove_altsubject_match_by_value(&self, altsubject_match: &str) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_802_1x_remove_altsubject_match_by_value(
                self.as_ref().to_glib_none().0,
                altsubject_match.to_glib_none().0,
            ))
        }
    }

    fn remove_eap_method(&self, i: u32) {
        unsafe {
            nm_sys::nm_setting_802_1x_remove_eap_method(self.as_ref().to_glib_none().0, i);
        }
    }

    fn remove_eap_method_by_value(&self, eap: &str) -> bool {
        unsafe {
            from_glib(nm_sys::nm_setting_802_1x_remove_eap_method_by_value(
                self.as_ref().to_glib_none().0,
                eap.to_glib_none().0,
            ))
        }
    }

    fn remove_phase2_altsubject_match(&self, i: u32) {
        unsafe {
            nm_sys::nm_setting_802_1x_remove_phase2_altsubject_match(
                self.as_ref().to_glib_none().0,
                i,
            );
        }
    }

    fn remove_phase2_altsubject_match_by_value(&self, phase2_altsubject_match: &str) -> bool {
        unsafe {
            from_glib(
                nm_sys::nm_setting_802_1x_remove_phase2_altsubject_match_by_value(
                    self.as_ref().to_glib_none().0,
                    phase2_altsubject_match.to_glib_none().0,
                ),
            )
        }
    }

    fn get_property_altsubject_matches(&self) -> Vec<GString> {
        unsafe {
            let mut value = Value::from_type(<Vec<GString> as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"altsubject-matches\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `altsubject-matches` getter")
                .unwrap()
        }
    }

    fn set_property_altsubject_matches(&self, altsubject_matches: &[&str]) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"altsubject-matches\0".as_ptr() as *const _,
                Value::from(altsubject_matches).to_glib_none().0,
            );
        }
    }

    fn set_property_anonymous_identity(&self, anonymous_identity: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"anonymous-identity\0".as_ptr() as *const _,
                Value::from(anonymous_identity).to_glib_none().0,
            );
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn set_property_auth_timeout(&self, auth_timeout: i32) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"auth-timeout\0".as_ptr() as *const _,
                Value::from(&auth_timeout).to_glib_none().0,
            );
        }
    }

    fn get_property_ca_cert(&self) -> Option<glib::Bytes> {
        unsafe {
            let mut value = Value::from_type(<glib::Bytes as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"ca-cert\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `ca-cert` getter")
        }
    }

    fn set_property_ca_cert(&self, ca_cert: Option<&glib::Bytes>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"ca-cert\0".as_ptr() as *const _,
                Value::from(ca_cert).to_glib_none().0,
            );
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn set_property_ca_cert_password(&self, ca_cert_password: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"ca-cert-password\0".as_ptr() as *const _,
                Value::from(ca_cert_password).to_glib_none().0,
            );
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn set_property_ca_cert_password_flags(&self, ca_cert_password_flags: SettingSecretFlags) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"ca-cert-password-flags\0".as_ptr() as *const _,
                Value::from(&ca_cert_password_flags).to_glib_none().0,
            );
        }
    }

    fn set_property_ca_path(&self, ca_path: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"ca-path\0".as_ptr() as *const _,
                Value::from(ca_path).to_glib_none().0,
            );
        }
    }

    fn get_property_client_cert(&self) -> Option<glib::Bytes> {
        unsafe {
            let mut value = Value::from_type(<glib::Bytes as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"client-cert\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `client-cert` getter")
        }
    }

    fn set_property_client_cert(&self, client_cert: Option<&glib::Bytes>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"client-cert\0".as_ptr() as *const _,
                Value::from(client_cert).to_glib_none().0,
            );
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn set_property_client_cert_password(&self, client_cert_password: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"client-cert-password\0".as_ptr() as *const _,
                Value::from(client_cert_password).to_glib_none().0,
            );
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn set_property_client_cert_password_flags(
        &self,
        client_cert_password_flags: SettingSecretFlags,
    ) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"client-cert-password-flags\0".as_ptr() as *const _,
                Value::from(&client_cert_password_flags).to_glib_none().0,
            );
        }
    }

    #[cfg(any(feature = "v1_24", feature = "dox"))]
    fn set_property_domain_match(&self, domain_match: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"domain-match\0".as_ptr() as *const _,
                Value::from(domain_match).to_glib_none().0,
            );
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn set_property_domain_suffix_match(&self, domain_suffix_match: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"domain-suffix-match\0".as_ptr() as *const _,
                Value::from(domain_suffix_match).to_glib_none().0,
            );
        }
    }

    fn get_property_eap(&self) -> Vec<GString> {
        unsafe {
            let mut value = Value::from_type(<Vec<GString> as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"eap\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `eap` getter")
                .unwrap()
        }
    }

    fn set_property_eap(&self, eap: &[&str]) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"eap\0".as_ptr() as *const _,
                Value::from(eap).to_glib_none().0,
            );
        }
    }

    fn set_property_identity(&self, identity: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"identity\0".as_ptr() as *const _,
                Value::from(identity).to_glib_none().0,
            );
        }
    }

    #[cfg(any(feature = "v1_22", feature = "dox"))]
    fn set_property_optional(&self, optional: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"optional\0".as_ptr() as *const _,
                Value::from(&optional).to_glib_none().0,
            );
        }
    }

    fn set_property_pac_file(&self, pac_file: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"pac-file\0".as_ptr() as *const _,
                Value::from(pac_file).to_glib_none().0,
            );
        }
    }

    fn set_property_password(&self, password: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"password\0".as_ptr() as *const _,
                Value::from(password).to_glib_none().0,
            );
        }
    }

    fn set_property_password_flags(&self, password_flags: SettingSecretFlags) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"password-flags\0".as_ptr() as *const _,
                Value::from(&password_flags).to_glib_none().0,
            );
        }
    }

    fn set_property_password_raw(&self, password_raw: Option<&glib::Bytes>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"password-raw\0".as_ptr() as *const _,
                Value::from(password_raw).to_glib_none().0,
            );
        }
    }

    fn set_property_password_raw_flags(&self, password_raw_flags: SettingSecretFlags) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"password-raw-flags\0".as_ptr() as *const _,
                Value::from(&password_raw_flags).to_glib_none().0,
            );
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn set_property_phase1_auth_flags(&self, phase1_auth_flags: u32) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"phase1-auth-flags\0".as_ptr() as *const _,
                Value::from(&phase1_auth_flags).to_glib_none().0,
            );
        }
    }

    fn set_property_phase1_fast_provisioning(&self, phase1_fast_provisioning: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"phase1-fast-provisioning\0".as_ptr() as *const _,
                Value::from(phase1_fast_provisioning).to_glib_none().0,
            );
        }
    }

    fn set_property_phase1_peaplabel(&self, phase1_peaplabel: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"phase1-peaplabel\0".as_ptr() as *const _,
                Value::from(phase1_peaplabel).to_glib_none().0,
            );
        }
    }

    fn set_property_phase1_peapver(&self, phase1_peapver: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"phase1-peapver\0".as_ptr() as *const _,
                Value::from(phase1_peapver).to_glib_none().0,
            );
        }
    }

    fn get_property_phase2_altsubject_matches(&self) -> Vec<GString> {
        unsafe {
            let mut value = Value::from_type(<Vec<GString> as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"phase2-altsubject-matches\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `phase2-altsubject-matches` getter")
                .unwrap()
        }
    }

    fn set_property_phase2_altsubject_matches(&self, phase2_altsubject_matches: &[&str]) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"phase2-altsubject-matches\0".as_ptr() as *const _,
                Value::from(phase2_altsubject_matches).to_glib_none().0,
            );
        }
    }

    fn set_property_phase2_auth(&self, phase2_auth: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"phase2-auth\0".as_ptr() as *const _,
                Value::from(phase2_auth).to_glib_none().0,
            );
        }
    }

    fn set_property_phase2_autheap(&self, phase2_autheap: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"phase2-autheap\0".as_ptr() as *const _,
                Value::from(phase2_autheap).to_glib_none().0,
            );
        }
    }

    fn get_property_phase2_ca_cert(&self) -> Option<glib::Bytes> {
        unsafe {
            let mut value = Value::from_type(<glib::Bytes as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"phase2-ca-cert\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `phase2-ca-cert` getter")
        }
    }

    fn set_property_phase2_ca_cert(&self, phase2_ca_cert: Option<&glib::Bytes>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"phase2-ca-cert\0".as_ptr() as *const _,
                Value::from(phase2_ca_cert).to_glib_none().0,
            );
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn set_property_phase2_ca_cert_password(&self, phase2_ca_cert_password: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"phase2-ca-cert-password\0".as_ptr() as *const _,
                Value::from(phase2_ca_cert_password).to_glib_none().0,
            );
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn set_property_phase2_ca_cert_password_flags(
        &self,
        phase2_ca_cert_password_flags: SettingSecretFlags,
    ) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"phase2-ca-cert-password-flags\0".as_ptr() as *const _,
                Value::from(&phase2_ca_cert_password_flags).to_glib_none().0,
            );
        }
    }

    fn set_property_phase2_ca_path(&self, phase2_ca_path: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"phase2-ca-path\0".as_ptr() as *const _,
                Value::from(phase2_ca_path).to_glib_none().0,
            );
        }
    }

    fn get_property_phase2_client_cert(&self) -> Option<glib::Bytes> {
        unsafe {
            let mut value = Value::from_type(<glib::Bytes as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"phase2-client-cert\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `phase2-client-cert` getter")
        }
    }

    fn set_property_phase2_client_cert(&self, phase2_client_cert: Option<&glib::Bytes>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"phase2-client-cert\0".as_ptr() as *const _,
                Value::from(phase2_client_cert).to_glib_none().0,
            );
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn set_property_phase2_client_cert_password(&self, phase2_client_cert_password: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"phase2-client-cert-password\0".as_ptr() as *const _,
                Value::from(phase2_client_cert_password).to_glib_none().0,
            );
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn set_property_phase2_client_cert_password_flags(
        &self,
        phase2_client_cert_password_flags: SettingSecretFlags,
    ) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"phase2-client-cert-password-flags\0".as_ptr() as *const _,
                Value::from(&phase2_client_cert_password_flags)
                    .to_glib_none()
                    .0,
            );
        }
    }

    #[cfg(any(feature = "v1_24", feature = "dox"))]
    fn set_property_phase2_domain_match(&self, phase2_domain_match: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"phase2-domain-match\0".as_ptr() as *const _,
                Value::from(phase2_domain_match).to_glib_none().0,
            );
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn set_property_phase2_domain_suffix_match(&self, phase2_domain_suffix_match: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"phase2-domain-suffix-match\0".as_ptr() as *const _,
                Value::from(phase2_domain_suffix_match).to_glib_none().0,
            );
        }
    }

    fn get_property_phase2_private_key(&self) -> Option<glib::Bytes> {
        unsafe {
            let mut value = Value::from_type(<glib::Bytes as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"phase2-private-key\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `phase2-private-key` getter")
        }
    }

    fn set_property_phase2_private_key(&self, phase2_private_key: Option<&glib::Bytes>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"phase2-private-key\0".as_ptr() as *const _,
                Value::from(phase2_private_key).to_glib_none().0,
            );
        }
    }

    fn set_property_phase2_private_key_password(&self, phase2_private_key_password: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"phase2-private-key-password\0".as_ptr() as *const _,
                Value::from(phase2_private_key_password).to_glib_none().0,
            );
        }
    }

    fn set_property_phase2_private_key_password_flags(
        &self,
        phase2_private_key_password_flags: SettingSecretFlags,
    ) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"phase2-private-key-password-flags\0".as_ptr() as *const _,
                Value::from(&phase2_private_key_password_flags)
                    .to_glib_none()
                    .0,
            );
        }
    }

    fn set_property_phase2_subject_match(&self, phase2_subject_match: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"phase2-subject-match\0".as_ptr() as *const _,
                Value::from(phase2_subject_match).to_glib_none().0,
            );
        }
    }

    fn set_property_pin(&self, pin: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"pin\0".as_ptr() as *const _,
                Value::from(pin).to_glib_none().0,
            );
        }
    }

    fn set_property_pin_flags(&self, pin_flags: SettingSecretFlags) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"pin-flags\0".as_ptr() as *const _,
                Value::from(&pin_flags).to_glib_none().0,
            );
        }
    }

    fn get_property_private_key(&self) -> Option<glib::Bytes> {
        unsafe {
            let mut value = Value::from_type(<glib::Bytes as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"private-key\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `private-key` getter")
        }
    }

    fn set_property_private_key(&self, private_key: Option<&glib::Bytes>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"private-key\0".as_ptr() as *const _,
                Value::from(private_key).to_glib_none().0,
            );
        }
    }

    fn set_property_private_key_password(&self, private_key_password: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"private-key-password\0".as_ptr() as *const _,
                Value::from(private_key_password).to_glib_none().0,
            );
        }
    }

    fn set_property_private_key_password_flags(
        &self,
        private_key_password_flags: SettingSecretFlags,
    ) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"private-key-password-flags\0".as_ptr() as *const _,
                Value::from(&private_key_password_flags).to_glib_none().0,
            );
        }
    }

    fn set_property_subject_match(&self, subject_match: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"subject-match\0".as_ptr() as *const _,
                Value::from(subject_match).to_glib_none().0,
            );
        }
    }

    fn set_property_system_ca_certs(&self, system_ca_certs: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"system-ca-certs\0".as_ptr() as *const _,
                Value::from(&system_ca_certs).to_glib_none().0,
            );
        }
    }

    fn connect_property_altsubject_matches_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_altsubject_matches_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::altsubject-matches\0".as_ptr() as *const _,
                Some(transmute(
                    notify_altsubject_matches_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_anonymous_identity_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_anonymous_identity_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::anonymous-identity\0".as_ptr() as *const _,
                Some(transmute(
                    notify_anonymous_identity_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn connect_property_auth_timeout_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_auth_timeout_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::auth-timeout\0".as_ptr() as *const _,
                Some(transmute(
                    notify_auth_timeout_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_ca_cert_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ca_cert_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::ca-cert\0".as_ptr() as *const _,
                Some(transmute(notify_ca_cert_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn connect_property_ca_cert_password_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_ca_cert_password_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::ca-cert-password\0".as_ptr() as *const _,
                Some(transmute(
                    notify_ca_cert_password_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn connect_property_ca_cert_password_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_ca_cert_password_flags_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::ca-cert-password-flags\0".as_ptr() as *const _,
                Some(transmute(
                    notify_ca_cert_password_flags_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_ca_path_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ca_path_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::ca-path\0".as_ptr() as *const _,
                Some(transmute(notify_ca_path_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_client_cert_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_client_cert_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::client-cert\0".as_ptr() as *const _,
                Some(transmute(notify_client_cert_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn connect_property_client_cert_password_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_client_cert_password_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::client-cert-password\0".as_ptr() as *const _,
                Some(transmute(
                    notify_client_cert_password_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn connect_property_client_cert_password_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_client_cert_password_flags_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::client-cert-password-flags\0".as_ptr() as *const _,
                Some(transmute(
                    notify_client_cert_password_flags_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_24", feature = "dox"))]
    fn connect_property_domain_match_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_domain_match_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::domain-match\0".as_ptr() as *const _,
                Some(transmute(
                    notify_domain_match_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn connect_property_domain_suffix_match_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_domain_suffix_match_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::domain-suffix-match\0".as_ptr() as *const _,
                Some(transmute(
                    notify_domain_suffix_match_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_eap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_eap_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::eap\0".as_ptr() as *const _,
                Some(transmute(notify_eap_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_identity_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_identity_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::identity\0".as_ptr() as *const _,
                Some(transmute(notify_identity_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_22", feature = "dox"))]
    fn connect_property_optional_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_optional_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::optional\0".as_ptr() as *const _,
                Some(transmute(notify_optional_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_pac_file_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_pac_file_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::pac-file\0".as_ptr() as *const _,
                Some(transmute(notify_pac_file_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_password_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_password_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::password\0".as_ptr() as *const _,
                Some(transmute(notify_password_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_password_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_password_flags_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::password-flags\0".as_ptr() as *const _,
                Some(transmute(
                    notify_password_flags_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_password_raw_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_password_raw_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::password-raw\0".as_ptr() as *const _,
                Some(transmute(
                    notify_password_raw_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_password_raw_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_password_raw_flags_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::password-raw-flags\0".as_ptr() as *const _,
                Some(transmute(
                    notify_password_raw_flags_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn connect_property_phase1_auth_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase1_auth_flags_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::phase1-auth-flags\0".as_ptr() as *const _,
                Some(transmute(
                    notify_phase1_auth_flags_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_phase1_fast_provisioning_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase1_fast_provisioning_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::phase1-fast-provisioning\0".as_ptr() as *const _,
                Some(transmute(
                    notify_phase1_fast_provisioning_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_phase1_peaplabel_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase1_peaplabel_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::phase1-peaplabel\0".as_ptr() as *const _,
                Some(transmute(
                    notify_phase1_peaplabel_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_phase1_peapver_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase1_peapver_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::phase1-peapver\0".as_ptr() as *const _,
                Some(transmute(
                    notify_phase1_peapver_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_phase2_altsubject_matches_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_altsubject_matches_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::phase2-altsubject-matches\0".as_ptr() as *const _,
                Some(transmute(
                    notify_phase2_altsubject_matches_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_phase2_auth_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_auth_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::phase2-auth\0".as_ptr() as *const _,
                Some(transmute(notify_phase2_auth_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_phase2_autheap_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_autheap_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::phase2-autheap\0".as_ptr() as *const _,
                Some(transmute(
                    notify_phase2_autheap_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_phase2_ca_cert_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_ca_cert_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::phase2-ca-cert\0".as_ptr() as *const _,
                Some(transmute(
                    notify_phase2_ca_cert_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn connect_property_phase2_ca_cert_password_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_ca_cert_password_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::phase2-ca-cert-password\0".as_ptr() as *const _,
                Some(transmute(
                    notify_phase2_ca_cert_password_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn connect_property_phase2_ca_cert_password_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_ca_cert_password_flags_trampoline<
            P,
            F: Fn(&P) + 'static,
        >(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::phase2-ca-cert-password-flags\0".as_ptr() as *const _,
                Some(transmute(
                    notify_phase2_ca_cert_password_flags_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_phase2_ca_path_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_ca_path_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::phase2-ca-path\0".as_ptr() as *const _,
                Some(transmute(
                    notify_phase2_ca_path_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_phase2_client_cert_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_client_cert_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::phase2-client-cert\0".as_ptr() as *const _,
                Some(transmute(
                    notify_phase2_client_cert_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn connect_property_phase2_client_cert_password_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_client_cert_password_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::phase2-client-cert-password\0".as_ptr() as *const _,
                Some(transmute(
                    notify_phase2_client_cert_password_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_8", feature = "dox"))]
    fn connect_property_phase2_client_cert_password_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_client_cert_password_flags_trampoline<
            P,
            F: Fn(&P) + 'static,
        >(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::phase2-client-cert-password-flags\0".as_ptr() as *const _,
                Some(transmute(
                    notify_phase2_client_cert_password_flags_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_24", feature = "dox"))]
    fn connect_property_phase2_domain_match_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_domain_match_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::phase2-domain-match\0".as_ptr() as *const _,
                Some(transmute(
                    notify_phase2_domain_match_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_2", feature = "dox"))]
    fn connect_property_phase2_domain_suffix_match_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_domain_suffix_match_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::phase2-domain-suffix-match\0".as_ptr() as *const _,
                Some(transmute(
                    notify_phase2_domain_suffix_match_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_phase2_private_key_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_private_key_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::phase2-private-key\0".as_ptr() as *const _,
                Some(transmute(
                    notify_phase2_private_key_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_phase2_private_key_password_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_private_key_password_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::phase2-private-key-password\0".as_ptr() as *const _,
                Some(transmute(
                    notify_phase2_private_key_password_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_phase2_private_key_password_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_private_key_password_flags_trampoline<
            P,
            F: Fn(&P) + 'static,
        >(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::phase2-private-key-password-flags\0".as_ptr() as *const _,
                Some(transmute(
                    notify_phase2_private_key_password_flags_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_phase2_subject_match_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_subject_match_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::phase2-subject-match\0".as_ptr() as *const _,
                Some(transmute(
                    notify_phase2_subject_match_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_pin_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_pin_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::pin\0".as_ptr() as *const _,
                Some(transmute(notify_pin_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_pin_flags_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_pin_flags_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::pin-flags\0".as_ptr() as *const _,
                Some(transmute(notify_pin_flags_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_private_key_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_private_key_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::private-key\0".as_ptr() as *const _,
                Some(transmute(notify_private_key_trampoline::<Self, F> as usize)),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_private_key_password_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_private_key_password_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::private-key-password\0".as_ptr() as *const _,
                Some(transmute(
                    notify_private_key_password_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_private_key_password_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_private_key_password_flags_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::private-key-password-flags\0".as_ptr() as *const _,
                Some(transmute(
                    notify_private_key_password_flags_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_subject_match_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_subject_match_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::subject-match\0".as_ptr() as *const _,
                Some(transmute(
                    notify_subject_match_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_system_ca_certs_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_system_ca_certs_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSetting8021x,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Setting8021x>,
        {
            let f: &F = &*(f as *const F);
            f(&Setting8021x::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::system-ca-certs\0".as_ptr() as *const _,
                Some(transmute(
                    notify_system_ca_certs_trampoline::<Self, F> as usize,
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl fmt::Display for Setting8021x {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Setting8021x")
    }
}
