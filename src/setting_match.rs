// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files
// DO NOT EDIT

use crate::Setting;
#[cfg(any(feature = "v1_32", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_32")))]
use glib::object::Cast;
use glib::object::ObjectType as ObjectType_;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib::ToValue;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem;
use std::mem::transmute;

glib::wrapper! {
    #[doc(alias = "NMSettingMatch")]
    pub struct SettingMatch(Object<ffi::NMSettingMatch, ffi::NMSettingMatchClass>) @extends Setting;

    match fn {
        type_ => || ffi::nm_setting_match_get_type(),
    }
}

impl SettingMatch {
    /// Creates a new [`SettingMatch`][crate::SettingMatch] object with default values.
    ///
    /// # Returns
    ///
    /// the new empty [`SettingMatch`][crate::SettingMatch] object
    ///
    /// Note that this function was present in header files since version 1.14.
    /// But due to a bug the symbol is only exposed and usable since version 1.32.
    /// As workaround, use g_object_new(NM_TYPE_SETTING_MATCH) which works with all
    /// versions since 1.14.
    #[cfg(any(feature = "v1_32", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_32")))]
    #[doc(alias = "nm_setting_match_new")]
    pub fn new() -> SettingMatch {
        unsafe { Setting::from_glib_full(ffi::nm_setting_match_new()).unsafe_cast() }
    }

    /// Adds a new driver to the setting.
    /// ## `driver`
    /// the driver to add
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_match_add_driver")]
    pub fn add_driver(&self, driver: &str) {
        unsafe {
            ffi::nm_setting_match_add_driver(self.to_glib_none().0, driver.to_glib_none().0);
        }
    }

    /// Adds a new interface name to the setting.
    /// ## `interface_name`
    /// the interface name to add
    #[doc(alias = "nm_setting_match_add_interface_name")]
    pub fn add_interface_name(&self, interface_name: &str) {
        unsafe {
            ffi::nm_setting_match_add_interface_name(
                self.to_glib_none().0,
                interface_name.to_glib_none().0,
            );
        }
    }

    /// Adds a new kernel command line argument to the setting.
    /// ## `kernel_command_line`
    /// the kernel command line argument to add
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_match_add_kernel_command_line")]
    pub fn add_kernel_command_line(&self, kernel_command_line: &str) {
        unsafe {
            ffi::nm_setting_match_add_kernel_command_line(
                self.to_glib_none().0,
                kernel_command_line.to_glib_none().0,
            );
        }
    }

    /// Adds a new path to the setting.
    /// ## `path`
    /// the path to add
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_match_add_path")]
    pub fn add_path(&self, path: &str) {
        unsafe {
            ffi::nm_setting_match_add_path(self.to_glib_none().0, path.to_glib_none().0);
        }
    }

    /// Removes all configured drivers.
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_match_clear_drivers")]
    pub fn clear_drivers(&self) {
        unsafe {
            ffi::nm_setting_match_clear_drivers(self.to_glib_none().0);
        }
    }

    /// Removes all configured interface names.
    #[doc(alias = "nm_setting_match_clear_interface_names")]
    pub fn clear_interface_names(&self) {
        unsafe {
            ffi::nm_setting_match_clear_interface_names(self.to_glib_none().0);
        }
    }

    /// Removes all configured kernel command line arguments.
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_match_clear_kernel_command_lines")]
    pub fn clear_kernel_command_lines(&self) {
        unsafe {
            ffi::nm_setting_match_clear_kernel_command_lines(self.to_glib_none().0);
        }
    }

    /// Removes all configured paths.
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_match_clear_paths")]
    pub fn clear_paths(&self) {
        unsafe {
            ffi::nm_setting_match_clear_paths(self.to_glib_none().0);
        }
    }

    /// ## `idx`
    /// index number of the DNS search domain to return
    ///
    /// # Returns
    ///
    /// the driver at index `idx`
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_match_get_driver")]
    #[doc(alias = "get_driver")]
    pub fn driver(&self, idx: u32) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::nm_setting_match_get_driver(self.to_glib_none().0, idx)) }
    }

    /// Returns all the drivers.
    ///
    /// # Returns
    ///
    /// the configured drivers.
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_match_get_drivers")]
    #[doc(alias = "get_drivers")]
    pub fn drivers(&self) -> Vec<glib::GString> {
        unsafe {
            let mut length = mem::MaybeUninit::uninit();
            let ret = FromGlibContainer::from_glib_none_num(
                ffi::nm_setting_match_get_drivers(self.to_glib_none().0, length.as_mut_ptr()),
                length.assume_init() as usize,
            );
            ret
        }
    }

    /// ## `idx`
    /// index number of the DNS search domain to return
    ///
    /// # Returns
    ///
    /// the interface name at index `idx`
    #[doc(alias = "nm_setting_match_get_interface_name")]
    #[doc(alias = "get_interface_name")]
    pub fn interface_name(&self, idx: i32) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::nm_setting_match_get_interface_name(
                self.to_glib_none().0,
                idx,
            ))
        }
    }

    /// Returns all the interface names.
    ///
    /// # Returns
    ///
    /// the NULL terminated list of
    ///  configured interface names.
    ///
    /// Before 1.26, the returned array was not [`None`] terminated and you MUST provide a length.
    #[doc(alias = "nm_setting_match_get_interface_names")]
    #[doc(alias = "get_interface_names")]
    pub fn interface_names(&self) -> Vec<glib::GString> {
        unsafe {
            let mut length = mem::MaybeUninit::uninit();
            let ret = FromGlibContainer::from_glib_none_num(
                ffi::nm_setting_match_get_interface_names(
                    self.to_glib_none().0,
                    length.as_mut_ptr(),
                ),
                length.assume_init() as usize,
            );
            ret
        }
    }

    /// ## `idx`
    /// index number of the kernel command line argument to return
    ///
    /// # Returns
    ///
    /// the kernel command line argument at index `idx`
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_match_get_kernel_command_line")]
    #[doc(alias = "get_kernel_command_line")]
    pub fn kernel_command_line(&self, idx: u32) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::nm_setting_match_get_kernel_command_line(
                self.to_glib_none().0,
                idx,
            ))
        }
    }

    /// Returns all the interface names.
    ///
    /// # Returns
    ///
    /// the configured interface names.
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_match_get_kernel_command_lines")]
    #[doc(alias = "get_kernel_command_lines")]
    pub fn kernel_command_lines(&self) -> Vec<glib::GString> {
        unsafe {
            let mut length = mem::MaybeUninit::uninit();
            let ret = FromGlibContainer::from_glib_none_num(
                ffi::nm_setting_match_get_kernel_command_lines(
                    self.to_glib_none().0,
                    length.as_mut_ptr(),
                ),
                length.assume_init() as usize,
            );
            ret
        }
    }

    ///
    /// # Returns
    ///
    /// the number of configured drivers
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_match_get_num_drivers")]
    #[doc(alias = "get_num_drivers")]
    pub fn num_drivers(&self) -> u32 {
        unsafe { ffi::nm_setting_match_get_num_drivers(self.to_glib_none().0) }
    }

    ///
    /// # Returns
    ///
    /// the number of configured interface names
    #[doc(alias = "nm_setting_match_get_num_interface_names")]
    #[doc(alias = "get_num_interface_names")]
    pub fn num_interface_names(&self) -> u32 {
        unsafe { ffi::nm_setting_match_get_num_interface_names(self.to_glib_none().0) }
    }

    ///
    /// # Returns
    ///
    /// the number of configured kernel command line arguments
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_match_get_num_kernel_command_lines")]
    #[doc(alias = "get_num_kernel_command_lines")]
    pub fn num_kernel_command_lines(&self) -> u32 {
        unsafe { ffi::nm_setting_match_get_num_kernel_command_lines(self.to_glib_none().0) }
    }

    ///
    /// # Returns
    ///
    /// the number of configured paths
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_match_get_num_paths")]
    #[doc(alias = "get_num_paths")]
    pub fn num_paths(&self) -> u32 {
        unsafe { ffi::nm_setting_match_get_num_paths(self.to_glib_none().0) }
    }

    /// ## `idx`
    /// index number of the path to return
    ///
    /// # Returns
    ///
    /// the path at index `idx`
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_match_get_path")]
    #[doc(alias = "get_path")]
    pub fn path(&self, idx: u32) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::nm_setting_match_get_path(self.to_glib_none().0, idx)) }
    }

    /// Returns all the paths.
    ///
    /// # Returns
    ///
    /// the configured paths.
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_match_get_paths")]
    #[doc(alias = "get_paths")]
    pub fn paths(&self) -> Vec<glib::GString> {
        unsafe {
            let mut length = mem::MaybeUninit::uninit();
            let ret = FromGlibContainer::from_glib_none_num(
                ffi::nm_setting_match_get_paths(self.to_glib_none().0, length.as_mut_ptr()),
                length.assume_init() as usize,
            );
            ret
        }
    }

    /// Removes the driver at index `idx`.
    /// ## `idx`
    /// index number of the driver
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_match_remove_driver")]
    pub fn remove_driver(&self, idx: u32) {
        unsafe {
            ffi::nm_setting_match_remove_driver(self.to_glib_none().0, idx);
        }
    }

    /// Removes `driver`.
    /// ## `driver`
    /// the driver to remove
    ///
    /// # Returns
    ///
    /// [`true`] if the driver was found and removed; [`false`] if it was not.
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_match_remove_driver_by_value")]
    pub fn remove_driver_by_value(&self, driver: &str) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_match_remove_driver_by_value(
                self.to_glib_none().0,
                driver.to_glib_none().0,
            ))
        }
    }

    /// Removes the interface name at index `idx`.
    /// ## `idx`
    /// index number of the interface name
    #[doc(alias = "nm_setting_match_remove_interface_name")]
    pub fn remove_interface_name(&self, idx: i32) {
        unsafe {
            ffi::nm_setting_match_remove_interface_name(self.to_glib_none().0, idx);
        }
    }

    /// Removes `interface_name`.
    /// ## `interface_name`
    /// the interface name to remove
    ///
    /// # Returns
    ///
    /// [`true`] if the interface name was found and removed; [`false`] if it was not.
    #[doc(alias = "nm_setting_match_remove_interface_name_by_value")]
    pub fn remove_interface_name_by_value(&self, interface_name: &str) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_match_remove_interface_name_by_value(
                self.to_glib_none().0,
                interface_name.to_glib_none().0,
            ))
        }
    }

    /// Removes the kernel command line argument at index `idx`.
    /// ## `idx`
    /// index number of the kernel command line argument
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_match_remove_kernel_command_line")]
    pub fn remove_kernel_command_line(&self, idx: u32) {
        unsafe {
            ffi::nm_setting_match_remove_kernel_command_line(self.to_glib_none().0, idx);
        }
    }

    /// Removes `kernel_command_line`.
    /// ## `kernel_command_line`
    /// the kernel command line argument name to remove
    ///
    /// # Returns
    ///
    /// [`true`] if the kernel command line argument was found and removed; [`false`] if it was not.
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_match_remove_kernel_command_line_by_value")]
    pub fn remove_kernel_command_line_by_value(&self, kernel_command_line: &str) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_match_remove_kernel_command_line_by_value(
                self.to_glib_none().0,
                kernel_command_line.to_glib_none().0,
            ))
        }
    }

    /// Removes the path at index `idx`.
    /// ## `idx`
    /// index number of the path
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_match_remove_path")]
    pub fn remove_path(&self, idx: u32) {
        unsafe {
            ffi::nm_setting_match_remove_path(self.to_glib_none().0, idx);
        }
    }

    /// Removes `path`.
    /// ## `path`
    /// the path to remove
    ///
    /// # Returns
    ///
    /// [`true`] if the path was found and removed; [`false`] if it was not.
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_match_remove_path_by_value")]
    pub fn remove_path_by_value(&self, path: &str) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_match_remove_path_by_value(
                self.to_glib_none().0,
                path.to_glib_none().0,
            ))
        }
    }

    /// A list of driver names to match. Each element is a shell wildcard pattern.
    ///
    /// See NMSettingMatch:interface-name for how special characters '|', '&',
    /// '!' and '\\' are used for optional and mandatory matches and inverting the
    /// pattern.
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    pub fn set_driver(&self, driver: &[&str]) {
        glib::ObjectExt::set_property(self, "driver", &driver)
    }

    /// A list of interface names to match. Each element is a shell wildcard
    /// pattern.
    ///
    /// An element can be prefixed with a pipe symbol (|) or an ampersand (&).
    /// The former means that the element is optional and the latter means that
    /// it is mandatory. If there are any optional elements, than the match
    /// evaluates to true if at least one of the optional element matches
    /// (logical OR). If there are any mandatory elements, then they all
    /// must match (logical AND). By default, an element is optional. This means
    /// that an element "foo" behaves the same as "|foo". An element can also be inverted
    /// with exclamation mark (!) between the pipe symbol (or the ampersand) and before
    /// the pattern. Note that "!foo" is a shortcut for the mandatory match "&!foo". Finally,
    /// a backslash can be used at the beginning of the element (after the optional special characters)
    /// to escape the start of the pattern. For example, "&\\!a" is an mandatory match for literally "!a".
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
    #[doc(alias = "interface-name")]
    pub fn set_interface_name(&self, interface_name: &[&str]) {
        glib::ObjectExt::set_property(self, "interface-name", &interface_name)
    }

    /// A list of kernel command line arguments to match. This may be used to check
    /// whether a specific kernel command line option is set (or unset, if prefixed with
    /// the exclamation mark). The argument must either be a single word, or
    /// an assignment (i.e. two words, joined by "="). In the former case the kernel
    /// command line is searched for the word appearing as is, or as left hand side
    /// of an assignment. In the latter case, the exact assignment is looked for
    /// with right and left hand side matching. Wildcard patterns are not supported.
    ///
    /// See NMSettingMatch:interface-name for how special characters '|', '&',
    /// '!' and '\\' are used for optional and mandatory matches and inverting the
    /// match.
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "kernel-command-line")]
    pub fn set_kernel_command_line(&self, kernel_command_line: &[&str]) {
        glib::ObjectExt::set_property(self, "kernel-command-line", &kernel_command_line)
    }

    /// A list of paths to match against the ID_PATH udev property of
    /// devices. ID_PATH represents the topological persistent path of a
    /// device. It typically contains a subsystem string (pci, usb, platform,
    /// etc.) and a subsystem-specific identifier.
    ///
    /// For PCI devices the path has the form
    /// "pci-$domain:$bus:$device.$function", where each variable is an
    /// hexadecimal value; for example "pci-0000:0a:00.0".
    ///
    /// The path of a device can be obtained with "udevadm info
    /// /sys/class/net/$dev | grep ID_PATH=" or by looking at the "path"
    /// property exported by NetworkManager ("nmcli -f general.path device
    /// show $dev").
    ///
    /// Each element of the list is a shell wildcard pattern.
    ///
    /// See NMSettingMatch:interface-name for how special characters '|', '&',
    /// '!' and '\\' are used for optional and mandatory matches and inverting the
    /// pattern.
    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    pub fn set_path(&self, path: &[&str]) {
        glib::ObjectExt::set_property(self, "path", &path)
    }

    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "driver")]
    pub fn connect_driver_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_driver_trampoline<F: Fn(&SettingMatch) + 'static>(
            this: *mut ffi::NMSettingMatch,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::driver\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_driver_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_14", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
    #[doc(alias = "interface-name")]
    pub fn connect_interface_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_interface_name_trampoline<F: Fn(&SettingMatch) + 'static>(
            this: *mut ffi::NMSettingMatch,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::interface-name\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_interface_name_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "kernel-command-line")]
    pub fn connect_kernel_command_line_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_kernel_command_line_trampoline<
            F: Fn(&SettingMatch) + 'static,
        >(
            this: *mut ffi::NMSettingMatch,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::kernel-command-line\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_kernel_command_line_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(any(feature = "v1_26", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
    #[doc(alias = "path")]
    pub fn connect_path_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_path_trampoline<F: Fn(&SettingMatch) + 'static>(
            this: *mut ffi::NMSettingMatch,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::path\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_path_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

#[cfg(any(feature = "v1_32", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_32")))]
impl Default for SettingMatch {
    fn default() -> Self {
        Self::new()
    }
}

impl fmt::Display for SettingMatch {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("SettingMatch")
    }
}
