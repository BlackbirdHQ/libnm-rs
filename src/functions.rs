// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files
// DO NOT EDIT

use crate::DeviceWifiCapabilities;
use crate::IPAddress;
use crate::IPRoute;
#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
use crate::SriovVF;
#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
use crate::TCAction;
#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
use crate::TCQdisc;
#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
use crate::TCTfilter;
use crate::UtilsSecurityType;
use crate::WepKeyType;
use crate::_80211ApFlags;
use crate::_80211ApSecurityFlags;
use glib::translate::*;
use std::mem;
use std::ptr;

/// Checks whether `optname` is a valid option name for a coalesce setting.
///
/// `Returns`: [`true`], if `optname` is valid
/// ## `optname`
/// the option name to check
#[cfg(any(feature = "v1_26", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
#[doc(alias = "nm_ethtool_optname_is_coalesce")]
pub fn ethtool_optname_is_coalesce(optname: Option<&str>) -> bool {
    unsafe {
        from_glib(ffi::nm_ethtool_optname_is_coalesce(
            optname.to_glib_none().0,
        ))
    }
}

/// Checks whether `optname` is a valid option name for an offload feature.
///
/// `Returns`: [`true`], if `optname` is valid
/// ## `optname`
/// the option name to check
#[cfg(any(feature = "v1_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
#[doc(alias = "nm_ethtool_optname_is_feature")]
pub fn ethtool_optname_is_feature(optname: Option<&str>) -> bool {
    unsafe { from_glib(ffi::nm_ethtool_optname_is_feature(optname.to_glib_none().0)) }
}

/// Checks whether `optname` is a valid option name for a pause setting.
///
/// `Returns`: [`true`], if `optname` is valid
/// ## `optname`
/// the option name to check
#[cfg(any(feature = "v1_32", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_32")))]
#[doc(alias = "nm_ethtool_optname_is_pause")]
pub fn ethtool_optname_is_pause(optname: Option<&str>) -> bool {
    unsafe { from_glib(ffi::nm_ethtool_optname_is_pause(optname.to_glib_none().0)) }
}

/// Checks whether `optname` is a valid option name for a ring setting.
///
/// `Returns`: [`true`], if `optname` is valid
/// ## `optname`
/// the option name to check
#[cfg(any(feature = "v1_26", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_26")))]
#[doc(alias = "nm_ethtool_optname_is_ring")]
pub fn ethtool_optname_is_ring(optname: Option<&str>) -> bool {
    unsafe { from_glib(ffi::nm_ethtool_optname_is_ring(optname.to_glib_none().0)) }
}

//#[cfg(any(feature = "v1_30", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
//#[doc(alias = "nm_keyfile_read")]
//pub fn keyfile_read(keyfile: &glib::KeyFile, base_dir: &str, handler_flags: KeyfileHandlerFlags, handler: /*Unimplemented*/FnMut(&glib::KeyFile, &Connection, &KeyfileHandlerType, /*Ignored*/KeyfileHandlerData) -> bool, user_data: /*Unimplemented*/Option<Fundamental: Pointer>) -> Result<Connection, glib::Error> {
//    unsafe { TODO: call ffi:nm_keyfile_read() }
//}

//#[cfg(any(feature = "v1_30", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
//#[doc(alias = "nm_keyfile_write")]
//pub fn keyfile_write<P: IsA<Connection>>(connection: &P, handler_flags: KeyfileHandlerFlags, handler: /*Unimplemented*/FnMut(&Connection, &glib::KeyFile, &KeyfileHandlerType, /*Ignored*/KeyfileHandlerData) -> bool, user_data: /*Unimplemented*/Option<Fundamental: Pointer>) -> Result<glib::KeyFile, glib::Error> {
//    unsafe { TODO: call ffi:nm_keyfile_write() }
//}

/// Given a set of device capabilities, and a desired security type to check
/// against, determines whether the combination of device capabilities and
/// desired security type are valid for AP/Hotspot connections.
/// ## `type_`
/// the security type to check device capabilities against,
/// e.g. [`UtilsSecurityType::StaticWep`][crate::UtilsSecurityType::StaticWep]
/// ## `wifi_caps`
/// bitfield of the capabilities of the specific Wi-Fi device, e.g.
/// [`DeviceWifiCapabilities::CIPHER_WEP40`][crate::DeviceWifiCapabilities::CIPHER_WEP40]
///
/// # Returns
///
/// [`true`] if the device capabilities are compatible with the desired
/// `type_`, [`false`] if they are not.
#[doc(alias = "nm_utils_ap_mode_security_valid")]
pub fn utils_ap_mode_security_valid(
    type_: UtilsSecurityType,
    wifi_caps: DeviceWifiCapabilities,
) -> bool {
    unsafe {
        from_glib(ffi::nm_utils_ap_mode_security_valid(
            type_.into_glib(),
            wifi_caps.into_glib(),
        ))
    }
}

/// Convert bonding mode from integer value to descriptive name.
/// See https://www.kernel.org/doc/Documentation/networking/bonding.txt for
/// available modes.
/// ## `mode`
/// bonding mode as a numeric value
///
/// # Returns
///
/// bonding mode string, or NULL on error
#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
#[doc(alias = "nm_utils_bond_mode_int_to_string")]
pub fn utils_bond_mode_int_to_string(mode: i32) -> Option<glib::GString> {
    unsafe { from_glib_none(ffi::nm_utils_bond_mode_int_to_string(mode)) }
}

/// Convert bonding mode from string representation to numeric value.
/// See https://www.kernel.org/doc/Documentation/networking/bonding.txt for
/// available modes.
/// The `mode` string can be either a descriptive name or a number (as string).
/// ## `mode`
/// bonding mode as string
///
/// # Returns
///
/// numeric bond mode, or -1 on error
#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
#[doc(alias = "nm_utils_bond_mode_string_to_int")]
pub fn utils_bond_mode_string_to_int(mode: &str) -> i32 {
    unsafe { ffi::nm_utils_bond_mode_string_to_int(mode.to_glib_none().0) }
}

/// Determines if a connection of type `virtual_type` can (in the
/// general case) work with connections of type `other_type`.
///
/// If `virtual_type` is `NM_TYPE_SETTING_VLAN`, then this checks if
/// `other_type` is a valid type for the parent of a VLAN.
///
/// If `virtual_type` is a "master" type (eg, `NM_TYPE_SETTING_BRIDGE`),
/// then this checks if `other_type` is a valid type for a slave of that
/// master.
///
/// Note that even if this returns [`true`] it is not guaranteed that
/// `<emphasis>`every`</emphasis>` connection of type `other_type` is
/// compatible with `virtual_type`; it may depend on the exact
/// configuration of the two connections, or on the capabilities of an
/// underlying device driver.
/// ## `virtual_type`
/// a virtual connection type
/// ## `other_type`
/// a connection type to test against `virtual_type`
///
/// # Returns
///
/// [`true`] or [`false`]
#[doc(alias = "nm_utils_check_virtual_device_compatibility")]
pub fn utils_check_virtual_device_compatibility(
    virtual_type: glib::types::Type,
    other_type: glib::types::Type,
) -> bool {
    unsafe {
        from_glib(ffi::nm_utils_check_virtual_device_compatibility(
            virtual_type.into_glib(),
            other_type.into_glib(),
        ))
    }
}

/// Returns the list of possible values for a given enum.
/// ## `type_`
/// the `GType` of the enum
/// ## `from`
/// the first element to be returned
/// ## `to`
/// the last element to be returned
///
/// # Returns
///
/// a NULL-terminated dynamically-allocated array of static strings
/// or [`None`] on error
#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
#[doc(alias = "nm_utils_enum_get_values")]
pub fn utils_enum_get_values(type_: glib::types::Type, from: i32, to: i32) -> Vec<glib::GString> {
    unsafe {
        FromGlibPtrContainer::from_glib_container(ffi::nm_utils_enum_get_values(
            type_.into_glib(),
            from,
            to,
        ))
    }
}

/// Converts an enum value to its string representation. If the enum is a
/// `G_TYPE_FLAGS` the function returns a comma-separated list of matching values.
/// If the value has no corresponding string representation, it is converted
/// to a number. For enums it is converted to a decimal number, for flags
/// to an (unsigned) hex number.
/// ## `type_`
/// the `GType` of the enum
/// ## `value`
/// the value to be translated
///
/// # Returns
///
/// a newly allocated string or [`None`]
#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
#[doc(alias = "nm_utils_enum_to_str")]
pub fn utils_enum_to_str(type_: glib::types::Type, value: i32) -> Option<glib::GString> {
    unsafe { from_glib_full(ffi::nm_utils_enum_to_str(type_.into_glib(), value)) }
}

/// This function does a quick printable character conversion of the SSID, simply
/// replacing embedded NULLs and non-printable characters with the hexadecimal
/// representation of that character. Intended for debugging only, should not
/// be used for display of SSIDs.
/// ## `ssid`
/// pointer to a buffer containing the SSID data
///
/// # Returns
///
/// pointer to the escaped SSID, which uses an internal static buffer
/// and will be overwritten by subsequent calls to this function
#[doc(alias = "nm_utils_escape_ssid")]
pub fn utils_escape_ssid(ssid: &[u8]) -> Option<glib::GString> {
    let len = ssid.len() as usize;
    unsafe { from_glib_none(ffi::nm_utils_escape_ssid(ssid.to_glib_none().0, len)) }
}

/// Tests if `filename` has a valid extension for an X.509 certificate file
/// (".cer", ".crt", ".der", or ".pem"), and contains a certificate in a format
/// recognized by NetworkManager.
/// ## `filename`
/// name of the file to test
///
/// # Returns
///
/// [`true`] if the file is a certificate, [`false`] if it is not
#[doc(alias = "nm_utils_file_is_certificate")]
pub fn utils_file_is_certificate(filename: &str) -> bool {
    unsafe { from_glib(ffi::nm_utils_file_is_certificate(filename.to_glib_none().0)) }
}

/// Tests if `filename` is a PKCS#<!-- -->12 file.
/// ## `filename`
/// name of the file to test
///
/// # Returns
///
/// [`true`] if the file is PKCS#<!-- -->12, [`false`] if it is not
#[doc(alias = "nm_utils_file_is_pkcs12")]
pub fn utils_file_is_pkcs12(filename: &str) -> bool {
    unsafe { from_glib(ffi::nm_utils_file_is_pkcs12(filename.to_glib_none().0)) }
}

/// Tests if `filename` has a valid extension for an X.509 private key file
/// (".der", ".key", ".pem", or ".p12"), and contains a private key in a format
/// recognized by NetworkManager.
/// ## `filename`
/// name of the file to test
///
/// # Returns
///
/// [`true`] if the file is a private key, [`false`] if it is not
///
/// ## `out_encrypted`
/// on return, whether the file is encrypted
#[doc(alias = "nm_utils_file_is_private_key")]
pub fn utils_file_is_private_key(filename: &str) -> Option<bool> {
    unsafe {
        let mut out_encrypted = mem::MaybeUninit::uninit();
        let ret = from_glib(ffi::nm_utils_file_is_private_key(
            filename.to_glib_none().0,
            out_encrypted.as_mut_ptr(),
        ));
        let out_encrypted = out_encrypted.assume_init();
        if ret {
            Some(from_glib(out_encrypted))
        } else {
            None
        }
    }
}

//#[doc(alias = "nm_utils_format_variant_attributes")]
//pub fn utils_format_variant_attributes(attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 25 }/TypeId { ns_id: 0, id: 25 }, attr_separator: glib::Char, key_value_separator: glib::Char) -> Option<glib::GString> {
//    unsafe { TODO: call ffi:nm_utils_format_variant_attributes() }
//}

#[doc(alias = "nm_utils_get_timestamp_msec")]
pub fn utils_get_timestamp_msec() -> i64 {
    unsafe { ffi::nm_utils_get_timestamp_msec() }
}

/// Converts a hexadecimal string `hex` into an array of bytes. The optional
/// separator ':' may be used between single or pairs of hexadecimal characters,
/// eg "00:11" or "0:1". Any "0x" at the beginning of `hex` is ignored. `hex`
/// may not start or end with ':'.
/// ## `hex`
/// a string of hexadecimal characters with optional ':' separators
///
/// # Returns
///
/// the converted bytes, or [`None`] on error
#[doc(alias = "nm_utils_hexstr2bin")]
pub fn utils_hexstr2bin(hex: &str) -> Option<glib::Bytes> {
    unsafe { from_glib_full(ffi::nm_utils_hexstr2bin(hex.to_glib_none().0)) }
}

/// Parses `asc` and converts it to binary form in a [`glib::ByteArray`][crate::glib::ByteArray]. See
/// `nm_utils_hwaddr_aton()` if you don't want a [`glib::ByteArray`][crate::glib::ByteArray].
/// ## `asc`
/// the ASCII representation of a hardware address
/// ## `length`
/// the expected length in bytes of the result
///
/// # Returns
///
/// a new [`glib::ByteArray`][crate::glib::ByteArray], or [`None`] if `asc` couldn't
/// be parsed
#[doc(alias = "nm_utils_hwaddr_atoba")]
pub fn utils_hwaddr_atoba(asc: &str) -> Option<glib::ByteArray> {
    let length = asc.len() as usize;
    unsafe { from_glib_full(ffi::nm_utils_hwaddr_atoba(asc.to_glib_none().0, length)) }
}

/// Parses `asc` to see if it is a valid hardware address of the given
/// length, and if so, returns it in canonical form (uppercase, with
/// leading 0s as needed, and with colons rather than hyphens).
/// ## `asc`
/// the ASCII representation of a hardware address
/// ## `length`
/// the length of address that `asc` is expected to convert to
///  (or -1 to accept any length up to `NM_UTILS_HWADDR_LEN_MAX`)
///
/// # Returns
///
/// the canonicalized address if `asc` appears to
///  be a valid hardware address of the indicated length, [`None`] if not.
#[doc(alias = "nm_utils_hwaddr_canonical")]
pub fn utils_hwaddr_canonical(asc: &str) -> Option<glib::GString> {
    let length = asc.len() as isize;
    unsafe { from_glib_full(ffi::nm_utils_hwaddr_canonical(asc.to_glib_none().0, length)) }
}

/// Returns the length in octets of a hardware address of type `type_`.
///
/// Before 1.28, it was an error to call this function with any value other than
/// `<literal>`ARPHRD_ETHER`</literal>` or `<literal>`ARPHRD_INFINIBAND`</literal>`.
/// ## `type_`
/// the type of address; either `<literal>`ARPHRD_ETHER`</literal>` or
/// `<literal>`ARPHRD_INFINIBAND`</literal>`
///
/// # Returns
///
/// the length or zero if the type is unrecognized.
#[doc(alias = "nm_utils_hwaddr_len")]
pub fn utils_hwaddr_len(type_: i32) -> usize {
    unsafe { ffi::nm_utils_hwaddr_len(type_) }
}

//#[doc(alias = "nm_utils_hwaddr_matches")]
//pub fn utils_hwaddr_matches(hwaddr1: /*Unimplemented*/Option<Fundamental: Pointer>, hwaddr1_len: isize, hwaddr2: /*Unimplemented*/Option<Fundamental: Pointer>, hwaddr2_len: isize) -> bool {
//    unsafe { TODO: call ffi:nm_utils_hwaddr_matches() }
//}

/// Parses `asc` to see if it is a valid hardware address of the given
/// length.
/// ## `asc`
/// the ASCII representation of a hardware address
/// ## `length`
/// the length of address that `asc` is expected to convert to
///  (or -1 to accept any length up to `NM_UTILS_HWADDR_LEN_MAX`)
///
/// # Returns
///
/// [`true`] if `asc` appears to be a valid hardware address
///  of the indicated length, [`false`] if not.
#[doc(alias = "nm_utils_hwaddr_valid")]
pub fn utils_hwaddr_valid(asc: &str) -> bool {
    let length = asc.len() as isize;
    unsafe { from_glib(ffi::nm_utils_hwaddr_valid(asc.to_glib_none().0, length)) }
}

/// Validate the network interface name.
///
/// # Deprecated since 1.6
///
/// Use [`utils_is_valid_iface_name()`][crate::utils_is_valid_iface_name()] instead, with better error reporting.
/// ## `name`
/// Name of interface
///
/// # Returns
///
/// [`true`] if interface name is valid, otherwise [`false`] is returned.
///
/// Before 1.20, this function did not accept [`None`] as `name` argument. If you
///  want to run against older versions of libnm, don't pass [`None`].
#[cfg_attr(feature = "v1_6", deprecated = "Since 1.6")]
#[doc(alias = "nm_utils_iface_valid_name")]
pub fn utils_iface_valid_name(name: Option<&str>) -> bool {
    unsafe { from_glib(ffi::nm_utils_iface_valid_name(name.to_glib_none().0)) }
}

/// Wrapper for inet_ntop.
/// ## `inaddr`
/// the address that should be converted to string.
/// ## `dst`
/// the destination buffer, it must contain at least
///  `<literal>`INET_ADDRSTRLEN`</literal>` or `NM_UTILS_INET_ADDRSTRLEN`
///  characters. If set to [`None`], it will return a pointer to an internal, static
///  buffer (shared with [`utils_inet6_ntop()`][crate::utils_inet6_ntop()]). Beware, that the internal
///  buffer will be overwritten with ever new call of [`utils_inet4_ntop()`][crate::utils_inet4_ntop()] or
///  [`utils_inet6_ntop()`][crate::utils_inet6_ntop()] that does not provide its own `dst` buffer. Since
///  1.28, the internal buffer is thread local and thus thread safe. Before
///  it was not thread safe. When in doubt, pass your own
///  `dst` buffer to avoid these issues.
///
/// # Returns
///
/// the input buffer `dst`, or a pointer to an
///  internal, static buffer. This function cannot fail.
#[doc(alias = "nm_utils_inet4_ntop")]
pub fn utils_inet4_ntop(inaddr: u32, dst: &str) -> Option<glib::GString> {
    unsafe { from_glib_none(ffi::nm_utils_inet4_ntop(inaddr, dst.to_glib_none().0)) }
}

/// Wrapper for inet_ntop.
/// ## `dst`
/// the destination buffer, it must contain at least
///  `<literal>`INET6_ADDRSTRLEN`</literal>` or `NM_UTILS_INET_ADDRSTRLEN`
///  characters. If set to [`None`], it will return a pointer to an internal, static
///  buffer (shared with [`utils_inet4_ntop()`][crate::utils_inet4_ntop()]). Beware, that the internal
///  buffer will be overwritten with ever new call of [`utils_inet4_ntop()`][crate::utils_inet4_ntop()] or
///  [`utils_inet6_ntop()`][crate::utils_inet6_ntop()] that does not provide its own `dst` buffer. Since
///  1.28, the internal buffer is thread local and thus thread safe. Before
///  it was not thread safe. When in doubt, pass your own
///  `dst` buffer to avoid these issues.
///
/// # Returns
///
/// the input buffer `dst`, or a pointer to an
///  internal, static buffer. [`None`] is not allowed as `in6addr`,
///  otherwise, this function cannot fail.
#[doc(alias = "nm_utils_inet6_ntop")]
pub fn utils_inet6_ntop(dst: &str) -> Option<glib::GString> {
    unsafe { from_glib_none(ffi::nm_utils_inet6_ntop(dst.to_glib_none().0)) }
}

/// Utility function to convert a [`glib::PtrArray`][crate::glib::PtrArray] of [`IPAddress`][crate::IPAddress] objects representing
/// IPv4 addresses into a [`glib::Variant`][crate::glib::Variant] of type 'aau' representing an array of
/// NetworkManager IPv4 addresses (which are tuples of address, prefix, and
/// gateway). The "gateway" field of the first address will get the value of
/// `gateway` (if non-[`None`]). In all of the other addresses, that field will be 0.
/// ## `addresses`
/// an array of [`IPAddress`][crate::IPAddress] objects
/// ## `gateway`
/// the gateway IP address
///
/// # Returns
///
/// a new floating [`glib::Variant`][crate::glib::Variant] representing `addresses`.
#[doc(alias = "nm_utils_ip4_addresses_to_variant")]
pub fn utils_ip4_addresses_to_variant(
    addresses: &[&IPAddress],
    gateway: Option<&str>,
) -> Option<glib::Variant> {
    unsafe {
        from_glib_none(ffi::nm_utils_ip4_addresses_to_variant(
            addresses.to_glib_none().0,
            gateway.to_glib_none().0,
        ))
    }
}

/// When the Internet was originally set up, various ranges of IP addresses were
/// segmented into three network classes: A, B, and C. This function will return
/// a prefix that is associated with the IP address specified defining where it
/// falls in the predefined classes.
/// ## `ip`
/// an IPv4 address (in network byte order)
///
/// # Returns
///
/// the default class prefix for the given IP
#[doc(alias = "nm_utils_ip4_get_default_prefix")]
pub fn utils_ip4_get_default_prefix(ip: u32) -> u32 {
    unsafe { ffi::nm_utils_ip4_get_default_prefix(ip) }
}

/// ## `netmask`
/// an IPv4 netmask in network byte order
///
/// # Returns
///
/// the CIDR prefix represented by the netmask
#[doc(alias = "nm_utils_ip4_netmask_to_prefix")]
pub fn utils_ip4_netmask_to_prefix(netmask: u32) -> u32 {
    unsafe { ffi::nm_utils_ip4_netmask_to_prefix(netmask) }
}

/// ## `prefix`
/// a CIDR prefix
///
/// # Returns
///
/// the netmask represented by the prefix, in network byte order
#[doc(alias = "nm_utils_ip4_prefix_to_netmask")]
pub fn utils_ip4_prefix_to_netmask(prefix: u32) -> u32 {
    unsafe { ffi::nm_utils_ip4_prefix_to_netmask(prefix) }
}

/// Utility function to convert a [`glib::Variant`][crate::glib::Variant] of type 'aau' representing an array
/// of NetworkManager IPv4 routes (which are tuples of route, prefix, next hop,
/// and metric) into a [`glib::PtrArray`][crate::glib::PtrArray] of [`IPRoute`][crate::IPRoute] objects.
/// ## `value`
/// [`glib::Variant`][crate::glib::Variant] of type 'aau'
///
/// # Returns
///
/// a newly allocated
///  [`glib::PtrArray`][crate::glib::PtrArray] of [`IPRoute`][crate::IPRoute] objects
#[doc(alias = "nm_utils_ip4_routes_from_variant")]
pub fn utils_ip4_routes_from_variant(value: &glib::Variant) -> Vec<IPRoute> {
    unsafe {
        FromGlibPtrContainer::from_glib_full(ffi::nm_utils_ip4_routes_from_variant(
            value.to_glib_none().0,
        ))
    }
}

/// Utility function to convert a [`glib::PtrArray`][crate::glib::PtrArray] of [`IPRoute`][crate::IPRoute] objects representing
/// IPv4 routes into a [`glib::Variant`][crate::glib::Variant] of type 'aau' representing an array of
/// NetworkManager IPv4 routes (which are tuples of route, prefix, next hop, and
/// metric).
/// ## `routes`
/// an array of `NMIP4Route` objects
///
/// # Returns
///
/// a new floating [`glib::Variant`][crate::glib::Variant] representing `routes`.
#[doc(alias = "nm_utils_ip4_routes_to_variant")]
pub fn utils_ip4_routes_to_variant(routes: &[&IPRoute]) -> Option<glib::Variant> {
    unsafe { from_glib_none(ffi::nm_utils_ip4_routes_to_variant(routes.to_glib_none().0)) }
}

/// Utility function to convert a [`glib::PtrArray`][crate::glib::PtrArray] of [`IPAddress`][crate::IPAddress] objects representing
/// IPv6 addresses into a [`glib::Variant`][crate::glib::Variant] of type 'a(ayuay)' representing an array of
/// NetworkManager IPv6 addresses (which are tuples of address, prefix, and
/// gateway). The "gateway" field of the first address will get the value of
/// `gateway` (if non-[`None`]). In all of the other addresses, that field will be
/// all 0s.
/// ## `addresses`
/// an array of [`IPAddress`][crate::IPAddress] objects
/// ## `gateway`
/// the gateway IP address
///
/// # Returns
///
/// a new floating [`glib::Variant`][crate::glib::Variant] representing `addresses`.
#[doc(alias = "nm_utils_ip6_addresses_to_variant")]
pub fn utils_ip6_addresses_to_variant(
    addresses: &[&IPAddress],
    gateway: Option<&str>,
) -> Option<glib::Variant> {
    unsafe {
        from_glib_none(ffi::nm_utils_ip6_addresses_to_variant(
            addresses.to_glib_none().0,
            gateway.to_glib_none().0,
        ))
    }
}

/// Utility function to convert a [`glib::Variant`][crate::glib::Variant] of type 'a(ayuayu)' representing an
/// array of NetworkManager IPv6 routes (which are tuples of route, prefix, next
/// hop, and metric) into a [`glib::PtrArray`][crate::glib::PtrArray] of [`IPRoute`][crate::IPRoute] objects.
/// ## `value`
/// [`glib::Variant`][crate::glib::Variant] of type 'a(ayuayu)'
///
/// # Returns
///
/// a newly allocated
///  [`glib::PtrArray`][crate::glib::PtrArray] of [`IPRoute`][crate::IPRoute] objects
#[doc(alias = "nm_utils_ip6_routes_from_variant")]
pub fn utils_ip6_routes_from_variant(value: &glib::Variant) -> Vec<IPRoute> {
    unsafe {
        FromGlibPtrContainer::from_glib_full(ffi::nm_utils_ip6_routes_from_variant(
            value.to_glib_none().0,
        ))
    }
}

/// Utility function to convert a [`glib::PtrArray`][crate::glib::PtrArray] of [`IPRoute`][crate::IPRoute] objects representing
/// IPv6 routes into a [`glib::Variant`][crate::glib::Variant] of type 'a(ayuayu)' representing an array of
/// NetworkManager IPv6 routes (which are tuples of route, prefix, next hop, and
/// metric).
/// ## `routes`
/// an array of [`IPRoute`][crate::IPRoute] objects
///
/// # Returns
///
/// a new floating [`glib::Variant`][crate::glib::Variant] representing `routes`.
#[doc(alias = "nm_utils_ip6_routes_to_variant")]
pub fn utils_ip6_routes_to_variant(routes: &[&IPRoute]) -> Option<glib::Variant> {
    unsafe { from_glib_none(ffi::nm_utils_ip6_routes_to_variant(routes.to_glib_none().0)) }
}

/// Utility function to convert a [`glib::Variant`][crate::glib::Variant] representing a list of new-style
/// NetworkManager IPv4 or IPv6 addresses (as described in the documentation for
/// [`utils_ip_addresses_to_variant()`][crate::utils_ip_addresses_to_variant()]) into a [`glib::PtrArray`][crate::glib::PtrArray] of [`IPAddress`][crate::IPAddress]
/// objects.
/// ## `value`
/// a [`glib::Variant`][crate::glib::Variant] of type 'aa{sv}'
/// ## `family`
/// an IP address family
///
/// # Returns
///
/// a newly allocated
///  [`glib::PtrArray`][crate::glib::PtrArray] of [`IPAddress`][crate::IPAddress] objects
#[doc(alias = "nm_utils_ip_addresses_from_variant")]
pub fn utils_ip_addresses_from_variant(value: &glib::Variant, family: i32) -> Vec<IPAddress> {
    unsafe {
        FromGlibPtrContainer::from_glib_full(ffi::nm_utils_ip_addresses_from_variant(
            value.to_glib_none().0,
            family,
        ))
    }
}

/// Utility function to convert a [`glib::PtrArray`][crate::glib::PtrArray] of [`IPAddress`][crate::IPAddress] objects representing
/// IPv4 or IPv6 addresses into a [`glib::Variant`][crate::glib::Variant] of type 'aa{sv}' representing an
/// array of new-style NetworkManager IP addresses. All addresses will include
/// "address" (an IP address string), and "prefix" (a uint). Some addresses may
/// include additional attributes.
/// ## `addresses`
/// an array of [`IPAddress`][crate::IPAddress] objects
///
/// # Returns
///
/// a new floating [`glib::Variant`][crate::glib::Variant] representing `addresses`.
#[doc(alias = "nm_utils_ip_addresses_to_variant")]
pub fn utils_ip_addresses_to_variant(addresses: &[&IPAddress]) -> Option<glib::Variant> {
    unsafe {
        from_glib_none(ffi::nm_utils_ip_addresses_to_variant(
            addresses.to_glib_none().0,
        ))
    }
}

/// Utility function to convert a [`glib::Variant`][crate::glib::Variant] representing a list of new-style
/// NetworkManager IPv4 or IPv6 addresses (which are tuples of destination,
/// prefix, next hop, metric, and additional attributes) into a [`glib::PtrArray`][crate::glib::PtrArray] of
/// [`IPRoute`][crate::IPRoute] objects.
/// ## `value`
/// a [`glib::Variant`][crate::glib::Variant] of type 'aa{sv}'
/// ## `family`
/// an IP address family
///
/// # Returns
///
/// a newly allocated
///  [`glib::PtrArray`][crate::glib::PtrArray] of [`IPRoute`][crate::IPRoute] objects
#[doc(alias = "nm_utils_ip_routes_from_variant")]
pub fn utils_ip_routes_from_variant(value: &glib::Variant, family: i32) -> Vec<IPRoute> {
    unsafe {
        FromGlibPtrContainer::from_glib_full(ffi::nm_utils_ip_routes_from_variant(
            value.to_glib_none().0,
            family,
        ))
    }
}

/// Utility function to convert a [`glib::PtrArray`][crate::glib::PtrArray] of [`IPRoute`][crate::IPRoute] objects representing
/// IPv4 or IPv6 routes into a [`glib::Variant`][crate::glib::Variant] of type 'aa{sv}' representing an array
/// of new-style NetworkManager IP routes (which are tuples of destination,
/// prefix, next hop, metric, and additional attributes).
/// ## `routes`
/// an array of [`IPRoute`][crate::IPRoute] objects
///
/// # Returns
///
/// a new floating [`glib::Variant`][crate::glib::Variant] representing `routes`.
#[doc(alias = "nm_utils_ip_routes_to_variant")]
pub fn utils_ip_routes_to_variant(routes: &[&IPRoute]) -> Option<glib::Variant> {
    unsafe { from_glib_none(ffi::nm_utils_ip_routes_to_variant(routes.to_glib_none().0)) }
}

/// Checks if `ip` contains a valid IP address of the given family.
/// ## `family`
/// `<literal>`AF_INET`</literal>` or `<literal>`AF_INET6`</literal>`, or
///  `<literal>`AF_UNSPEC`</literal>` to accept either
/// ## `ip`
/// an IP address
///
/// # Returns
///
/// [`true`] or [`false`]
#[doc(alias = "nm_utils_ipaddr_valid")]
pub fn utils_ipaddr_valid(family: i32, ip: &str) -> bool {
    unsafe { from_glib(ffi::nm_utils_ipaddr_valid(family, ip.to_glib_none().0)) }
}

/// Different manufacturers use different mechanisms for not broadcasting the
/// AP's SSID. This function attempts to detect blank/empty SSIDs using a
/// number of known SSID-cloaking methods.
/// ## `ssid`
/// pointer to a buffer containing the SSID data
///
/// # Returns
///
/// [`true`] if the SSID is "empty", [`false`] if it is not
#[doc(alias = "nm_utils_is_empty_ssid")]
pub fn utils_is_empty_ssid(ssid: &[u8]) -> bool {
    let len = ssid.len() as usize;
    unsafe { from_glib(ffi::nm_utils_is_empty_ssid(ssid.to_glib_none().0, len)) }
}

/// ## `str`
/// the JSON string to test
///
/// # Returns
///
/// whether the passed string is valid JSON.
///  If libnm is not compiled with libjansson support, this check will
///  also return [`true`] for possibly invalid inputs. If that is a problem
///  for you, you must validate the JSON yourself.
#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
#[doc(alias = "nm_utils_is_json_object")]
pub fn utils_is_json_object(str: &str) -> Result<(), glib::Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let _ = ffi::nm_utils_is_json_object(str.to_glib_none().0, &mut error);
        if error.is_null() {
            Ok(())
        } else {
            Err(from_glib_full(error))
        }
    }
}

/// Checks if `str` is a UUID
///
/// # Deprecated since 1.32
///
/// older versions of NetworkManager had a wrong
///  understanding of what makes a valid UUID. This function can thus
///  accept some inputs as valid, which in fact are not valid UUIDs.
/// ## `str`
/// a string that might be a UUID
///
/// # Returns
///
/// [`true`] if `str` is a UUID, [`false`] if not
///
/// In older versions, [`utils_is_uuid()`][crate::utils_is_uuid()] did not accept [`None`] as `str`
/// argument. Don't pass [`None`] if you run against older versions of libnm.
#[cfg_attr(feature = "v1_32", deprecated = "Since 1.32")]
#[doc(alias = "nm_utils_is_uuid")]
pub fn utils_is_uuid(str: Option<&str>) -> bool {
    unsafe { from_glib(ffi::nm_utils_is_uuid(str.to_glib_none().0)) }
}

/// Validate the network interface name.
///
/// This function is a 1:1 copy of the kernel's interface validation
/// function in net/core/dev.c.
/// ## `name`
/// Name of interface
///
/// # Returns
///
/// [`true`] if interface name is valid, otherwise [`false`] is returned.
///
/// Before 1.20, this function did not accept [`None`] as `name` argument. If you
///  want to run against older versions of libnm, don't pass [`None`].
#[doc(alias = "nm_utils_is_valid_iface_name")]
pub fn utils_is_valid_iface_name(name: Option<&str>) -> Result<(), glib::Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let _ = ffi::nm_utils_is_valid_iface_name(name.to_glib_none().0, &mut error);
        if error.is_null() {
            Ok(())
        } else {
            Err(from_glib_full(error))
        }
    }
}

//#[cfg(any(feature = "v1_8", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
//#[doc(alias = "nm_utils_parse_variant_attributes")]
//pub fn utils_parse_variant_attributes(string: &str, attr_separator: glib::Char, key_value_separator: glib::Char, ignore_unknown: bool, spec: /*Ignored*/&VariantAttributeSpec) -> Result</*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 2, id: 200 }, glib::Error> {
//    unsafe { TODO: call ffi:nm_utils_parse_variant_attributes() }
//}

/// The only purpose of this function is to give access to `g_print()`
/// or `g_printerr()` from pygobject. libnm can do debug logging by
/// setting LIBNM_CLIENT_DEBUG and uses thereby `g_printerr()` or
/// `g_print()`. A plain "`print()`" function in python is not in sync
/// with these functions (it implements additional buffering). By
/// using [`utils_print()`][crate::utils_print()], the same logging mechanisms can be used.
/// ## `output_mode`
/// if 1 it uses `g_print()`. If 2, it uses `g_printerr()`.
///  If 0, it uses either `g_print()` or `g_printerr()`, depending
///  on LIBNM_CLIENT_DEBUG (and the "stdout" flag).
/// ## `msg`
/// the message to print. The function does not append
///  a trailing newline.
#[cfg(any(feature = "v1_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
#[doc(alias = "nm_utils_print")]
pub fn utils_print(output_mode: i32, msg: &str) {
    unsafe {
        ffi::nm_utils_print(output_mode, msg.to_glib_none().0);
    }
}

/// Earlier versions of the Linux kernel added a NULL byte to the end of the
/// SSID to enable easy printing of the SSID on the console or in a terminal,
/// but this behavior was problematic (SSIDs are simply byte arrays, not strings)
/// and thus was changed. This function compensates for that behavior at the
/// cost of some compatibility with odd SSIDs that may legitimately have trailing
/// NULLs, even though that is functionally pointless.
/// ## `ssid1`
/// the first SSID to compare
/// ## `ssid2`
/// the second SSID to compare
/// ## `ignore_trailing_null`
/// [`true`] to ignore one trailing NULL byte
///
/// # Returns
///
/// [`true`] if the SSIDs are the same, [`false`] if they are not
#[doc(alias = "nm_utils_same_ssid")]
pub fn utils_same_ssid(ssid1: &[u8], ssid2: &[u8], ignore_trailing_null: bool) -> bool {
    let len1 = ssid1.len() as usize;
    let len2 = ssid2.len() as usize;
    unsafe {
        from_glib(ffi::nm_utils_same_ssid(
            ssid1.to_glib_none().0,
            len1,
            ssid2.to_glib_none().0,
            len2,
            ignore_trailing_null.into_glib(),
        ))
    }
}

/// Given a set of device capabilities, and a desired security type to check
/// against, determines whether the combination of device, desired security
/// type, and AP capabilities intersect.
///
/// NOTE: this function cannot handle checking security for AP/Hotspot mode;
/// use [`utils_ap_mode_security_valid()`][crate::utils_ap_mode_security_valid()] instead.
/// ## `type_`
/// the security type to check AP flags and device capabilities against,
/// e.g. [`UtilsSecurityType::StaticWep`][crate::UtilsSecurityType::StaticWep]
/// ## `wifi_caps`
/// bitfield of the capabilities of the specific Wi-Fi device, e.g.
/// [`DeviceWifiCapabilities::CIPHER_WEP40`][crate::DeviceWifiCapabilities::CIPHER_WEP40]
/// ## `have_ap`
/// whether the `ap_flags`, `ap_wpa`, and `ap_rsn` arguments are valid
/// ## `adhoc`
/// whether the capabilities being tested are from an Ad-Hoc AP (IBSS)
/// ## `ap_flags`
/// bitfield of AP capabilities, e.g. [`_80211ApFlags::PRIVACY`][crate::_80211ApFlags::PRIVACY]
/// ## `ap_wpa`
/// bitfield of AP capabilities derived from the AP's WPA beacon,
/// e.g. ([`_80211ApSecurityFlags::PAIR_TKIP`][crate::_80211ApSecurityFlags::PAIR_TKIP] | [`_80211ApSecurityFlags::KEY_MGMT_PSK`][crate::_80211ApSecurityFlags::KEY_MGMT_PSK])
/// ## `ap_rsn`
/// bitfield of AP capabilities derived from the AP's RSN/WPA2 beacon,
/// e.g. ([`_80211ApSecurityFlags::PAIR_CCMP`][crate::_80211ApSecurityFlags::PAIR_CCMP] | [`_80211ApSecurityFlags::PAIR_TKIP`][crate::_80211ApSecurityFlags::PAIR_TKIP])
///
/// # Returns
///
/// [`true`] if the device capabilities and AP capabilities intersect and are
/// compatible with the desired `type_`, [`false`] if they are not
#[doc(alias = "nm_utils_security_valid")]
pub fn utils_security_valid(
    type_: UtilsSecurityType,
    wifi_caps: DeviceWifiCapabilities,
    have_ap: bool,
    adhoc: bool,
    ap_flags: _80211ApFlags,
    ap_wpa: _80211ApSecurityFlags,
    ap_rsn: _80211ApSecurityFlags,
) -> bool {
    unsafe {
        from_glib(ffi::nm_utils_security_valid(
            type_.into_glib(),
            wifi_caps.into_glib(),
            have_ap.into_glib(),
            adhoc.into_glib(),
            ap_flags.into_glib(),
            ap_wpa.into_glib(),
            ap_rsn.into_glib(),
        ))
    }
}

/// Converts a string to a SR-IOV virtual function object.
/// ## `str`
/// the input string
///
/// # Returns
///
/// the virtual function object
#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
#[doc(alias = "nm_utils_sriov_vf_from_str")]
pub fn utils_sriov_vf_from_str(str: &str) -> Result<SriovVF, glib::Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let ret = ffi::nm_utils_sriov_vf_from_str(str.to_glib_none().0, &mut error);
        if error.is_null() {
            Ok(from_glib_full(ret))
        } else {
            Err(from_glib_full(error))
        }
    }
}

/// Converts a SR-IOV virtual function object to its string representation.
/// ## `vf`
/// the `NMSriovVF`
/// ## `omit_index`
/// if [`true`], the VF index will be omitted from output string
///
/// # Returns
///
/// a newly allocated string or [`None`] on error
#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
#[doc(alias = "nm_utils_sriov_vf_to_str")]
pub fn utils_sriov_vf_to_str(vf: &SriovVF, omit_index: bool) -> Result<glib::GString, glib::Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let ret =
            ffi::nm_utils_sriov_vf_to_str(vf.to_glib_none().0, omit_index.into_glib(), &mut error);
        if error.is_null() {
            Ok(from_glib_full(ret))
        } else {
            Err(from_glib_full(error))
        }
    }
}

/// Wi-Fi SSIDs are byte arrays, they are _not_ strings. Thus, an SSID may
/// contain embedded NULLs and other unprintable characters. Often it is
/// useful to print the SSID out for debugging purposes, but that should be the
/// _only_ use of this function. Do not use this function for any persistent
/// storage of the SSID, since the printable SSID returned from this function
/// cannot be converted back into the real SSID of the access point.
///
/// This function does almost everything humanly possible to convert the input
/// into a printable UTF-8 string, using roughly the following procedure:
///
/// 1) if the input data is already UTF-8 safe, no conversion is performed
/// 2) attempts to get the current system language from the LANG environment
///  variable, and depending on the language, uses a table of alternative
///  encodings to try. For example, if LANG=hu_HU, the table may first try
///  the ISO-8859-2 encoding, and if that fails, try the Windows-1250 encoding.
///  If all fallback encodings fail, replaces non-UTF-8 characters with '?'.
/// 3) If the system language was unable to be determined, falls back to the
///  ISO-8859-1 encoding, then to the Windows-1251 encoding.
/// 4) If step 3 fails, replaces non-UTF-8 characters with '?'.
///
/// Again, this function should be used for debugging and display purposes
/// _only_.
/// ## `ssid`
/// pointer to a buffer containing the SSID data
///
/// # Returns
///
/// an allocated string containing a UTF-8
/// representation of the SSID, which must be freed by the caller using `g_free()`.
/// Returns [`None`] on errors.
#[doc(alias = "nm_utils_ssid_to_utf8")]
pub fn utils_ssid_to_utf8(ssid: &[u8]) -> Option<glib::GString> {
    let len = ssid.len() as usize;
    unsafe { from_glib_full(ffi::nm_utils_ssid_to_utf8(ssid.to_glib_none().0, len)) }
}

/// Parses the tc style string action representation of the queueing
/// discipline to a `NMTCAction` instance. Supports a subset of the tc language.
/// ## `str`
/// the string representation of a action
///
/// # Returns
///
/// the `NMTCAction` or [`None`]
#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
#[doc(alias = "nm_utils_tc_action_from_str")]
pub fn utils_tc_action_from_str(str: &str) -> Result<TCAction, glib::Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let ret = ffi::nm_utils_tc_action_from_str(str.to_glib_none().0, &mut error);
        if error.is_null() {
            Ok(from_glib_full(ret))
        } else {
            Err(from_glib_full(error))
        }
    }
}

/// Turns the `NMTCAction` into a tc style string representation of the queueing
/// discipline.
/// ## `action`
/// the `NMTCAction`
///
/// # Returns
///
/// formatted string or [`None`]
#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
#[doc(alias = "nm_utils_tc_action_to_str")]
pub fn utils_tc_action_to_str(action: &TCAction) -> Result<glib::GString, glib::Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let ret = ffi::nm_utils_tc_action_to_str(action.to_glib_none().0, &mut error);
        if error.is_null() {
            Ok(from_glib_full(ret))
        } else {
            Err(from_glib_full(error))
        }
    }
}

/// Parses the tc style string qdisc representation of the queueing
/// discipline to a `NMTCQdisc` instance. Supports a subset of the tc language.
/// ## `str`
/// the string representation of a qdisc
///
/// # Returns
///
/// the `NMTCQdisc` or [`None`]
#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
#[doc(alias = "nm_utils_tc_qdisc_from_str")]
pub fn utils_tc_qdisc_from_str(str: &str) -> Result<TCQdisc, glib::Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let ret = ffi::nm_utils_tc_qdisc_from_str(str.to_glib_none().0, &mut error);
        if error.is_null() {
            Ok(from_glib_full(ret))
        } else {
            Err(from_glib_full(error))
        }
    }
}

/// Turns the `NMTCQdisc` into a tc style string representation of the queueing
/// discipline.
/// ## `qdisc`
/// the `NMTCQdisc`
///
/// # Returns
///
/// formatted string or [`None`]
#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
#[doc(alias = "nm_utils_tc_qdisc_to_str")]
pub fn utils_tc_qdisc_to_str(qdisc: &TCQdisc) -> Result<glib::GString, glib::Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let ret = ffi::nm_utils_tc_qdisc_to_str(qdisc.to_glib_none().0, &mut error);
        if error.is_null() {
            Ok(from_glib_full(ret))
        } else {
            Err(from_glib_full(error))
        }
    }
}

/// Parses the tc style string tfilter representation of the queueing
/// discipline to a `NMTCTfilter` instance. Supports a subset of the tc language.
/// ## `str`
/// the string representation of a tfilter
///
/// # Returns
///
/// the `NMTCTfilter` or [`None`]
#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
#[doc(alias = "nm_utils_tc_tfilter_from_str")]
pub fn utils_tc_tfilter_from_str(str: &str) -> Result<TCTfilter, glib::Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let ret = ffi::nm_utils_tc_tfilter_from_str(str.to_glib_none().0, &mut error);
        if error.is_null() {
            Ok(from_glib_full(ret))
        } else {
            Err(from_glib_full(error))
        }
    }
}

/// Turns the `NMTCTfilter` into a tc style string representation of the queueing
/// discipline.
/// ## `tfilter`
/// the `NMTCTfilter`
///
/// # Returns
///
/// formatted string or [`None`]
#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
#[doc(alias = "nm_utils_tc_tfilter_to_str")]
pub fn utils_tc_tfilter_to_str(tfilter: &TCTfilter) -> Result<glib::GString, glib::Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let ret = ffi::nm_utils_tc_tfilter_to_str(tfilter.to_glib_none().0, &mut error);
        if error.is_null() {
            Ok(from_glib_full(ret))
        } else {
            Err(from_glib_full(error))
        }
    }
}

///
/// # Returns
///
/// a newly allocated UUID suitable for use as the [`SettingConnection`][crate::SettingConnection]
/// object's `property::SettingConnection::id`: property. Should be freed with `g_free()`
#[doc(alias = "nm_utils_uuid_generate")]
pub fn utils_uuid_generate() -> Option<glib::GString> {
    unsafe { from_glib_full(ffi::nm_utils_uuid_generate()) }
}

///
/// # Returns
///
/// the version ID of the libnm version. That is, the `NM_VERSION`
///  at runtime.
#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
#[doc(alias = "nm_utils_version")]
pub fn utils_version() -> u32 {
    unsafe { ffi::nm_utils_version() }
}

/// Checks if `key` is a valid WEP key
/// ## `key`
/// a string that might be a WEP key
/// ## `wep_type`
/// the [`WepKeyType`][crate::WepKeyType] type of the WEP key
///
/// # Returns
///
/// [`true`] if `key` is a WEP key, [`false`] if not
#[doc(alias = "nm_utils_wep_key_valid")]
pub fn utils_wep_key_valid(key: &str, wep_type: WepKeyType) -> bool {
    unsafe {
        from_glib(ffi::nm_utils_wep_key_valid(
            key.to_glib_none().0,
            wep_type.into_glib(),
        ))
    }
}

/// Utility function to translate a Wi-Fi channel to its corresponding frequency.
/// ## `channel`
/// channel
/// ## `band`
/// frequency band for wireless ("a" or "bg")
///
/// # Returns
///
/// the frequency represented by the channel of the band,
///  or -1 when the freq is invalid, or 0 when the band
///  is invalid
#[doc(alias = "nm_utils_wifi_channel_to_freq")]
pub fn utils_wifi_channel_to_freq(channel: u32, band: &str) -> u32 {
    unsafe { ffi::nm_utils_wifi_channel_to_freq(channel, band.to_glib_none().0) }
}

/// Utility function to find out next/previous Wi-Fi channel for a channel.
/// ## `channel`
/// current channel
/// ## `direction`
/// whether going downward (0 or less) or upward (1 or more)
/// ## `band`
/// frequency band for wireless ("a" or "bg")
///
/// # Returns
///
/// the next channel in the specified direction or 0
#[doc(alias = "nm_utils_wifi_find_next_channel")]
pub fn utils_wifi_find_next_channel(channel: u32, direction: i32, band: &str) -> u32 {
    unsafe { ffi::nm_utils_wifi_find_next_channel(channel, direction, band.to_glib_none().0) }
}

/// Utility function to translate a Wi-Fi frequency to its corresponding channel.
/// ## `freq`
/// frequency
///
/// # Returns
///
/// the channel represented by the frequency or 0
#[doc(alias = "nm_utils_wifi_freq_to_channel")]
pub fn utils_wifi_freq_to_channel(freq: u32) -> u32 {
    unsafe { ffi::nm_utils_wifi_freq_to_channel(freq) }
}

/// Utility function to verify Wi-Fi channel validity.
/// ## `channel`
/// channel
/// ## `band`
/// frequency band for wireless ("a" or "bg")
///
/// # Returns
///
/// [`true`] or [`false`]
#[doc(alias = "nm_utils_wifi_is_channel_valid")]
pub fn utils_wifi_is_channel_valid(channel: u32, band: &str) -> bool {
    unsafe {
        from_glib(ffi::nm_utils_wifi_is_channel_valid(
            channel,
            band.to_glib_none().0,
        ))
    }
}

/// Converts `strength` into a 4-character-wide graphical representation of
/// strength suitable for printing to stdout.
///
/// Previous versions used to take a guess at the terminal type and possibly
/// return a wide UTF-8 encoded string. Now it always returns a 7-bit
/// clean strings of one to 0 to 4 asterisks. Users that actually need
/// the functionality are encouraged to make their implementations instead.
/// ## `strength`
/// the access point strength, from 0 to 100
///
/// # Returns
///
/// the graphical representation of the access point strength
#[doc(alias = "nm_utils_wifi_strength_bars")]
pub fn utils_wifi_strength_bars(strength: u8) -> Option<glib::GString> {
    unsafe { from_glib_none(ffi::nm_utils_wifi_strength_bars(strength)) }
}

/// Checks if `psk` is a valid WPA PSK
/// ## `psk`
/// a string that might be a WPA PSK
///
/// # Returns
///
/// [`true`] if `psk` is a WPA PSK, [`false`] if not
#[doc(alias = "nm_utils_wpa_psk_valid")]
pub fn utils_wpa_psk_valid(psk: &str) -> bool {
    unsafe { from_glib(ffi::nm_utils_wpa_psk_valid(psk.to_glib_none().0)) }
}
