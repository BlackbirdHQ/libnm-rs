// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use _80211ApFlags;
use _80211ApSecurityFlags;
use glib;
use glib::translate::*;
use glib::GString;
use nm_sys;
use std::mem;
use std::ptr;
use DeviceWifiCapabilities;
use IPAddress;
use IPRoute;
#[cfg(any(feature = "v1_14", feature = "dox"))]
use SriovVF;
#[cfg(any(feature = "v1_12", feature = "dox"))]
use TCQdisc;
#[cfg(any(feature = "v1_12", feature = "dox"))]
use TCTfilter;
use UtilsSecurityType;
use WepKeyType;

#[cfg(any(feature = "v1_20", feature = "dox"))]
pub fn ethtool_optname_is_feature(optname: Option<&str>) -> bool {
    unsafe {
        from_glib(nm_sys::nm_ethtool_optname_is_feature(
            optname.to_glib_none().0,
        ))
    }
}

pub fn utils_ap_mode_security_valid(
    type_: UtilsSecurityType,
    wifi_caps: DeviceWifiCapabilities,
) -> bool {
    unsafe {
        from_glib(nm_sys::nm_utils_ap_mode_security_valid(
            type_.to_glib(),
            wifi_caps.to_glib(),
        ))
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
pub fn utils_bond_mode_int_to_string(mode: i32) -> Option<GString> {
    unsafe { from_glib_none(nm_sys::nm_utils_bond_mode_int_to_string(mode)) }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
pub fn utils_bond_mode_string_to_int(mode: &str) -> i32 {
    unsafe { nm_sys::nm_utils_bond_mode_string_to_int(mode.to_glib_none().0) }
}

pub fn utils_check_virtual_device_compatibility(
    virtual_type: glib::types::Type,
    other_type: glib::types::Type,
) -> bool {
    unsafe {
        from_glib(nm_sys::nm_utils_check_virtual_device_compatibility(
            virtual_type.to_glib(),
            other_type.to_glib(),
        ))
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
pub fn utils_enum_get_values(type_: glib::types::Type, from: i32, to: i32) -> Vec<GString> {
    unsafe {
        FromGlibPtrContainer::from_glib_container(nm_sys::nm_utils_enum_get_values(
            type_.to_glib(),
            from,
            to,
        ))
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
pub fn utils_enum_to_str(type_: glib::types::Type, value: i32) -> Option<GString> {
    unsafe { from_glib_full(nm_sys::nm_utils_enum_to_str(type_.to_glib(), value)) }
}

pub fn utils_escape_ssid(ssid: &[u8]) -> Option<GString> {
    let len = ssid.len() as usize;
    unsafe { from_glib_none(nm_sys::nm_utils_escape_ssid(ssid.to_glib_none().0, len)) }
}

pub fn utils_file_is_certificate(filename: &str) -> bool {
    unsafe {
        from_glib(nm_sys::nm_utils_file_is_certificate(
            filename.to_glib_none().0,
        ))
    }
}

pub fn utils_file_is_pkcs12(filename: &str) -> bool {
    unsafe { from_glib(nm_sys::nm_utils_file_is_pkcs12(filename.to_glib_none().0)) }
}

pub fn utils_file_is_private_key(filename: &str) -> Option<bool> {
    unsafe {
        let mut out_encrypted = mem::MaybeUninit::uninit();
        let ret = from_glib(nm_sys::nm_utils_file_is_private_key(
            filename.to_glib_none().0,
            out_encrypted.as_mut_ptr(),
        ));
        let out_encrypted = out_encrypted.assume_init();
        if ret {
            Some(from_glib(out_encrypted))
        } else {
            None
        }
    }
}

//pub fn utils_format_variant_attributes(attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 25 }/TypeId { ns_id: 0, id: 25 }, attr_separator: glib::Char, key_value_separator: glib::Char) -> Option<GString> {
//    unsafe { TODO: call nm_sys:nm_utils_format_variant_attributes() }
//}

pub fn utils_get_timestamp_msec() -> i64 {
    unsafe { nm_sys::nm_utils_get_timestamp_msec() }
}

pub fn utils_hexstr2bin(hex: &str) -> Option<glib::Bytes> {
    unsafe { from_glib_full(nm_sys::nm_utils_hexstr2bin(hex.to_glib_none().0)) }
}

pub fn utils_hwaddr_atoba(asc: &str) -> Option<glib::ByteArray> {
    let length = asc.len() as usize;
    unsafe { from_glib_full(nm_sys::nm_utils_hwaddr_atoba(asc.to_glib_none().0, length)) }
}

pub fn utils_hwaddr_canonical(asc: &str) -> Option<GString> {
    let length = asc.len() as isize;
    unsafe {
        from_glib_full(nm_sys::nm_utils_hwaddr_canonical(
            asc.to_glib_none().0,
            length,
        ))
    }
}

pub fn utils_hwaddr_len(type_: i32) -> usize {
    unsafe { nm_sys::nm_utils_hwaddr_len(type_) }
}

//pub fn utils_hwaddr_matches(hwaddr1: /*Unimplemented*/Option<Fundamental: Pointer>, hwaddr1_len: isize, hwaddr2: /*Unimplemented*/Option<Fundamental: Pointer>, hwaddr2_len: isize) -> bool {
//    unsafe { TODO: call nm_sys:nm_utils_hwaddr_matches() }
//}

pub fn utils_hwaddr_valid(asc: &str) -> bool {
    let length = asc.len() as isize;
    unsafe { from_glib(nm_sys::nm_utils_hwaddr_valid(asc.to_glib_none().0, length)) }
}

#[cfg_attr(feature = "v1_6", deprecated)]
pub fn utils_iface_valid_name(name: Option<&str>) -> bool {
    unsafe { from_glib(nm_sys::nm_utils_iface_valid_name(name.to_glib_none().0)) }
}

pub fn utils_inet4_ntop(dst: &str) -> Option<GString> {
    unsafe { from_glib_none(nm_sys::nm_utils_inet4_ntop(dst.to_glib_none().0)) }
}

pub fn utils_inet6_ntop(dst: &str) -> Option<GString> {
    unsafe { from_glib_none(nm_sys::nm_utils_inet6_ntop(dst.to_glib_none().0)) }
}

pub fn utils_ip4_addresses_to_variant(
    addresses: &[&IPAddress],
    gateway: Option<&str>,
) -> Option<glib::Variant> {
    unsafe {
        from_glib_none(nm_sys::nm_utils_ip4_addresses_to_variant(
            addresses.to_glib_none().0,
            gateway.to_glib_none().0,
        ))
    }
}

pub fn utils_ip4_get_default_prefix(ip: u32) -> u32 {
    unsafe { nm_sys::nm_utils_ip4_get_default_prefix(ip) }
}

pub fn utils_ip4_netmask_to_prefix(netmask: u32) -> u32 {
    unsafe { nm_sys::nm_utils_ip4_netmask_to_prefix(netmask) }
}

pub fn utils_ip4_prefix_to_netmask(prefix: u32) -> u32 {
    unsafe { nm_sys::nm_utils_ip4_prefix_to_netmask(prefix) }
}

pub fn utils_ip4_routes_from_variant(value: &glib::Variant) -> Vec<IPRoute> {
    unsafe {
        FromGlibPtrContainer::from_glib_full(nm_sys::nm_utils_ip4_routes_from_variant(
            value.to_glib_none().0,
        ))
    }
}

pub fn utils_ip4_routes_to_variant(routes: &[&IPRoute]) -> Option<glib::Variant> {
    unsafe {
        from_glib_none(nm_sys::nm_utils_ip4_routes_to_variant(
            routes.to_glib_none().0,
        ))
    }
}

pub fn utils_ip6_addresses_to_variant(
    addresses: &[&IPAddress],
    gateway: Option<&str>,
) -> Option<glib::Variant> {
    unsafe {
        from_glib_none(nm_sys::nm_utils_ip6_addresses_to_variant(
            addresses.to_glib_none().0,
            gateway.to_glib_none().0,
        ))
    }
}

pub fn utils_ip6_routes_from_variant(value: &glib::Variant) -> Vec<IPRoute> {
    unsafe {
        FromGlibPtrContainer::from_glib_full(nm_sys::nm_utils_ip6_routes_from_variant(
            value.to_glib_none().0,
        ))
    }
}

pub fn utils_ip6_routes_to_variant(routes: &[&IPRoute]) -> Option<glib::Variant> {
    unsafe {
        from_glib_none(nm_sys::nm_utils_ip6_routes_to_variant(
            routes.to_glib_none().0,
        ))
    }
}

pub fn utils_ip_addresses_from_variant(value: &glib::Variant, family: i32) -> Vec<IPAddress> {
    unsafe {
        FromGlibPtrContainer::from_glib_full(nm_sys::nm_utils_ip_addresses_from_variant(
            value.to_glib_none().0,
            family,
        ))
    }
}

pub fn utils_ip_addresses_to_variant(addresses: &[&IPAddress]) -> Option<glib::Variant> {
    unsafe {
        from_glib_none(nm_sys::nm_utils_ip_addresses_to_variant(
            addresses.to_glib_none().0,
        ))
    }
}

pub fn utils_ip_routes_from_variant(value: &glib::Variant, family: i32) -> Vec<IPRoute> {
    unsafe {
        FromGlibPtrContainer::from_glib_full(nm_sys::nm_utils_ip_routes_from_variant(
            value.to_glib_none().0,
            family,
        ))
    }
}

pub fn utils_ip_routes_to_variant(routes: &[&IPRoute]) -> Option<glib::Variant> {
    unsafe {
        from_glib_none(nm_sys::nm_utils_ip_routes_to_variant(
            routes.to_glib_none().0,
        ))
    }
}

pub fn utils_ipaddr_valid(family: i32, ip: &str) -> bool {
    unsafe { from_glib(nm_sys::nm_utils_ipaddr_valid(family, ip.to_glib_none().0)) }
}

pub fn utils_is_empty_ssid(ssid: &[u8]) -> bool {
    let len = ssid.len() as usize;
    unsafe { from_glib(nm_sys::nm_utils_is_empty_ssid(ssid.to_glib_none().0, len)) }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
pub fn utils_is_json_object(str: &str) -> Result<(), glib::Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let _ = nm_sys::nm_utils_is_json_object(str.to_glib_none().0, &mut error);
        if error.is_null() {
            Ok(())
        } else {
            Err(from_glib_full(error))
        }
    }
}

pub fn utils_is_uuid(str: Option<&str>) -> bool {
    unsafe { from_glib(nm_sys::nm_utils_is_uuid(str.to_glib_none().0)) }
}

pub fn utils_is_valid_iface_name(name: Option<&str>) -> Result<(), glib::Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let _ = nm_sys::nm_utils_is_valid_iface_name(name.to_glib_none().0, &mut error);
        if error.is_null() {
            Ok(())
        } else {
            Err(from_glib_full(error))
        }
    }
}

//#[cfg(any(feature = "v1_8", feature = "dox"))]
//pub fn utils_parse_variant_attributes(string: &str, attr_separator: glib::Char, key_value_separator: glib::Char, ignore_unknown: bool, spec: /*Ignored*/&VariantAttributeSpec) -> Result</*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 2, id: 185 }, glib::Error> {
//    unsafe { TODO: call nm_sys:nm_utils_parse_variant_attributes() }
//}

pub fn utils_same_ssid(ssid1: &[u8], ssid2: &[u8], ignore_trailing_null: bool) -> bool {
    let len1 = ssid1.len() as usize;
    let len2 = ssid2.len() as usize;
    unsafe {
        from_glib(nm_sys::nm_utils_same_ssid(
            ssid1.to_glib_none().0,
            len1,
            ssid2.to_glib_none().0,
            len2,
            ignore_trailing_null.to_glib(),
        ))
    }
}

pub fn utils_security_valid(
    type_: UtilsSecurityType,
    wifi_caps: DeviceWifiCapabilities,
    have_ap: bool,
    adhoc: bool,
    ap_flags: _80211ApFlags,
    ap_wpa: _80211ApSecurityFlags,
    ap_rsn: _80211ApSecurityFlags,
) -> bool {
    unsafe {
        from_glib(nm_sys::nm_utils_security_valid(
            type_.to_glib(),
            wifi_caps.to_glib(),
            have_ap.to_glib(),
            adhoc.to_glib(),
            ap_flags.to_glib(),
            ap_wpa.to_glib(),
            ap_rsn.to_glib(),
        ))
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
pub fn utils_sriov_vf_from_str(str: &str) -> Result<SriovVF, glib::Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let ret = nm_sys::nm_utils_sriov_vf_from_str(str.to_glib_none().0, &mut error);
        if error.is_null() {
            Ok(from_glib_full(ret))
        } else {
            Err(from_glib_full(error))
        }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
pub fn utils_sriov_vf_to_str(vf: &SriovVF, omit_index: bool) -> Result<GString, glib::Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let ret =
            nm_sys::nm_utils_sriov_vf_to_str(vf.to_glib_none().0, omit_index.to_glib(), &mut error);
        if error.is_null() {
            Ok(from_glib_full(ret))
        } else {
            Err(from_glib_full(error))
        }
    }
}

pub fn utils_ssid_to_utf8(ssid: &[u8]) -> Option<GString> {
    let len = ssid.len() as usize;
    unsafe { from_glib_full(nm_sys::nm_utils_ssid_to_utf8(ssid.to_glib_none().0, len)) }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
pub fn utils_tc_qdisc_from_str(str: &str) -> Result<TCQdisc, glib::Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let ret = nm_sys::nm_utils_tc_qdisc_from_str(str.to_glib_none().0, &mut error);
        if error.is_null() {
            Ok(from_glib_full(ret))
        } else {
            Err(from_glib_full(error))
        }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
pub fn utils_tc_qdisc_to_str(qdisc: &TCQdisc) -> Result<GString, glib::Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let ret = nm_sys::nm_utils_tc_qdisc_to_str(qdisc.to_glib_none().0, &mut error);
        if error.is_null() {
            Ok(from_glib_full(ret))
        } else {
            Err(from_glib_full(error))
        }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
pub fn utils_tc_tfilter_from_str(str: &str) -> Result<TCTfilter, glib::Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let ret = nm_sys::nm_utils_tc_tfilter_from_str(str.to_glib_none().0, &mut error);
        if error.is_null() {
            Ok(from_glib_full(ret))
        } else {
            Err(from_glib_full(error))
        }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
pub fn utils_tc_tfilter_to_str(tfilter: &TCTfilter) -> Result<GString, glib::Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let ret = nm_sys::nm_utils_tc_tfilter_to_str(tfilter.to_glib_none().0, &mut error);
        if error.is_null() {
            Ok(from_glib_full(ret))
        } else {
            Err(from_glib_full(error))
        }
    }
}

pub fn utils_uuid_generate() -> Option<GString> {
    unsafe { from_glib_full(nm_sys::nm_utils_uuid_generate()) }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
pub fn utils_version() -> u32 {
    unsafe { nm_sys::nm_utils_version() }
}

pub fn utils_wep_key_valid(key: &str, wep_type: WepKeyType) -> bool {
    unsafe {
        from_glib(nm_sys::nm_utils_wep_key_valid(
            key.to_glib_none().0,
            wep_type.to_glib(),
        ))
    }
}

pub fn utils_wifi_channel_to_freq(channel: u32, band: &str) -> u32 {
    unsafe { nm_sys::nm_utils_wifi_channel_to_freq(channel, band.to_glib_none().0) }
}

pub fn utils_wifi_find_next_channel(channel: u32, direction: i32, band: &str) -> u32 {
    unsafe { nm_sys::nm_utils_wifi_find_next_channel(channel, direction, band.to_glib_none().0) }
}

pub fn utils_wifi_freq_to_channel(freq: u32) -> u32 {
    unsafe { nm_sys::nm_utils_wifi_freq_to_channel(freq) }
}

pub fn utils_wifi_is_channel_valid(channel: u32, band: &str) -> bool {
    unsafe {
        from_glib(nm_sys::nm_utils_wifi_is_channel_valid(
            channel,
            band.to_glib_none().0,
        ))
    }
}

pub fn utils_wifi_strength_bars(strength: u8) -> Option<GString> {
    unsafe { from_glib_none(nm_sys::nm_utils_wifi_strength_bars(strength)) }
}

pub fn utils_wpa_psk_valid(psk: &str) -> bool {
    unsafe { from_glib(nm_sys::nm_utils_wpa_psk_valid(psk.to_glib_none().0)) }
}
