// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use gio;
use gio_sys;
use glib;
use glib::object::Cast;
use glib::object::IsA;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib::GString;
use glib::StaticType;
use glib::Value;
use glib_sys;
use gobject_sys;
use nm_sys;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem::transmute;
use std::pin::Pin;
use std::ptr;
use crate::Connection;
use crate::SecretAgentCapabilities;
use crate::SecretAgentGetSecretsFlags;

glib_wrapper! {
    pub struct SecretAgentOld(Object<nm_sys::NMSecretAgentOld, nm_sys::NMSecretAgentOldClass, SecretAgentOldClass>);

    match fn {
        get_type => || nm_sys::nm_secret_agent_old_get_type(),
    }
}

pub const NONE_SECRET_AGENT_OLD: Option<&SecretAgentOld> = None;

/// Trait containing all `SecretAgentOld` methods.
///
/// # Implementors
///
/// [`SecretAgentOld`](struct.SecretAgentOld.html)
pub trait SecretAgentOldExt: 'static {
    /// Asynchronously asks the agent to delete all saved secrets belonging to
    /// `connection`.
    /// ## `connection`
    /// a `Connection`
    /// ## `callback`
    /// a callback, to be invoked when the operation is done
    /// ## `user_data`
    /// caller-specific data to be passed to `callback`
    fn delete_secrets<
        P: IsA<Connection>,
        Q: FnOnce(&SecretAgentOld, &Connection, &glib::Error) + 'static,
    >(
        &self,
        connection: &P,
        callback: Q,
    );

    /// Since 1.24, the instance will already register a D-Bus object on the
    /// D-Bus connection during initialization. That object will stay registered
    /// until `self` gets unrefed (destroyed) or this function is called. This
    /// function performs the necessary cleanup to tear down the instance. Afterwards,
    /// the function can not longer be used. This is optional, but necessary to
    /// ensure unregistering the D-Bus object at a define point, when other users
    /// might still have a reference on `self`.
    ///
    /// You may call this function any time and repeatedly. However, after destroying
    /// the instance, it is a bug to still use the instance for other purposes. The
    /// instance becomes defunct and cannot re-register.
    ///
    /// Feature: `v1_24`
    ///
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    fn destroy(&self);

    /// This has the same effect as setting `NM_SECRET_AGENT_OLD_AUTO_REGISTER`
    /// property.
    ///
    /// Unlike most other functions, you may already call this function before
    /// initialization completes.
    ///
    /// Feature: `v1_24`
    ///
    /// ## `enable`
    /// whether to enable or disable the listener.
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    fn enable(&self, enable: bool);

    /// Returns a `gobject::Object` that stays alive as long as there are pending
    /// requests in the `gio::DBusConnection`. Such requests keep the `glib::MainContext`
    /// alive, and thus you may want to keep iterating the context as long
    /// until a weak reference indicates that this object is gone. This is
    /// useful because even when you destroy the instance right away (and all
    /// the internally pending requests get cancelled), any pending `gio::DBusConnection::call`
    /// requests will still invoke the result on the `glib::MainContext`. Hence, this
    /// allows you to know how long you must iterate the context to know
    /// that all remains are cleaned up.
    ///
    /// Feature: `v1_24`
    ///
    ///
    /// # Returns
    ///
    /// a `gobject::Object` that you may register a weak pointer
    ///  to know that the `glib::MainContext` is still kept busy by `self`.
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    fn get_context_busy_watcher(&self) -> Option<glib::Object>;

    ///
    /// Feature: `v1_24`
    ///
    ///
    /// # Returns
    ///
    /// the current D-Bus name owner. While this property
    ///  is set while registering, it really only makes sense when
    ///  the `SecretAgentOldExt::get_registered` indicates that
    ///  registration is successfull.
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    fn get_dbus_name_owner(&self) -> Option<GString>;

    //#[cfg(any(feature = "v1_24", feature = "dox"))]
    //fn get_main_context(&self) -> /*Ignored*/Option<glib::MainContext>;

    /// Note that the secret agent transparently registers and re-registers
    /// as the D-Bus name owner appears. Hence, this property is not really
    /// useful. Also, to be graceful against races during registration, the
    /// instance will already accept requests while being in the process of
    /// registering.
    /// If you need to avoid races and want to wait until `self` is registered,
    /// call `SecretAgentOldExt::register_async`. If that function completes
    /// with success, you know the instance is registered.
    ///
    /// # Returns
    ///
    /// a `true` if the agent is registered, `false` if it is not.
    fn get_registered(&self) -> bool;

    /// Asynchronously retrieves secrets belonging to `connection` for the
    /// setting `setting_name`. `flags` indicate specific behavior that the secret
    /// agent should use when performing the request, for example returning only
    /// existing secrets without user interaction, or requesting entirely new
    /// secrets from the user.
    /// ## `connection`
    /// the `Connection` for which we're asked secrets
    /// ## `setting_name`
    /// the name of the secret setting
    /// ## `hints`
    /// hints to the agent
    /// ## `flags`
    /// flags that modify the behavior of the request
    /// ## `callback`
    /// a callback, to be invoked when the operation is done
    /// ## `user_data`
    /// caller-specific data to be passed to `callback`
    fn get_secrets<
        P: IsA<Connection>,
        Q: FnOnce(&SecretAgentOld, &Connection, &glib::Variant, &glib::Error) + 'static,
    >(
        &self,
        connection: &P,
        setting_name: &str,
        hints: &[&str],
        flags: SecretAgentGetSecretsFlags,
        callback: Q,
    );

    /// Registers the `SecretAgentOld` with the NetworkManager secret manager,
    /// indicating to NetworkManager that the agent is able to provide and save
    /// secrets for connections on behalf of its user.
    ///
    /// # Deprecated since 1.24
    ///
    /// Use `SecretAgentOldExt::enable` or `SecretAgentOldExt::register_async`.
    /// ## `cancellable`
    /// a `gio::Cancellable`, or `None`
    ///
    /// # Returns
    ///
    /// `true` if registration was successful, `false` on error.
    ///
    /// Since 1.24, this can no longer fail unless the `cancellable` gets
    /// cancelled. Contrary to `SecretAgentOldExt::register_async`, this also
    /// does not wait for the registration to succeed. You cannot synchronously
    /// (without iterating the caller's GMainContext) wait for registration.
    ///
    /// Since 1.24, registration is idempotent. It has the same effect as setting
    /// `NM_SECRET_AGENT_OLD_AUTO_REGISTER` to `true` or `SecretAgentOldExt::enable`.
    #[cfg_attr(feature = "v1_24", deprecated)]
    fn register<P: IsA<gio::Cancellable>>(
        &self,
        cancellable: Option<&P>,
    ) -> Result<(), glib::Error>;

    /// Asynchronously registers the `SecretAgentOld` with the NetworkManager secret
    /// manager, indicating to NetworkManager that the agent is able to provide and
    /// save secrets for connections on behalf of its user.
    ///
    /// Since 1.24, registration cannot fail and is idempotent. It has
    /// the same effect as setting `NM_SECRET_AGENT_OLD_AUTO_REGISTER` to `true`
    /// or `SecretAgentOldExt::enable`.
    ///
    /// Since 1.24, the asynchronous result indicates whether the instance is successfully
    /// registered. In any case, this call enables the agent and it will automatically
    /// try to register and handle secret requests. A failure of this function only indicates
    /// that currently the instance might not be ready (but since it will automatically
    /// try to recover, it might be ready in a moment afterwards). Use this function if
    /// you want to check and ensure that the agent is registered.
    /// ## `cancellable`
    /// a `gio::Cancellable`, or `None`
    /// ## `callback`
    /// callback to call when the agent is registered
    /// ## `user_data`
    /// data for `callback`
    fn register_async<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
    >(
        &self,
        cancellable: Option<&P>,
        callback: Q,
    );

    fn register_async_future(
        &self,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>>;

    /// Asynchronously ensures that all secrets inside `connection` are stored to
    /// disk.
    /// ## `connection`
    /// a `Connection`
    /// ## `callback`
    /// a callback, to be invoked when the operation is done
    /// ## `user_data`
    /// caller-specific data to be passed to `callback`
    fn save_secrets<
        P: IsA<Connection>,
        Q: FnOnce(&SecretAgentOld, &Connection, &glib::Error) + 'static,
    >(
        &self,
        connection: &P,
        callback: Q,
    );

    /// Unregisters the `SecretAgentOld` with the NetworkManager secret manager,
    /// indicating to NetworkManager that the agent will no longer provide or
    /// store secrets on behalf of this user.
    ///
    /// # Deprecated since 1.24
    ///
    /// Use `SecretAgentOldExt::enable`.
    /// ## `cancellable`
    /// a `gio::Cancellable`, or `None`
    ///
    /// # Returns
    ///
    /// `true` if unregistration was successful, `false` on error
    ///
    /// Since 1.24, registration cannot fail and is idempotent. It has
    /// the same effect as setting `NM_SECRET_AGENT_OLD_AUTO_REGISTER` to `false`
    /// or `SecretAgentOldExt::enable`.
    #[cfg_attr(feature = "v1_24", deprecated)]
    fn unregister<P: IsA<gio::Cancellable>>(
        &self,
        cancellable: Option<&P>,
    ) -> Result<(), glib::Error>;

    /// Asynchronously unregisters the `SecretAgentOld` with the NetworkManager secret
    /// manager, indicating to NetworkManager that the agent will no longer provide
    /// or store secrets on behalf of this user.
    ///
    /// Since 1.24, registration cannot fail and is idempotent. It has
    /// the same effect as setting `NM_SECRET_AGENT_OLD_AUTO_REGISTER` to `false`
    /// or `SecretAgentOldExt::enable`.
    ///
    /// # Deprecated since 1.24
    ///
    /// Use `SecretAgentOldExt::enable`.
    /// ## `cancellable`
    /// a `gio::Cancellable`, or `None`
    /// ## `callback`
    /// callback to call when the agent is unregistered
    /// ## `user_data`
    /// data for `callback`
    #[cfg_attr(feature = "v1_24", deprecated)]
    fn unregister_async<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
    >(
        &self,
        cancellable: Option<&P>,
        callback: Q,
    );

    #[cfg_attr(feature = "v1_24", deprecated)]

    fn unregister_async_future(
        &self,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>>;

    /// If `true` (the default), the agent will always be registered when
    /// NetworkManager is running; if NetworkManager exits and restarts, the
    /// agent will re-register itself automatically.
    ///
    /// In particular, if this property is `true` at construct time, then the
    /// agent will register itself with NetworkManager during
    /// construction/initialization and initialization will only complete
    /// after registration is completed (either successfully or unsucessfully).
    /// Since 1.24, a failure to register will no longer cause initialization
    /// of `SecretAgentOld` to fail.
    ///
    /// If the property is `false`, the agent will not automatically register with
    /// NetworkManager, and `SecretAgentOldExt::enable` or
    /// `SecretAgentOldExt::register_async` must be called to register it.
    ///
    /// Calling `SecretAgentOldExt::enable` has the same effect as setting this
    /// property.
    fn get_property_auto_register(&self) -> bool;

    /// If `true` (the default), the agent will always be registered when
    /// NetworkManager is running; if NetworkManager exits and restarts, the
    /// agent will re-register itself automatically.
    ///
    /// In particular, if this property is `true` at construct time, then the
    /// agent will register itself with NetworkManager during
    /// construction/initialization and initialization will only complete
    /// after registration is completed (either successfully or unsucessfully).
    /// Since 1.24, a failure to register will no longer cause initialization
    /// of `SecretAgentOld` to fail.
    ///
    /// If the property is `false`, the agent will not automatically register with
    /// NetworkManager, and `SecretAgentOldExt::enable` or
    /// `SecretAgentOldExt::register_async` must be called to register it.
    ///
    /// Calling `SecretAgentOldExt::enable` has the same effect as setting this
    /// property.
    fn set_property_auto_register(&self, auto_register: bool);

    /// A bitfield of `SecretAgentCapabilities`.
    ///
    /// Changing this property is possible at any time. In case the secret
    /// agent is currently registered, this will cause a re-registration.
    fn get_property_capabilities(&self) -> SecretAgentCapabilities;

    /// A bitfield of `SecretAgentCapabilities`.
    ///
    /// Changing this property is possible at any time. In case the secret
    /// agent is currently registered, this will cause a re-registration.
    fn set_property_capabilities(&self, capabilities: SecretAgentCapabilities);

    /// Identifies this agent; only one agent in each user session may use the
    /// same identifier. Identifier formatting follows the same rules as
    /// D-Bus bus names with the exception that the ':' character is not
    /// allowed. The valid set of characters is "[A-Z][a-z][0-9]_-." and the
    /// identifier is limited in length to 255 characters with a minimum
    /// of 3 characters. An example valid identifier is 'org.gnome.nm-applet'
    /// (without quotes).
    fn get_property_identifier(&self) -> Option<GString>;

    fn connect_property_auto_register_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_capabilities_notify<F: Fn(&Self) + 'static>(&self, f: F)
        -> SignalHandlerId;

    fn connect_property_registered_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<SecretAgentOld>> SecretAgentOldExt for O {
    fn delete_secrets<
        P: IsA<Connection>,
        Q: FnOnce(&SecretAgentOld, &Connection, &glib::Error) + 'static,
    >(
        &self,
        connection: &P,
        callback: Q,
    ) {
        let callback_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn callback_func<
            P: IsA<Connection>,
            Q: FnOnce(&SecretAgentOld, &Connection, &glib::Error) + 'static,
        >(
            agent: *mut nm_sys::NMSecretAgentOld,
            connection: *mut nm_sys::NMConnection,
            error: *mut glib_sys::GError,
            user_data: glib_sys::gpointer,
        ) {
            let agent = from_glib_borrow(agent);
            let connection = from_glib_borrow(connection);
            let error = from_glib_borrow(error);
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            (*callback)(&agent, &connection, &error);
        }
        let callback = Some(callback_func::<P, Q> as _);
        let super_callback0: Box_<Q> = callback_data;
        unsafe {
            nm_sys::nm_secret_agent_old_delete_secrets(
                self.as_ref().to_glib_none().0,
                connection.as_ref().to_glib_none().0,
                callback,
                Box_::into_raw(super_callback0) as *mut _,
            );
        }
    }

    #[cfg(any(feature = "v1_24", feature = "dox"))]
    fn destroy(&self) {
        unsafe {
            nm_sys::nm_secret_agent_old_destroy(self.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v1_24", feature = "dox"))]
    fn enable(&self, enable: bool) {
        unsafe {
            nm_sys::nm_secret_agent_old_enable(self.as_ref().to_glib_none().0, enable.to_glib());
        }
    }

    #[cfg(any(feature = "v1_24", feature = "dox"))]
    fn get_context_busy_watcher(&self) -> Option<glib::Object> {
        unsafe {
            from_glib_none(nm_sys::nm_secret_agent_old_get_context_busy_watcher(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(any(feature = "v1_24", feature = "dox"))]
    fn get_dbus_name_owner(&self) -> Option<GString> {
        unsafe {
            from_glib_none(nm_sys::nm_secret_agent_old_get_dbus_name_owner(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    //#[cfg(any(feature = "v1_24", feature = "dox"))]
    //fn get_main_context(&self) -> /*Ignored*/Option<glib::MainContext> {
    //    unsafe { TODO: call nm_sys:nm_secret_agent_old_get_main_context() }
    //}

    fn get_registered(&self) -> bool {
        unsafe {
            from_glib(nm_sys::nm_secret_agent_old_get_registered(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_secrets<
        P: IsA<Connection>,
        Q: FnOnce(&SecretAgentOld, &Connection, &glib::Variant, &glib::Error) + 'static,
    >(
        &self,
        connection: &P,
        setting_name: &str,
        hints: &[&str],
        flags: SecretAgentGetSecretsFlags,
        callback: Q,
    ) {
        let callback_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn callback_func<
            P: IsA<Connection>,
            Q: FnOnce(&SecretAgentOld, &Connection, &glib::Variant, &glib::Error) + 'static,
        >(
            agent: *mut nm_sys::NMSecretAgentOld,
            connection: *mut nm_sys::NMConnection,
            secrets: *mut glib_sys::GVariant,
            error: *mut glib_sys::GError,
            user_data: glib_sys::gpointer,
        ) {
            let agent = from_glib_borrow(agent);
            let connection = from_glib_borrow(connection);
            let secrets = from_glib_borrow(secrets);
            let error = from_glib_borrow(error);
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            (*callback)(&agent, &connection, &secrets, &error);
        }
        let callback = Some(callback_func::<P, Q> as _);
        let super_callback0: Box_<Q> = callback_data;
        unsafe {
            nm_sys::nm_secret_agent_old_get_secrets(
                self.as_ref().to_glib_none().0,
                connection.as_ref().to_glib_none().0,
                setting_name.to_glib_none().0,
                hints.to_glib_none().0,
                flags.to_glib(),
                callback,
                Box_::into_raw(super_callback0) as *mut _,
            );
        }
    }

    fn register<P: IsA<gio::Cancellable>>(
        &self,
        cancellable: Option<&P>,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = nm_sys::nm_secret_agent_old_register(
                self.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn register_async<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
    >(
        &self,
        cancellable: Option<&P>,
        callback: Q,
    ) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn register_async_trampoline<
            Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
        >(
            _source_object: *mut gobject_sys::GObject,
            res: *mut gio_sys::GAsyncResult,
            user_data: glib_sys::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let _ = nm_sys::nm_secret_agent_old_register_finish(
                _source_object as *mut _,
                res,
                &mut error,
            );
            let result = if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = register_async_trampoline::<Q>;
        unsafe {
            nm_sys::nm_secret_agent_old_register_async(
                self.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn register_async_future(
        &self,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {
        Box_::pin(gio::GioFuture::new(self, move |obj, send| {
            let cancellable = gio::Cancellable::new();
            obj.register_async(Some(&cancellable), move |res| {
                send.resolve(res);
            });

            cancellable
        }))
    }

    fn save_secrets<
        P: IsA<Connection>,
        Q: FnOnce(&SecretAgentOld, &Connection, &glib::Error) + 'static,
    >(
        &self,
        connection: &P,
        callback: Q,
    ) {
        let callback_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn callback_func<
            P: IsA<Connection>,
            Q: FnOnce(&SecretAgentOld, &Connection, &glib::Error) + 'static,
        >(
            agent: *mut nm_sys::NMSecretAgentOld,
            connection: *mut nm_sys::NMConnection,
            error: *mut glib_sys::GError,
            user_data: glib_sys::gpointer,
        ) {
            let agent = from_glib_borrow(agent);
            let connection = from_glib_borrow(connection);
            let error = from_glib_borrow(error);
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            (*callback)(&agent, &connection, &error);
        }
        let callback = Some(callback_func::<P, Q> as _);
        let super_callback0: Box_<Q> = callback_data;
        unsafe {
            nm_sys::nm_secret_agent_old_save_secrets(
                self.as_ref().to_glib_none().0,
                connection.as_ref().to_glib_none().0,
                callback,
                Box_::into_raw(super_callback0) as *mut _,
            );
        }
    }

    fn unregister<P: IsA<gio::Cancellable>>(
        &self,
        cancellable: Option<&P>,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = nm_sys::nm_secret_agent_old_unregister(
                self.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn unregister_async<
        P: IsA<gio::Cancellable>,
        Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
    >(
        &self,
        cancellable: Option<&P>,
        callback: Q,
    ) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn unregister_async_trampoline<
            Q: FnOnce(Result<(), glib::Error>) + Send + 'static,
        >(
            _source_object: *mut gobject_sys::GObject,
            res: *mut gio_sys::GAsyncResult,
            user_data: glib_sys::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let _ = nm_sys::nm_secret_agent_old_unregister_finish(
                _source_object as *mut _,
                res,
                &mut error,
            );
            let result = if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = unregister_async_trampoline::<Q>;
        unsafe {
            nm_sys::nm_secret_agent_old_unregister_async(
                self.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn unregister_async_future(
        &self,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {
        Box_::pin(gio::GioFuture::new(self, move |obj, send| {
            let cancellable = gio::Cancellable::new();
            obj.unregister_async(Some(&cancellable), move |res| {
                send.resolve(res);
            });

            cancellable
        }))
    }

    fn get_property_auto_register(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"auto-register\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `auto-register` getter")
                .unwrap()
        }
    }

    fn set_property_auto_register(&self, auto_register: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"auto-register\0".as_ptr() as *const _,
                Value::from(&auto_register).to_glib_none().0,
            );
        }
    }

    fn get_property_capabilities(&self) -> SecretAgentCapabilities {
        unsafe {
            let mut value =
                Value::from_type(<SecretAgentCapabilities as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"capabilities\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `capabilities` getter")
                .unwrap()
        }
    }

    fn set_property_capabilities(&self, capabilities: SecretAgentCapabilities) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"capabilities\0".as_ptr() as *const _,
                Value::from(&capabilities).to_glib_none().0,
            );
        }
    }

    fn get_property_identifier(&self) -> Option<GString> {
        unsafe {
            let mut value = Value::from_type(<GString as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"identifier\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `identifier` getter")
        }
    }

    fn connect_property_auto_register_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_auto_register_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSecretAgentOld,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SecretAgentOld>,
        {
            let f: &F = &*(f as *const F);
            f(&SecretAgentOld::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::auto-register\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_auto_register_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_capabilities_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_capabilities_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSecretAgentOld,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SecretAgentOld>,
        {
            let f: &F = &*(f as *const F);
            f(&SecretAgentOld::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::capabilities\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_capabilities_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_registered_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_registered_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut nm_sys::NMSecretAgentOld,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<SecretAgentOld>,
        {
            let f: &F = &*(f as *const F);
            f(&SecretAgentOld::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::registered\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_registered_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl fmt::Display for SecretAgentOld {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "SecretAgentOld")
    }
}
