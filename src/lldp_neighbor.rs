// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files
// DO NOT EDIT

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
use glib::translate::*;
#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
use std::mem;

glib::wrapper! {
    /// Supported attributes are:
    ///
    /// - [`LLDP_ATTR_CHASSIS_ID_TYPE`][crate::LLDP_ATTR_CHASSIS_ID_TYPE] (type: 'u')
    /// - [`LLDP_ATTR_CHASSIS_ID`][crate::LLDP_ATTR_CHASSIS_ID] (type: 's')
    /// - [`LLDP_ATTR_DESTINATION`][crate::LLDP_ATTR_DESTINATION] (type: 's')
    /// - [`LLDP_ATTR_IEEE_802_1_PPVID`][crate::LLDP_ATTR_IEEE_802_1_PPVID] (type: 'u'). This attribute only reports the first PPVID
    ///  and therefore it is deprecated in favor of NM_LLDP_ATTR_IEEE_802_1_PPVIDS which reports
    ///  all the PPVID.
    /// - [`LLDP_ATTR_IEEE_802_1_PPVID_FLAGS`][crate::LLDP_ATTR_IEEE_802_1_PPVID_FLAGS] (type: 'u'). This attribute only reports the first PPVID
    ///  and therefore it is deprecated in favor of NM_LLDP_ATTR_IEEE_802_1_PPVIDS which reports
    ///  all the PPVID.
    /// - [`LLDP_ATTR_IEEE_802_1_PPVIDS`][crate::LLDP_ATTR_IEEE_802_1_PPVIDS] (type: 'aa{sv}')
    ///
    ///  An array of dictionaries where each element has keys:
    ///  - flags (type: 'u')
    ///  - ppvid (type: 'u')
    /// - [`LLDP_ATTR_IEEE_802_1_PVID`][crate::LLDP_ATTR_IEEE_802_1_PVID] (type: 'u')
    /// - [`LLDP_ATTR_IEEE_802_1_VID`][crate::LLDP_ATTR_IEEE_802_1_VID] (type: 'u'). This attribute only reports the first VLAN
    ///  and therefore it is deprecated in favor of NM_LLDP_ATTR_IEEE_802_1_VLANS which reports
    ///  all the VLANs.
    /// - [`LLDP_ATTR_IEEE_802_1_VLAN_NAME`][crate::LLDP_ATTR_IEEE_802_1_VLAN_NAME] (type: 's'). This attribute only reports the first VLAN
    ///  and therefore it is deprecated in favor of NM_LLDP_ATTR_IEEE_802_1_VLANS which reports
    ///  all the VLANs.
    /// - [`LLDP_ATTR_IEEE_802_1_VLANS`][crate::LLDP_ATTR_IEEE_802_1_VLANS] (type: 'aa{sv}')
    ///
    ///  An array of dictionaries where each element has keys:
    ///  - name (type: 's')
    ///  - vid (type: 'u')
    /// - [`LLDP_ATTR_IEEE_802_3_MAC_PHY_CONF`][crate::LLDP_ATTR_IEEE_802_3_MAC_PHY_CONF] (type: 'a{sv}')
    ///
    ///  Dictionary where each element has keys:
    ///  - autoneg (type: 'u')
    ///  - operational-mau-type (type: 'u')
    ///  - pmd-autoneg-cap (type: 'u')
    /// - [`LLDP_ATTR_IEEE_802_3_MAX_FRAME_SIZE`][crate::LLDP_ATTR_IEEE_802_3_MAX_FRAME_SIZE] (type: 'u')
    /// - [`LLDP_ATTR_IEEE_802_3_POWER_VIA_MDI`][crate::LLDP_ATTR_IEEE_802_3_POWER_VIA_MDI] (type: 'a{sv}')
    ///
    ///  Dictionary where each element has keys:
    ///  - mdi-power-support (type: 'u')
    ///  - power-class (type: 'u')
    ///  - pse-power-pair (type: 'u')
    /// - [`LLDP_ATTR_MANAGEMENT_ADDRESSES`][crate::LLDP_ATTR_MANAGEMENT_ADDRESSES] (type: 'aa{sv}')
    ///
    ///  An array of dictionaries where each element has keys:
    ///  - address (type: 'ay')
    ///  - address-subtype (type: 'u')
    ///  - interface-number (type: 'u')
    ///  - interface-number-subtype (type: 'u')
    ///  - object-id (type: 'ay')
    /// - [`LLDP_ATTR_PORT_DESCRIPTION`][crate::LLDP_ATTR_PORT_DESCRIPTION] (type: 's')
    /// - [`LLDP_ATTR_PORT_ID_TYPE`][crate::LLDP_ATTR_PORT_ID_TYPE] (type: 'u')
    /// - [`LLDP_ATTR_PORT_ID`][crate::LLDP_ATTR_PORT_ID] (type: 's')
    /// - [`LLDP_ATTR_RAW`][crate::LLDP_ATTR_RAW] (type: 'ay')
    /// - [`LLDP_ATTR_SYSTEM_CAPABILITIES`][crate::LLDP_ATTR_SYSTEM_CAPABILITIES] (type: 'u')
    /// - [`LLDP_ATTR_SYSTEM_DESCRIPTION`][crate::LLDP_ATTR_SYSTEM_DESCRIPTION] (type: 's')
    /// - [`LLDP_ATTR_SYSTEM_NAME`][crate::LLDP_ATTR_SYSTEM_NAME] (type: 's')
    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct LldpNeighbor(Shared<ffi::NMLldpNeighbor>);

    match fn {
        ref => |ptr| ffi::nm_lldp_neighbor_ref(ptr),
        unref => |ptr| ffi::nm_lldp_neighbor_unref(ptr),
        type_ => || ffi::nm_lldp_neighbor_get_type(),
    }
}

impl LldpNeighbor {
    /// Creates a new [`LldpNeighbor`][crate::LldpNeighbor] object.
    ///
    /// Note that [`LldpNeighbor`][crate::LldpNeighbor] has no public API for mutating
    /// an instance. Also, libnm will not internally mutate a
    /// once exposed object. They are guaranteed to be immutable.
    /// Since 1.32, ref-counting is thread-safe.
    ///
    /// This function is not useful, as there is no public API to
    /// actually modify the (empty) instance.
    ///
    /// # Returns
    ///
    /// the new [`LldpNeighbor`][crate::LldpNeighbor] object.
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_lldp_neighbor_new")]
    pub fn new() -> LldpNeighbor {
        unsafe { from_glib_full(ffi::nm_lldp_neighbor_new()) }
    }

    /// Get the type of an attribute.
    /// ## `name`
    /// the attribute name
    ///
    /// # Returns
    ///
    /// the [`glib::VariantType`][crate::glib::VariantType] of the attribute with name `name`
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_lldp_neighbor_get_attr_type")]
    #[doc(alias = "get_attr_type")]
    pub fn attr_type(&self, name: &str) -> Option<glib::VariantType> {
        unsafe {
            from_glib_none(ffi::nm_lldp_neighbor_get_attr_type(
                self.to_glib_none().0,
                name.to_glib_none().0,
            ))
        }
    }

    /// Gets the uint32 value of attribute with name `name` on `self`
    /// ## `name`
    /// the attribute name
    ///
    /// # Returns
    ///
    /// [`true`] if a uint32 attribute with name `name` was found, [`false`] otherwise
    ///
    /// ## `out_value`
    /// on return, the attribute value
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_lldp_neighbor_get_attr_uint_value")]
    #[doc(alias = "get_attr_uint_value")]
    pub fn attr_uint_value(&self, name: &str) -> Option<u32> {
        unsafe {
            let mut out_value = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::nm_lldp_neighbor_get_attr_uint_value(
                self.to_glib_none().0,
                name.to_glib_none().0,
                out_value.as_mut_ptr(),
            ));
            if ret {
                Some(out_value.assume_init())
            } else {
                None
            }
        }
    }

    /// Gets the value (as a GVariant) of attribute with name `name` on `self`
    /// ## `name`
    /// the attribute name
    ///
    /// # Returns
    ///
    /// the value or [`None`] if the attribute with `name` was
    /// not found.
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    #[doc(alias = "nm_lldp_neighbor_get_attr_value")]
    #[doc(alias = "get_attr_value")]
    pub fn attr_value(&self, name: &str) -> Option<glib::Variant> {
        unsafe {
            from_glib_none(ffi::nm_lldp_neighbor_get_attr_value(
                self.to_glib_none().0,
                name.to_glib_none().0,
            ))
        }
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
impl Default for LldpNeighbor {
    fn default() -> Self {
        Self::new()
    }
}
