// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files
// DO NOT EDIT

use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::ToValue;
use glib::Quark;
use glib::StaticType;
use glib::Type;
use std::fmt;

/// [`ActiveConnectionState`][crate::ActiveConnectionState] values indicate the state of a connection to a
/// specific network while it is starting, connected, or disconnecting from that
/// network.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMActiveConnectionState")]
pub enum ActiveConnectionState {
    /// the state of the connection is unknown
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_UNKNOWN")]
    Unknown,
    /// a network connection is being prepared
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_ACTIVATING")]
    Activating,
    /// there is a connection to the network
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_ACTIVATED")]
    Activated,
    /// the network connection is being
    ///  torn down and cleaned up
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_DEACTIVATING")]
    Deactivating,
    /// the network connection is disconnected
    ///  and will be removed
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_DEACTIVATED")]
    Deactivated,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ActiveConnectionState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ActiveConnectionState::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::Activating => "Activating",
                Self::Activated => "Activated",
                Self::Deactivating => "Deactivating",
                Self::Deactivated => "Deactivated",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for ActiveConnectionState {
    type GlibType = ffi::NMActiveConnectionState;

    fn into_glib(self) -> ffi::NMActiveConnectionState {
        match self {
            Self::Unknown => ffi::NM_ACTIVE_CONNECTION_STATE_UNKNOWN,
            Self::Activating => ffi::NM_ACTIVE_CONNECTION_STATE_ACTIVATING,
            Self::Activated => ffi::NM_ACTIVE_CONNECTION_STATE_ACTIVATED,
            Self::Deactivating => ffi::NM_ACTIVE_CONNECTION_STATE_DEACTIVATING,
            Self::Deactivated => ffi::NM_ACTIVE_CONNECTION_STATE_DEACTIVATED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMActiveConnectionState> for ActiveConnectionState {
    unsafe fn from_glib(value: ffi::NMActiveConnectionState) -> Self {
        match value {
            ffi::NM_ACTIVE_CONNECTION_STATE_UNKNOWN => Self::Unknown,
            ffi::NM_ACTIVE_CONNECTION_STATE_ACTIVATING => Self::Activating,
            ffi::NM_ACTIVE_CONNECTION_STATE_ACTIVATED => Self::Activated,
            ffi::NM_ACTIVE_CONNECTION_STATE_DEACTIVATING => Self::Deactivating,
            ffi::NM_ACTIVE_CONNECTION_STATE_DEACTIVATED => Self::Deactivated,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ActiveConnectionState {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_active_connection_state_get_type()) }
    }
}

impl glib::value::ValueType for ActiveConnectionState {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ActiveConnectionState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ActiveConnectionState {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// Active connection state reasons.
#[cfg(any(feature = "v1_8", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMActiveConnectionStateReason")]
pub enum ActiveConnectionStateReason {
    /// The reason for the active connection
    ///  state change is unknown.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_UNKNOWN")]
    Unknown,
    /// No reason was given for the active
    ///  connection state change.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_NONE")]
    None,
    /// The active connection changed
    ///  state because the user disconnected it.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_USER_DISCONNECTED")]
    UserDisconnected,
    /// The active connection
    ///  changed state because the device it was using was disconnected.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED")]
    DeviceDisconnected,
    /// The service providing the
    ///  VPN connection was stopped.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_STOPPED")]
    ServiceStopped,
    /// The IP config of the active
    ///  connection was invalid.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_IP_CONFIG_INVALID")]
    IpConfigInvalid,
    /// The connection attempt to
    ///  the VPN service timed out.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_CONNECT_TIMEOUT")]
    ConnectTimeout,
    /// A timeout occurred
    ///  while starting the service providing the VPN connection.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT")]
    ServiceStartTimeout,
    /// Starting the service
    ///  providing the VPN connection failed.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_FAILED")]
    ServiceStartFailed,
    /// Necessary secrets for the
    ///  connection were not provided.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_NO_SECRETS")]
    NoSecrets,
    /// Authentication to the
    ///  server failed.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_LOGIN_FAILED")]
    LoginFailed,
    /// The connection was
    ///  deleted from settings.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_CONNECTION_REMOVED")]
    ConnectionRemoved,
    /// Master connection of this
    ///  connection failed to activate.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_DEPENDENCY_FAILED")]
    DependencyFailed,
    /// Could not create the
    ///  software device link.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REALIZE_FAILED")]
    DeviceRealizeFailed,
    /// The device this connection
    ///  depended on disappeared.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REMOVED")]
    DeviceRemoved,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
impl fmt::Display for ActiveConnectionStateReason {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ActiveConnectionStateReason::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::None => "None",
                Self::UserDisconnected => "UserDisconnected",
                Self::DeviceDisconnected => "DeviceDisconnected",
                Self::ServiceStopped => "ServiceStopped",
                Self::IpConfigInvalid => "IpConfigInvalid",
                Self::ConnectTimeout => "ConnectTimeout",
                Self::ServiceStartTimeout => "ServiceStartTimeout",
                Self::ServiceStartFailed => "ServiceStartFailed",
                Self::NoSecrets => "NoSecrets",
                Self::LoginFailed => "LoginFailed",
                Self::ConnectionRemoved => "ConnectionRemoved",
                Self::DependencyFailed => "DependencyFailed",
                Self::DeviceRealizeFailed => "DeviceRealizeFailed",
                Self::DeviceRemoved => "DeviceRemoved",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
#[doc(hidden)]
impl IntoGlib for ActiveConnectionStateReason {
    type GlibType = ffi::NMActiveConnectionStateReason;

    fn into_glib(self) -> ffi::NMActiveConnectionStateReason {
        match self {
            Self::Unknown => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_UNKNOWN,
            Self::None => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_NONE,
            Self::UserDisconnected => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_USER_DISCONNECTED,
            Self::DeviceDisconnected => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED,
            Self::ServiceStopped => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_STOPPED,
            Self::IpConfigInvalid => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_IP_CONFIG_INVALID,
            Self::ConnectTimeout => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_CONNECT_TIMEOUT,
            Self::ServiceStartTimeout => {
                ffi::NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT
            }
            Self::ServiceStartFailed => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_FAILED,
            Self::NoSecrets => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_NO_SECRETS,
            Self::LoginFailed => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_LOGIN_FAILED,
            Self::ConnectionRemoved => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_CONNECTION_REMOVED,
            Self::DependencyFailed => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_DEPENDENCY_FAILED,
            Self::DeviceRealizeFailed => {
                ffi::NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REALIZE_FAILED
            }
            Self::DeviceRemoved => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REMOVED,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
#[doc(hidden)]
impl FromGlib<ffi::NMActiveConnectionStateReason> for ActiveConnectionStateReason {
    unsafe fn from_glib(value: ffi::NMActiveConnectionStateReason) -> Self {
        match value {
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_UNKNOWN => Self::Unknown,
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_NONE => Self::None,
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_USER_DISCONNECTED => Self::UserDisconnected,
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED => Self::DeviceDisconnected,
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_STOPPED => Self::ServiceStopped,
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_IP_CONFIG_INVALID => Self::IpConfigInvalid,
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_CONNECT_TIMEOUT => Self::ConnectTimeout,
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT => {
                Self::ServiceStartTimeout
            }
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_FAILED => Self::ServiceStartFailed,
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_NO_SECRETS => Self::NoSecrets,
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_LOGIN_FAILED => Self::LoginFailed,
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_CONNECTION_REMOVED => Self::ConnectionRemoved,
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_DEPENDENCY_FAILED => Self::DependencyFailed,
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REALIZE_FAILED => {
                Self::DeviceRealizeFailed
            }
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REMOVED => Self::DeviceRemoved,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
impl StaticType for ActiveConnectionStateReason {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_active_connection_state_reason_get_type()) }
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
impl glib::value::ValueType for ActiveConnectionStateReason {
    type Type = Self;
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
unsafe impl<'a> FromValue<'a> for ActiveConnectionStateReason {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_8")))]
impl ToValue for ActiveConnectionStateReason {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// Errors returned from the secret-agent manager.
///
/// These errors may be returned from operations that could cause secrets to be
/// requested (such as `nm_client_activate_connection()`), and correspond to D-Bus
/// errors in the "org.freedesktop.NetworkManager.AgentManager" namespace.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMAgentManagerError")]
pub enum AgentManagerError {
    /// unknown or unspecified error
    #[doc(alias = "NM_AGENT_MANAGER_ERROR_FAILED")]
    Failed,
    /// The caller does not have permission
    ///  to register a secret agent, or is trying to register the same secret agent
    ///  twice.
    #[doc(alias = "NM_AGENT_MANAGER_ERROR_PERMISSION_DENIED")]
    PermissionDenied,
    /// The identifier is not a valid
    ///  secret agent identifier.
    #[doc(alias = "NM_AGENT_MANAGER_ERROR_INVALID_IDENTIFIER")]
    InvalidIdentifier,
    /// The caller tried to unregister an agent
    ///  that was not registered.
    #[doc(alias = "NM_AGENT_MANAGER_ERROR_NOT_REGISTERED")]
    NotRegistered,
    /// No secret agent returned secrets for this
    ///  request
    #[doc(alias = "NM_AGENT_MANAGER_ERROR_NO_SECRETS")]
    NoSecrets,
    /// The user canceled the secrets request.
    #[doc(alias = "NM_AGENT_MANAGER_ERROR_USER_CANCELED")]
    UserCanceled,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AgentManagerError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AgentManagerError::{}",
            match *self {
                Self::Failed => "Failed",
                Self::PermissionDenied => "PermissionDenied",
                Self::InvalidIdentifier => "InvalidIdentifier",
                Self::NotRegistered => "NotRegistered",
                Self::NoSecrets => "NoSecrets",
                Self::UserCanceled => "UserCanceled",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for AgentManagerError {
    type GlibType = ffi::NMAgentManagerError;

    fn into_glib(self) -> ffi::NMAgentManagerError {
        match self {
            Self::Failed => ffi::NM_AGENT_MANAGER_ERROR_FAILED,
            Self::PermissionDenied => ffi::NM_AGENT_MANAGER_ERROR_PERMISSION_DENIED,
            Self::InvalidIdentifier => ffi::NM_AGENT_MANAGER_ERROR_INVALID_IDENTIFIER,
            Self::NotRegistered => ffi::NM_AGENT_MANAGER_ERROR_NOT_REGISTERED,
            Self::NoSecrets => ffi::NM_AGENT_MANAGER_ERROR_NO_SECRETS,
            Self::UserCanceled => ffi::NM_AGENT_MANAGER_ERROR_USER_CANCELED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMAgentManagerError> for AgentManagerError {
    unsafe fn from_glib(value: ffi::NMAgentManagerError) -> Self {
        match value {
            ffi::NM_AGENT_MANAGER_ERROR_FAILED => Self::Failed,
            ffi::NM_AGENT_MANAGER_ERROR_PERMISSION_DENIED => Self::PermissionDenied,
            ffi::NM_AGENT_MANAGER_ERROR_INVALID_IDENTIFIER => Self::InvalidIdentifier,
            ffi::NM_AGENT_MANAGER_ERROR_NOT_REGISTERED => Self::NotRegistered,
            ffi::NM_AGENT_MANAGER_ERROR_NO_SECRETS => Self::NoSecrets,
            ffi::NM_AGENT_MANAGER_ERROR_USER_CANCELED => Self::UserCanceled,
            value => Self::__Unknown(value),
        }
    }
}

impl ErrorDomain for AgentManagerError {
    fn domain() -> Quark {
        unsafe { from_glib(ffi::nm_agent_manager_error_quark()) }
    }

    fn code(self) -> i32 {
        self.into_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            ffi::NM_AGENT_MANAGER_ERROR_FAILED => Some(Self::Failed),
            ffi::NM_AGENT_MANAGER_ERROR_PERMISSION_DENIED => Some(Self::PermissionDenied),
            ffi::NM_AGENT_MANAGER_ERROR_INVALID_IDENTIFIER => Some(Self::InvalidIdentifier),
            ffi::NM_AGENT_MANAGER_ERROR_NOT_REGISTERED => Some(Self::NotRegistered),
            ffi::NM_AGENT_MANAGER_ERROR_NO_SECRETS => Some(Self::NoSecrets),
            ffi::NM_AGENT_MANAGER_ERROR_USER_CANCELED => Some(Self::UserCanceled),
            _ => Some(Self::Failed),
        }
    }
}

impl StaticType for AgentManagerError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_agent_manager_error_get_type()) }
    }
}

impl glib::value::ValueType for AgentManagerError {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for AgentManagerError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AgentManagerError {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// [`Capability`][crate::Capability] names the numbers in the Capabilities property.
/// Capabilities are positive numbers. They are part of stable API
/// and a certain capability number is guaranteed not to change.
///
/// The range 0x7000 - 0x7FFF of capabilities is guaranteed not to be
/// used by upstream NetworkManager. It could thus be used for downstream
/// extensions.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMCapability")]
pub enum Capability {
    /// Teams can be managed. This means the team device plugin
    ///  is loaded.
    #[doc(alias = "NM_CAPABILITY_TEAM")]
    Team,
    /// OpenVSwitch can be managed. This means the OVS device plugin
    ///  is loaded. Since: 1.24.
    #[doc(alias = "NM_CAPABILITY_OVS")]
    Ovs,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Capability {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Capability::{}",
            match *self {
                Self::Team => "Team",
                Self::Ovs => "Ovs",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for Capability {
    type GlibType = ffi::NMCapability;

    fn into_glib(self) -> ffi::NMCapability {
        match self {
            Self::Team => ffi::NM_CAPABILITY_TEAM,
            Self::Ovs => ffi::NM_CAPABILITY_OVS,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMCapability> for Capability {
    unsafe fn from_glib(value: ffi::NMCapability) -> Self {
        match value {
            ffi::NM_CAPABILITY_TEAM => Self::Team,
            ffi::NM_CAPABILITY_OVS => Self::Ovs,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for Capability {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_capability_get_type()) }
    }
}

impl glib::value::ValueType for Capability {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for Capability {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for Capability {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// Describes errors that may result from operations involving a [`Client`][crate::Client].
///
/// D-Bus operations may also return errors from other domains, including
/// [`ManagerError`][crate::ManagerError], [`SettingsError`][crate::SettingsError], [`AgentManagerError`][crate::AgentManagerError], and [`ConnectionError`][crate::ConnectionError].
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMClientError")]
pub enum ClientError {
    /// unknown or unclassified error
    #[doc(alias = "NM_CLIENT_ERROR_FAILED")]
    Failed,
    /// an operation that requires NetworkManager
    ///  failed because NetworkManager is not running
    #[doc(alias = "NM_CLIENT_ERROR_MANAGER_NOT_RUNNING")]
    ManagerNotRunning,
    /// NetworkManager claimed that an
    ///  operation succeeded, but the object that was allegedly created (eg,
    ///  [`RemoteConnection`][crate::RemoteConnection], [`ActiveConnection`][crate::ActiveConnection]) was apparently destroyed before
    ///  [`Client`][crate::Client] could create a representation of it.
    #[doc(alias = "NM_CLIENT_ERROR_OBJECT_CREATION_FAILED")]
    ObjectCreationFailed,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ClientError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ClientError::{}",
            match *self {
                Self::Failed => "Failed",
                Self::ManagerNotRunning => "ManagerNotRunning",
                Self::ObjectCreationFailed => "ObjectCreationFailed",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for ClientError {
    type GlibType = ffi::NMClientError;

    fn into_glib(self) -> ffi::NMClientError {
        match self {
            Self::Failed => ffi::NM_CLIENT_ERROR_FAILED,
            Self::ManagerNotRunning => ffi::NM_CLIENT_ERROR_MANAGER_NOT_RUNNING,
            Self::ObjectCreationFailed => ffi::NM_CLIENT_ERROR_OBJECT_CREATION_FAILED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMClientError> for ClientError {
    unsafe fn from_glib(value: ffi::NMClientError) -> Self {
        match value {
            ffi::NM_CLIENT_ERROR_FAILED => Self::Failed,
            ffi::NM_CLIENT_ERROR_MANAGER_NOT_RUNNING => Self::ManagerNotRunning,
            ffi::NM_CLIENT_ERROR_OBJECT_CREATION_FAILED => Self::ObjectCreationFailed,
            value => Self::__Unknown(value),
        }
    }
}

impl ErrorDomain for ClientError {
    fn domain() -> Quark {
        unsafe { from_glib(ffi::nm_client_error_quark()) }
    }

    fn code(self) -> i32 {
        self.into_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            ffi::NM_CLIENT_ERROR_FAILED => Some(Self::Failed),
            ffi::NM_CLIENT_ERROR_MANAGER_NOT_RUNNING => Some(Self::ManagerNotRunning),
            ffi::NM_CLIENT_ERROR_OBJECT_CREATION_FAILED => Some(Self::ObjectCreationFailed),
            _ => Some(Self::Failed),
        }
    }
}

impl StaticType for ClientError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_client_error_get_type()) }
    }
}

impl glib::value::ValueType for ClientError {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ClientError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ClientError {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// [`ClientPermission`][crate::ClientPermission] values indicate various permissions that NetworkManager
/// clients can obtain to perform certain tasks on behalf of the current user.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMClientPermission")]
pub enum ClientPermission {
    /// unknown or no permission
    #[doc(alias = "NM_CLIENT_PERMISSION_NONE")]
    None,
    /// controls whether networking
    ///  can be globally enabled or disabled
    #[doc(alias = "NM_CLIENT_PERMISSION_ENABLE_DISABLE_NETWORK")]
    EnableDisableNetwork,
    /// controls whether Wi-Fi can be
    ///  globally enabled or disabled
    #[doc(alias = "NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIFI")]
    EnableDisableWifi,
    /// controls whether WWAN (3G) can be
    ///  globally enabled or disabled
    #[doc(alias = "NM_CLIENT_PERMISSION_ENABLE_DISABLE_WWAN")]
    EnableDisableWwan,
    /// controls whether WiMAX can be
    ///  globally enabled or disabled
    #[doc(alias = "NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIMAX")]
    EnableDisableWimax,
    /// controls whether the client can ask
    ///  NetworkManager to sleep and wake
    #[doc(alias = "NM_CLIENT_PERMISSION_SLEEP_WAKE")]
    SleepWake,
    /// controls whether networking connections
    ///  can be started, stopped, and changed
    #[doc(alias = "NM_CLIENT_PERMISSION_NETWORK_CONTROL")]
    NetworkControl,
    /// controls whether a password
    ///  protected Wi-Fi hotspot can be created
    #[doc(alias = "NM_CLIENT_PERMISSION_WIFI_SHARE_PROTECTED")]
    WifiShareProtected,
    /// controls whether an open Wi-Fi hotspot
    ///  can be created
    #[doc(alias = "NM_CLIENT_PERMISSION_WIFI_SHARE_OPEN")]
    WifiShareOpen,
    /// controls whether connections
    ///  that are available to all users can be modified
    #[doc(alias = "NM_CLIENT_PERMISSION_SETTINGS_MODIFY_SYSTEM")]
    SettingsModifySystem,
    /// controls whether connections
    ///  owned by the current user can be modified
    #[doc(alias = "NM_CLIENT_PERMISSION_SETTINGS_MODIFY_OWN")]
    SettingsModifyOwn,
    /// controls whether the
    ///  persistent hostname can be changed
    #[doc(alias = "NM_CLIENT_PERMISSION_SETTINGS_MODIFY_HOSTNAME")]
    SettingsModifyHostname,
    /// modify persistent global
    ///  DNS configuration
    #[doc(alias = "NM_CLIENT_PERMISSION_SETTINGS_MODIFY_GLOBAL_DNS")]
    SettingsModifyGlobalDns,
    /// controls access to Reload.
    #[doc(alias = "NM_CLIENT_PERMISSION_RELOAD")]
    Reload,
    /// permission to create checkpoints.
    #[doc(alias = "NM_CLIENT_PERMISSION_CHECKPOINT_ROLLBACK")]
    CheckpointRollback,
    /// controls whether device
    ///  statistics can be globally enabled or disabled
    #[doc(alias = "NM_CLIENT_PERMISSION_ENABLE_DISABLE_STATISTICS")]
    EnableDisableStatistics,
    /// controls whether
    ///  connectivity check can be enabled or disabled
    #[doc(alias = "NM_CLIENT_PERMISSION_ENABLE_DISABLE_CONNECTIVITY_CHECK")]
    EnableDisableConnectivityCheck,
    /// controls whether wifi scans can be performed
    #[doc(alias = "NM_CLIENT_PERMISSION_WIFI_SCAN")]
    WifiScan,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ClientPermission {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ClientPermission::{}",
            match *self {
                Self::None => "None",
                Self::EnableDisableNetwork => "EnableDisableNetwork",
                Self::EnableDisableWifi => "EnableDisableWifi",
                Self::EnableDisableWwan => "EnableDisableWwan",
                Self::EnableDisableWimax => "EnableDisableWimax",
                Self::SleepWake => "SleepWake",
                Self::NetworkControl => "NetworkControl",
                Self::WifiShareProtected => "WifiShareProtected",
                Self::WifiShareOpen => "WifiShareOpen",
                Self::SettingsModifySystem => "SettingsModifySystem",
                Self::SettingsModifyOwn => "SettingsModifyOwn",
                Self::SettingsModifyHostname => "SettingsModifyHostname",
                Self::SettingsModifyGlobalDns => "SettingsModifyGlobalDns",
                Self::Reload => "Reload",
                Self::CheckpointRollback => "CheckpointRollback",
                Self::EnableDisableStatistics => "EnableDisableStatistics",
                Self::EnableDisableConnectivityCheck => "EnableDisableConnectivityCheck",
                Self::WifiScan => "WifiScan",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for ClientPermission {
    type GlibType = ffi::NMClientPermission;

    fn into_glib(self) -> ffi::NMClientPermission {
        match self {
            Self::None => ffi::NM_CLIENT_PERMISSION_NONE,
            Self::EnableDisableNetwork => ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_NETWORK,
            Self::EnableDisableWifi => ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIFI,
            Self::EnableDisableWwan => ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_WWAN,
            Self::EnableDisableWimax => ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIMAX,
            Self::SleepWake => ffi::NM_CLIENT_PERMISSION_SLEEP_WAKE,
            Self::NetworkControl => ffi::NM_CLIENT_PERMISSION_NETWORK_CONTROL,
            Self::WifiShareProtected => ffi::NM_CLIENT_PERMISSION_WIFI_SHARE_PROTECTED,
            Self::WifiShareOpen => ffi::NM_CLIENT_PERMISSION_WIFI_SHARE_OPEN,
            Self::SettingsModifySystem => ffi::NM_CLIENT_PERMISSION_SETTINGS_MODIFY_SYSTEM,
            Self::SettingsModifyOwn => ffi::NM_CLIENT_PERMISSION_SETTINGS_MODIFY_OWN,
            Self::SettingsModifyHostname => ffi::NM_CLIENT_PERMISSION_SETTINGS_MODIFY_HOSTNAME,
            Self::SettingsModifyGlobalDns => ffi::NM_CLIENT_PERMISSION_SETTINGS_MODIFY_GLOBAL_DNS,
            Self::Reload => ffi::NM_CLIENT_PERMISSION_RELOAD,
            Self::CheckpointRollback => ffi::NM_CLIENT_PERMISSION_CHECKPOINT_ROLLBACK,
            Self::EnableDisableStatistics => ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_STATISTICS,
            Self::EnableDisableConnectivityCheck => {
                ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_CONNECTIVITY_CHECK
            }
            Self::WifiScan => ffi::NM_CLIENT_PERMISSION_WIFI_SCAN,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMClientPermission> for ClientPermission {
    unsafe fn from_glib(value: ffi::NMClientPermission) -> Self {
        match value {
            ffi::NM_CLIENT_PERMISSION_NONE => Self::None,
            ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_NETWORK => Self::EnableDisableNetwork,
            ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIFI => Self::EnableDisableWifi,
            ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_WWAN => Self::EnableDisableWwan,
            ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIMAX => Self::EnableDisableWimax,
            ffi::NM_CLIENT_PERMISSION_SLEEP_WAKE => Self::SleepWake,
            ffi::NM_CLIENT_PERMISSION_NETWORK_CONTROL => Self::NetworkControl,
            ffi::NM_CLIENT_PERMISSION_WIFI_SHARE_PROTECTED => Self::WifiShareProtected,
            ffi::NM_CLIENT_PERMISSION_WIFI_SHARE_OPEN => Self::WifiShareOpen,
            ffi::NM_CLIENT_PERMISSION_SETTINGS_MODIFY_SYSTEM => Self::SettingsModifySystem,
            ffi::NM_CLIENT_PERMISSION_SETTINGS_MODIFY_OWN => Self::SettingsModifyOwn,
            ffi::NM_CLIENT_PERMISSION_SETTINGS_MODIFY_HOSTNAME => Self::SettingsModifyHostname,
            ffi::NM_CLIENT_PERMISSION_SETTINGS_MODIFY_GLOBAL_DNS => Self::SettingsModifyGlobalDns,
            ffi::NM_CLIENT_PERMISSION_RELOAD => Self::Reload,
            ffi::NM_CLIENT_PERMISSION_CHECKPOINT_ROLLBACK => Self::CheckpointRollback,
            ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_STATISTICS => Self::EnableDisableStatistics,
            ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_CONNECTIVITY_CHECK => {
                Self::EnableDisableConnectivityCheck
            }
            ffi::NM_CLIENT_PERMISSION_WIFI_SCAN => Self::WifiScan,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ClientPermission {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_client_permission_get_type()) }
    }
}

impl glib::value::ValueType for ClientPermission {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ClientPermission {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ClientPermission {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// [`ClientPermissionResult`][crate::ClientPermissionResult] values indicate what authorizations and permissions
/// the user requires to obtain a given [`ClientPermission`][crate::ClientPermission]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMClientPermissionResult")]
pub enum ClientPermissionResult {
    /// unknown or no authorization
    #[doc(alias = "NM_CLIENT_PERMISSION_RESULT_UNKNOWN")]
    Unknown,
    /// the permission is available
    #[doc(alias = "NM_CLIENT_PERMISSION_RESULT_YES")]
    Yes,
    /// authorization is necessary before the
    ///  permission is available
    #[doc(alias = "NM_CLIENT_PERMISSION_RESULT_AUTH")]
    Auth,
    /// permission to perform the operation is
    ///  denied by system policy
    #[doc(alias = "NM_CLIENT_PERMISSION_RESULT_NO")]
    No,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ClientPermissionResult {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ClientPermissionResult::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::Yes => "Yes",
                Self::Auth => "Auth",
                Self::No => "No",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for ClientPermissionResult {
    type GlibType = ffi::NMClientPermissionResult;

    fn into_glib(self) -> ffi::NMClientPermissionResult {
        match self {
            Self::Unknown => ffi::NM_CLIENT_PERMISSION_RESULT_UNKNOWN,
            Self::Yes => ffi::NM_CLIENT_PERMISSION_RESULT_YES,
            Self::Auth => ffi::NM_CLIENT_PERMISSION_RESULT_AUTH,
            Self::No => ffi::NM_CLIENT_PERMISSION_RESULT_NO,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMClientPermissionResult> for ClientPermissionResult {
    unsafe fn from_glib(value: ffi::NMClientPermissionResult) -> Self {
        match value {
            ffi::NM_CLIENT_PERMISSION_RESULT_UNKNOWN => Self::Unknown,
            ffi::NM_CLIENT_PERMISSION_RESULT_YES => Self::Yes,
            ffi::NM_CLIENT_PERMISSION_RESULT_AUTH => Self::Auth,
            ffi::NM_CLIENT_PERMISSION_RESULT_NO => Self::No,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ClientPermissionResult {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_client_permission_result_get_type()) }
    }
}

impl glib::value::ValueType for ClientPermissionResult {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ClientPermissionResult {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ClientPermissionResult {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// Describes errors that may result from operations involving a [`Connection`][crate::Connection]
/// or its `NMSettings`.
///
/// These errors may be returned directly from [`Connection`][crate::Connection] and [`Setting`][crate::Setting]
/// methods, or may be returned from D-Bus operations (eg on [`Client`][crate::Client] or
/// [`Device`][crate::Device]), where they correspond to errors in the
/// "org.freedesktop.NetworkManager.Settings.Connection" namespace.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMConnectionError")]
pub enum ConnectionError {
    /// unknown or unclassified error
    #[doc(alias = "NM_CONNECTION_ERROR_FAILED")]
    Failed,
    /// the [`Connection`][crate::Connection] object
    ///  did not contain the specified [`Setting`][crate::Setting] object
    #[doc(alias = "NM_CONNECTION_ERROR_SETTING_NOT_FOUND")]
    SettingNotFound,
    /// the [`Connection`][crate::Connection] did not contain the
    ///  requested [`Setting`][crate::Setting] property
    #[doc(alias = "NM_CONNECTION_ERROR_PROPERTY_NOT_FOUND")]
    PropertyNotFound,
    /// an operation which requires a secret
    ///  was attempted on a non-secret property
    #[doc(alias = "NM_CONNECTION_ERROR_PROPERTY_NOT_SECRET")]
    PropertyNotSecret,
    /// the [`Connection`][crate::Connection] object is missing an
    ///  [`Setting`][crate::Setting] which is required for its configuration. The error message will
    ///  always be prefixed with "&lt;setting-name>: ", where "&lt;setting-name>" is the
    ///  name of the setting that is missing.
    #[doc(alias = "NM_CONNECTION_ERROR_MISSING_SETTING")]
    MissingSetting,
    /// the [`Connection`][crate::Connection] object contains an
    ///  invalid or inappropriate [`Setting`][crate::Setting]. The error message will always be
    ///  prefixed with "&lt;setting-name>: ", where "&lt;setting-name>" is the name of the
    ///  setting that is invalid.
    #[doc(alias = "NM_CONNECTION_ERROR_INVALID_SETTING")]
    InvalidSetting,
    /// the [`Connection`][crate::Connection] object is invalid
    ///  because it is missing a required property. The error message will always be
    ///  prefixed with "&lt;setting-name>.&lt;property-name>: ", where "&lt;setting-name>" is
    ///  the name of the setting with the missing property, and "&lt;property-name>" is
    ///  the property that is missing.
    #[doc(alias = "NM_CONNECTION_ERROR_MISSING_PROPERTY")]
    MissingProperty,
    /// the [`Connection`][crate::Connection] object is invalid
    ///  because a property has an invalid value. The error message will always be
    ///  prefixed with "&lt;setting-name>.&lt;property-name>: ", where "&lt;setting-name>" is
    ///  the name of the setting with the invalid property, and "&lt;property-name>" is
    ///  the property that is invalid.
    #[doc(alias = "NM_CONNECTION_ERROR_INVALID_PROPERTY")]
    InvalidProperty,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ConnectionError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ConnectionError::{}",
            match *self {
                Self::Failed => "Failed",
                Self::SettingNotFound => "SettingNotFound",
                Self::PropertyNotFound => "PropertyNotFound",
                Self::PropertyNotSecret => "PropertyNotSecret",
                Self::MissingSetting => "MissingSetting",
                Self::InvalidSetting => "InvalidSetting",
                Self::MissingProperty => "MissingProperty",
                Self::InvalidProperty => "InvalidProperty",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for ConnectionError {
    type GlibType = ffi::NMConnectionError;

    fn into_glib(self) -> ffi::NMConnectionError {
        match self {
            Self::Failed => ffi::NM_CONNECTION_ERROR_FAILED,
            Self::SettingNotFound => ffi::NM_CONNECTION_ERROR_SETTING_NOT_FOUND,
            Self::PropertyNotFound => ffi::NM_CONNECTION_ERROR_PROPERTY_NOT_FOUND,
            Self::PropertyNotSecret => ffi::NM_CONNECTION_ERROR_PROPERTY_NOT_SECRET,
            Self::MissingSetting => ffi::NM_CONNECTION_ERROR_MISSING_SETTING,
            Self::InvalidSetting => ffi::NM_CONNECTION_ERROR_INVALID_SETTING,
            Self::MissingProperty => ffi::NM_CONNECTION_ERROR_MISSING_PROPERTY,
            Self::InvalidProperty => ffi::NM_CONNECTION_ERROR_INVALID_PROPERTY,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMConnectionError> for ConnectionError {
    unsafe fn from_glib(value: ffi::NMConnectionError) -> Self {
        match value {
            ffi::NM_CONNECTION_ERROR_FAILED => Self::Failed,
            ffi::NM_CONNECTION_ERROR_SETTING_NOT_FOUND => Self::SettingNotFound,
            ffi::NM_CONNECTION_ERROR_PROPERTY_NOT_FOUND => Self::PropertyNotFound,
            ffi::NM_CONNECTION_ERROR_PROPERTY_NOT_SECRET => Self::PropertyNotSecret,
            ffi::NM_CONNECTION_ERROR_MISSING_SETTING => Self::MissingSetting,
            ffi::NM_CONNECTION_ERROR_INVALID_SETTING => Self::InvalidSetting,
            ffi::NM_CONNECTION_ERROR_MISSING_PROPERTY => Self::MissingProperty,
            ffi::NM_CONNECTION_ERROR_INVALID_PROPERTY => Self::InvalidProperty,
            value => Self::__Unknown(value),
        }
    }
}

impl ErrorDomain for ConnectionError {
    fn domain() -> Quark {
        unsafe { from_glib(ffi::nm_connection_error_quark()) }
    }

    fn code(self) -> i32 {
        self.into_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            ffi::NM_CONNECTION_ERROR_FAILED => Some(Self::Failed),
            ffi::NM_CONNECTION_ERROR_SETTING_NOT_FOUND => Some(Self::SettingNotFound),
            ffi::NM_CONNECTION_ERROR_PROPERTY_NOT_FOUND => Some(Self::PropertyNotFound),
            ffi::NM_CONNECTION_ERROR_PROPERTY_NOT_SECRET => Some(Self::PropertyNotSecret),
            ffi::NM_CONNECTION_ERROR_MISSING_SETTING => Some(Self::MissingSetting),
            ffi::NM_CONNECTION_ERROR_INVALID_SETTING => Some(Self::InvalidSetting),
            ffi::NM_CONNECTION_ERROR_MISSING_PROPERTY => Some(Self::MissingProperty),
            ffi::NM_CONNECTION_ERROR_INVALID_PROPERTY => Some(Self::InvalidProperty),
            _ => Some(Self::Failed),
        }
    }
}

impl StaticType for ConnectionError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_connection_error_get_type()) }
    }
}

impl glib::value::ValueType for ConnectionError {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ConnectionError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ConnectionError {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMConnectionMultiConnect")]
pub enum ConnectionMultiConnect {
    /// indicates that the per-connection
    ///  setting is unspecified. In this case, it will fallback to the default
    ///  value, which is [`Single`][Self::Single].
    #[doc(alias = "NM_CONNECTION_MULTI_CONNECT_DEFAULT")]
    Default,
    /// the connection profile can only
    ///  be active once at each moment. Activating a profile that is already active,
    ///  will first deactivate it.
    #[doc(alias = "NM_CONNECTION_MULTI_CONNECT_SINGLE")]
    Single,
    /// the profile can
    ///  be manually activated multiple times on different devices. However,
    ///  regarding autoconnect, the profile will autoconnect only if it is
    ///  currently not connected otherwise.
    #[doc(alias = "NM_CONNECTION_MULTI_CONNECT_MANUAL_MULTIPLE")]
    ManualMultiple,
    /// the profile can autoactivate
    ///  and be manually activated multiple times together.
    #[doc(alias = "NM_CONNECTION_MULTI_CONNECT_MULTIPLE")]
    Multiple,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
impl fmt::Display for ConnectionMultiConnect {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ConnectionMultiConnect::{}",
            match *self {
                Self::Default => "Default",
                Self::Single => "Single",
                Self::ManualMultiple => "ManualMultiple",
                Self::Multiple => "Multiple",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
#[doc(hidden)]
impl IntoGlib for ConnectionMultiConnect {
    type GlibType = ffi::NMConnectionMultiConnect;

    fn into_glib(self) -> ffi::NMConnectionMultiConnect {
        match self {
            Self::Default => ffi::NM_CONNECTION_MULTI_CONNECT_DEFAULT,
            Self::Single => ffi::NM_CONNECTION_MULTI_CONNECT_SINGLE,
            Self::ManualMultiple => ffi::NM_CONNECTION_MULTI_CONNECT_MANUAL_MULTIPLE,
            Self::Multiple => ffi::NM_CONNECTION_MULTI_CONNECT_MULTIPLE,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
#[doc(hidden)]
impl FromGlib<ffi::NMConnectionMultiConnect> for ConnectionMultiConnect {
    unsafe fn from_glib(value: ffi::NMConnectionMultiConnect) -> Self {
        match value {
            ffi::NM_CONNECTION_MULTI_CONNECT_DEFAULT => Self::Default,
            ffi::NM_CONNECTION_MULTI_CONNECT_SINGLE => Self::Single,
            ffi::NM_CONNECTION_MULTI_CONNECT_MANUAL_MULTIPLE => Self::ManualMultiple,
            ffi::NM_CONNECTION_MULTI_CONNECT_MULTIPLE => Self::Multiple,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
impl StaticType for ConnectionMultiConnect {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_connection_multi_connect_get_type()) }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
impl glib::value::ValueType for ConnectionMultiConnect {
    type Type = Self;
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
unsafe impl<'a> FromValue<'a> for ConnectionMultiConnect {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
impl ToValue for ConnectionMultiConnect {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMConnectivityState")]
pub enum ConnectivityState {
    /// Network connectivity is unknown. This means the
    ///  connectivity checks are disabled (e.g. on server installations) or has
    ///  not run yet. The graphical shell should assume the Internet connection
    ///  might be available and not present a captive portal window.
    #[doc(alias = "NM_CONNECTIVITY_UNKNOWN")]
    Unknown,
    /// The host is not connected to any network. There's
    ///  no active connection that contains a default route to the internet and
    ///  thus it makes no sense to even attempt a connectivity check. The graphical
    ///  shell should use this state to indicate the network connection is unavailable.
    #[doc(alias = "NM_CONNECTIVITY_NONE")]
    None,
    /// The Internet connection is hijacked by a captive
    ///  portal gateway. The graphical shell may open a sandboxed web browser window
    ///  (because the captive portals typically attempt a man-in-the-middle attacks
    ///  against the https connections) for the purpose of authenticating to a gateway
    ///  and retrigger the connectivity check with CheckConnectivity() when the
    ///  browser window is dismissed.
    #[doc(alias = "NM_CONNECTIVITY_PORTAL")]
    Portal,
    /// The host is connected to a network, does not appear
    ///  to be able to reach the full Internet, but a captive portal has not been
    ///  detected.
    #[doc(alias = "NM_CONNECTIVITY_LIMITED")]
    Limited,
    /// The host is connected to a network, and
    ///  appears to be able to reach the full Internet.
    #[doc(alias = "NM_CONNECTIVITY_FULL")]
    Full,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ConnectivityState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ConnectivityState::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::None => "None",
                Self::Portal => "Portal",
                Self::Limited => "Limited",
                Self::Full => "Full",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for ConnectivityState {
    type GlibType = ffi::NMConnectivityState;

    fn into_glib(self) -> ffi::NMConnectivityState {
        match self {
            Self::Unknown => ffi::NM_CONNECTIVITY_UNKNOWN,
            Self::None => ffi::NM_CONNECTIVITY_NONE,
            Self::Portal => ffi::NM_CONNECTIVITY_PORTAL,
            Self::Limited => ffi::NM_CONNECTIVITY_LIMITED,
            Self::Full => ffi::NM_CONNECTIVITY_FULL,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMConnectivityState> for ConnectivityState {
    unsafe fn from_glib(value: ffi::NMConnectivityState) -> Self {
        match value {
            ffi::NM_CONNECTIVITY_UNKNOWN => Self::Unknown,
            ffi::NM_CONNECTIVITY_NONE => Self::None,
            ffi::NM_CONNECTIVITY_PORTAL => Self::Portal,
            ffi::NM_CONNECTIVITY_LIMITED => Self::Limited,
            ffi::NM_CONNECTIVITY_FULL => Self::Full,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ConnectivityState {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_connectivity_state_get_type()) }
    }
}

impl glib::value::ValueType for ConnectivityState {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ConnectivityState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ConnectivityState {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// Cryptography-related errors that can be returned from some nm-utils methods,
/// and some [`Setting8021x`][crate::Setting8021x] operations.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMCryptoError")]
pub enum CryptoError {
    /// generic failure
    #[doc(alias = "NM_CRYPTO_ERROR_FAILED")]
    Failed,
    /// the certificate or key data provided
    ///  was invalid
    #[doc(alias = "NM_CRYPTO_ERROR_INVALID_DATA")]
    InvalidData,
    /// the password was invalid
    #[doc(alias = "NM_CRYPTO_ERROR_INVALID_PASSWORD")]
    InvalidPassword,
    /// the data uses an unknown cipher
    #[doc(alias = "NM_CRYPTO_ERROR_UNKNOWN_CIPHER")]
    UnknownCipher,
    /// decryption failed
    #[doc(alias = "NM_CRYPTO_ERROR_DECRYPTION_FAILED")]
    DecryptionFailed,
    /// encryption failed
    #[doc(alias = "NM_CRYPTO_ERROR_ENCRYPTION_FAILED")]
    EncryptionFailed,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CryptoError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CryptoError::{}",
            match *self {
                Self::Failed => "Failed",
                Self::InvalidData => "InvalidData",
                Self::InvalidPassword => "InvalidPassword",
                Self::UnknownCipher => "UnknownCipher",
                Self::DecryptionFailed => "DecryptionFailed",
                Self::EncryptionFailed => "EncryptionFailed",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for CryptoError {
    type GlibType = ffi::NMCryptoError;

    fn into_glib(self) -> ffi::NMCryptoError {
        match self {
            Self::Failed => ffi::NM_CRYPTO_ERROR_FAILED,
            Self::InvalidData => ffi::NM_CRYPTO_ERROR_INVALID_DATA,
            Self::InvalidPassword => ffi::NM_CRYPTO_ERROR_INVALID_PASSWORD,
            Self::UnknownCipher => ffi::NM_CRYPTO_ERROR_UNKNOWN_CIPHER,
            Self::DecryptionFailed => ffi::NM_CRYPTO_ERROR_DECRYPTION_FAILED,
            Self::EncryptionFailed => ffi::NM_CRYPTO_ERROR_ENCRYPTION_FAILED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMCryptoError> for CryptoError {
    unsafe fn from_glib(value: ffi::NMCryptoError) -> Self {
        match value {
            ffi::NM_CRYPTO_ERROR_FAILED => Self::Failed,
            ffi::NM_CRYPTO_ERROR_INVALID_DATA => Self::InvalidData,
            ffi::NM_CRYPTO_ERROR_INVALID_PASSWORD => Self::InvalidPassword,
            ffi::NM_CRYPTO_ERROR_UNKNOWN_CIPHER => Self::UnknownCipher,
            ffi::NM_CRYPTO_ERROR_DECRYPTION_FAILED => Self::DecryptionFailed,
            ffi::NM_CRYPTO_ERROR_ENCRYPTION_FAILED => Self::EncryptionFailed,
            value => Self::__Unknown(value),
        }
    }
}

impl ErrorDomain for CryptoError {
    fn domain() -> Quark {
        unsafe { from_glib(ffi::nm_crypto_error_quark()) }
    }

    fn code(self) -> i32 {
        self.into_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            ffi::NM_CRYPTO_ERROR_FAILED => Some(Self::Failed),
            ffi::NM_CRYPTO_ERROR_INVALID_DATA => Some(Self::InvalidData),
            ffi::NM_CRYPTO_ERROR_INVALID_PASSWORD => Some(Self::InvalidPassword),
            ffi::NM_CRYPTO_ERROR_UNKNOWN_CIPHER => Some(Self::UnknownCipher),
            ffi::NM_CRYPTO_ERROR_DECRYPTION_FAILED => Some(Self::DecryptionFailed),
            ffi::NM_CRYPTO_ERROR_ENCRYPTION_FAILED => Some(Self::EncryptionFailed),
            _ => Some(Self::Failed),
        }
    }
}

impl StaticType for CryptoError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_crypto_error_get_type()) }
    }
}

impl glib::value::ValueType for CryptoError {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for CryptoError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CryptoError {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// Device-related errors.
///
/// These errors may be returned directly from [`Device`][crate::Device] methods, or may be
/// returned from D-Bus operations (where they correspond to errors in the
/// "org.freedesktop.NetworkManager.Device" namespace).
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMDeviceError")]
pub enum DeviceError {
    /// unknown or unclassified error
    #[doc(alias = "NM_DEVICE_ERROR_FAILED")]
    Failed,
    /// NetworkManager failed to create the device
    #[doc(alias = "NM_DEVICE_ERROR_CREATION_FAILED")]
    CreationFailed,
    /// the specified connection is not valid
    #[doc(alias = "NM_DEVICE_ERROR_INVALID_CONNECTION")]
    InvalidConnection,
    /// the specified connection is not
    ///  compatible with this device.
    #[doc(alias = "NM_DEVICE_ERROR_INCOMPATIBLE_CONNECTION")]
    IncompatibleConnection,
    /// the device does not have an active connection
    #[doc(alias = "NM_DEVICE_ERROR_NOT_ACTIVE")]
    NotActive,
    /// the requested operation is only valid on
    ///  software devices.
    #[doc(alias = "NM_DEVICE_ERROR_NOT_SOFTWARE")]
    NotSoftware,
    /// the requested operation is not allowed at
    ///  this time.
    #[doc(alias = "NM_DEVICE_ERROR_NOT_ALLOWED")]
    NotAllowed,
    /// the "specific object" in the
    ///  activation request (eg, the [`AccessPoint`][crate::AccessPoint] or [`WimaxNsp`][crate::WimaxNsp]) was not
    ///  found.
    #[doc(alias = "NM_DEVICE_ERROR_SPECIFIC_OBJECT_NOT_FOUND")]
    SpecificObjectNotFound,
    /// the version id did not match.
    #[doc(alias = "NM_DEVICE_ERROR_VERSION_ID_MISMATCH")]
    VersionIdMismatch,
    /// the requested operation could not
    ///  be completed due to missing dependencies.
    #[doc(alias = "NM_DEVICE_ERROR_MISSING_DEPENDENCIES")]
    MissingDependencies,
    /// invalid argument. Since: 1.16.
    #[doc(alias = "NM_DEVICE_ERROR_INVALID_ARGUMENT")]
    InvalidArgument,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DeviceError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DeviceError::{}",
            match *self {
                Self::Failed => "Failed",
                Self::CreationFailed => "CreationFailed",
                Self::InvalidConnection => "InvalidConnection",
                Self::IncompatibleConnection => "IncompatibleConnection",
                Self::NotActive => "NotActive",
                Self::NotSoftware => "NotSoftware",
                Self::NotAllowed => "NotAllowed",
                Self::SpecificObjectNotFound => "SpecificObjectNotFound",
                Self::VersionIdMismatch => "VersionIdMismatch",
                Self::MissingDependencies => "MissingDependencies",
                Self::InvalidArgument => "InvalidArgument",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for DeviceError {
    type GlibType = ffi::NMDeviceError;

    fn into_glib(self) -> ffi::NMDeviceError {
        match self {
            Self::Failed => ffi::NM_DEVICE_ERROR_FAILED,
            Self::CreationFailed => ffi::NM_DEVICE_ERROR_CREATION_FAILED,
            Self::InvalidConnection => ffi::NM_DEVICE_ERROR_INVALID_CONNECTION,
            Self::IncompatibleConnection => ffi::NM_DEVICE_ERROR_INCOMPATIBLE_CONNECTION,
            Self::NotActive => ffi::NM_DEVICE_ERROR_NOT_ACTIVE,
            Self::NotSoftware => ffi::NM_DEVICE_ERROR_NOT_SOFTWARE,
            Self::NotAllowed => ffi::NM_DEVICE_ERROR_NOT_ALLOWED,
            Self::SpecificObjectNotFound => ffi::NM_DEVICE_ERROR_SPECIFIC_OBJECT_NOT_FOUND,
            Self::VersionIdMismatch => ffi::NM_DEVICE_ERROR_VERSION_ID_MISMATCH,
            Self::MissingDependencies => ffi::NM_DEVICE_ERROR_MISSING_DEPENDENCIES,
            Self::InvalidArgument => ffi::NM_DEVICE_ERROR_INVALID_ARGUMENT,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMDeviceError> for DeviceError {
    unsafe fn from_glib(value: ffi::NMDeviceError) -> Self {
        match value {
            ffi::NM_DEVICE_ERROR_FAILED => Self::Failed,
            ffi::NM_DEVICE_ERROR_CREATION_FAILED => Self::CreationFailed,
            ffi::NM_DEVICE_ERROR_INVALID_CONNECTION => Self::InvalidConnection,
            ffi::NM_DEVICE_ERROR_INCOMPATIBLE_CONNECTION => Self::IncompatibleConnection,
            ffi::NM_DEVICE_ERROR_NOT_ACTIVE => Self::NotActive,
            ffi::NM_DEVICE_ERROR_NOT_SOFTWARE => Self::NotSoftware,
            ffi::NM_DEVICE_ERROR_NOT_ALLOWED => Self::NotAllowed,
            ffi::NM_DEVICE_ERROR_SPECIFIC_OBJECT_NOT_FOUND => Self::SpecificObjectNotFound,
            ffi::NM_DEVICE_ERROR_VERSION_ID_MISMATCH => Self::VersionIdMismatch,
            ffi::NM_DEVICE_ERROR_MISSING_DEPENDENCIES => Self::MissingDependencies,
            ffi::NM_DEVICE_ERROR_INVALID_ARGUMENT => Self::InvalidArgument,
            value => Self::__Unknown(value),
        }
    }
}

impl ErrorDomain for DeviceError {
    fn domain() -> Quark {
        unsafe { from_glib(ffi::nm_device_error_quark()) }
    }

    fn code(self) -> i32 {
        self.into_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            ffi::NM_DEVICE_ERROR_FAILED => Some(Self::Failed),
            ffi::NM_DEVICE_ERROR_CREATION_FAILED => Some(Self::CreationFailed),
            ffi::NM_DEVICE_ERROR_INVALID_CONNECTION => Some(Self::InvalidConnection),
            ffi::NM_DEVICE_ERROR_INCOMPATIBLE_CONNECTION => Some(Self::IncompatibleConnection),
            ffi::NM_DEVICE_ERROR_NOT_ACTIVE => Some(Self::NotActive),
            ffi::NM_DEVICE_ERROR_NOT_SOFTWARE => Some(Self::NotSoftware),
            ffi::NM_DEVICE_ERROR_NOT_ALLOWED => Some(Self::NotAllowed),
            ffi::NM_DEVICE_ERROR_SPECIFIC_OBJECT_NOT_FOUND => Some(Self::SpecificObjectNotFound),
            ffi::NM_DEVICE_ERROR_VERSION_ID_MISMATCH => Some(Self::VersionIdMismatch),
            ffi::NM_DEVICE_ERROR_MISSING_DEPENDENCIES => Some(Self::MissingDependencies),
            ffi::NM_DEVICE_ERROR_INVALID_ARGUMENT => Some(Self::InvalidArgument),
            _ => Some(Self::Failed),
        }
    }
}

impl StaticType for DeviceError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_device_error_get_type()) }
    }
}

impl glib::value::ValueType for DeviceError {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for DeviceError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DeviceError {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMDeviceState")]
pub enum DeviceState {
    /// the device's state is unknown
    #[doc(alias = "NM_DEVICE_STATE_UNKNOWN")]
    Unknown,
    /// the device is recognized, but not managed by
    ///  NetworkManager
    #[doc(alias = "NM_DEVICE_STATE_UNMANAGED")]
    Unmanaged,
    /// the device is managed by NetworkManager, but
    ///  is not available for use. Reasons may include the wireless switched off,
    ///  missing firmware, no ethernet carrier, missing supplicant or modem manager,
    ///  etc.
    #[doc(alias = "NM_DEVICE_STATE_UNAVAILABLE")]
    Unavailable,
    /// the device can be activated, but is currently
    ///  idle and not connected to a network.
    #[doc(alias = "NM_DEVICE_STATE_DISCONNECTED")]
    Disconnected,
    /// the device is preparing the connection to the
    ///  network. This may include operations like changing the MAC address,
    ///  setting physical link properties, and anything else required to connect
    ///  to the requested network.
    #[doc(alias = "NM_DEVICE_STATE_PREPARE")]
    Prepare,
    /// the device is connecting to the requested network.
    ///  This may include operations like associating with the Wi-Fi AP, dialing
    ///  the modem, connecting to the remote Bluetooth device, etc.
    #[doc(alias = "NM_DEVICE_STATE_CONFIG")]
    Config,
    /// the device requires more information to continue
    ///  connecting to the requested network. This includes secrets like WiFi
    ///  passphrases, login passwords, PIN codes, etc.
    #[doc(alias = "NM_DEVICE_STATE_NEED_AUTH")]
    NeedAuth,
    /// the device is requesting IPv4 and/or IPv6
    ///  addresses and routing information from the network.
    #[doc(alias = "NM_DEVICE_STATE_IP_CONFIG")]
    IpConfig,
    /// the device is checking whether further action is
    ///  required for the requested network connection. This may include checking
    ///  whether only local network access is available, whether a captive portal
    ///  is blocking access to the Internet, etc.
    #[doc(alias = "NM_DEVICE_STATE_IP_CHECK")]
    IpCheck,
    /// the device is waiting for a secondary
    ///  connection (like a VPN) which must activated before the device can be
    ///  activated
    #[doc(alias = "NM_DEVICE_STATE_SECONDARIES")]
    Secondaries,
    /// the device has a network connection, either local
    ///  or global.
    #[doc(alias = "NM_DEVICE_STATE_ACTIVATED")]
    Activated,
    /// a disconnection from the current network
    ///  connection was requested, and the device is cleaning up resources used for
    ///  that connection. The network connection may still be valid.
    #[doc(alias = "NM_DEVICE_STATE_DEACTIVATING")]
    Deactivating,
    /// the device failed to connect to the requested
    ///  network and is cleaning up the connection request
    #[doc(alias = "NM_DEVICE_STATE_FAILED")]
    Failed,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DeviceState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DeviceState::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::Unmanaged => "Unmanaged",
                Self::Unavailable => "Unavailable",
                Self::Disconnected => "Disconnected",
                Self::Prepare => "Prepare",
                Self::Config => "Config",
                Self::NeedAuth => "NeedAuth",
                Self::IpConfig => "IpConfig",
                Self::IpCheck => "IpCheck",
                Self::Secondaries => "Secondaries",
                Self::Activated => "Activated",
                Self::Deactivating => "Deactivating",
                Self::Failed => "Failed",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for DeviceState {
    type GlibType = ffi::NMDeviceState;

    fn into_glib(self) -> ffi::NMDeviceState {
        match self {
            Self::Unknown => ffi::NM_DEVICE_STATE_UNKNOWN,
            Self::Unmanaged => ffi::NM_DEVICE_STATE_UNMANAGED,
            Self::Unavailable => ffi::NM_DEVICE_STATE_UNAVAILABLE,
            Self::Disconnected => ffi::NM_DEVICE_STATE_DISCONNECTED,
            Self::Prepare => ffi::NM_DEVICE_STATE_PREPARE,
            Self::Config => ffi::NM_DEVICE_STATE_CONFIG,
            Self::NeedAuth => ffi::NM_DEVICE_STATE_NEED_AUTH,
            Self::IpConfig => ffi::NM_DEVICE_STATE_IP_CONFIG,
            Self::IpCheck => ffi::NM_DEVICE_STATE_IP_CHECK,
            Self::Secondaries => ffi::NM_DEVICE_STATE_SECONDARIES,
            Self::Activated => ffi::NM_DEVICE_STATE_ACTIVATED,
            Self::Deactivating => ffi::NM_DEVICE_STATE_DEACTIVATING,
            Self::Failed => ffi::NM_DEVICE_STATE_FAILED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMDeviceState> for DeviceState {
    unsafe fn from_glib(value: ffi::NMDeviceState) -> Self {
        match value {
            ffi::NM_DEVICE_STATE_UNKNOWN => Self::Unknown,
            ffi::NM_DEVICE_STATE_UNMANAGED => Self::Unmanaged,
            ffi::NM_DEVICE_STATE_UNAVAILABLE => Self::Unavailable,
            ffi::NM_DEVICE_STATE_DISCONNECTED => Self::Disconnected,
            ffi::NM_DEVICE_STATE_PREPARE => Self::Prepare,
            ffi::NM_DEVICE_STATE_CONFIG => Self::Config,
            ffi::NM_DEVICE_STATE_NEED_AUTH => Self::NeedAuth,
            ffi::NM_DEVICE_STATE_IP_CONFIG => Self::IpConfig,
            ffi::NM_DEVICE_STATE_IP_CHECK => Self::IpCheck,
            ffi::NM_DEVICE_STATE_SECONDARIES => Self::Secondaries,
            ffi::NM_DEVICE_STATE_ACTIVATED => Self::Activated,
            ffi::NM_DEVICE_STATE_DEACTIVATING => Self::Deactivating,
            ffi::NM_DEVICE_STATE_FAILED => Self::Failed,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for DeviceState {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_device_state_get_type()) }
    }
}

impl glib::value::ValueType for DeviceState {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for DeviceState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DeviceState {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// Device state change reason codes
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMDeviceStateReason")]
pub enum DeviceStateReason {
    /// No reason given
    #[doc(alias = "NM_DEVICE_STATE_REASON_NONE")]
    None,
    /// Unknown error
    #[doc(alias = "NM_DEVICE_STATE_REASON_UNKNOWN")]
    Unknown,
    /// Device is now managed
    #[doc(alias = "NM_DEVICE_STATE_REASON_NOW_MANAGED")]
    NowManaged,
    /// Device is now unmanaged
    #[doc(alias = "NM_DEVICE_STATE_REASON_NOW_UNMANAGED")]
    NowUnmanaged,
    /// The device could not be readied for configuration
    #[doc(alias = "NM_DEVICE_STATE_REASON_CONFIG_FAILED")]
    ConfigFailed,
    /// IP configuration could not be reserved (no available address, timeout, etc)
    #[doc(alias = "NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE")]
    IpConfigUnavailable,
    /// The IP config is no longer valid
    #[doc(alias = "NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED")]
    IpConfigExpired,
    /// Secrets were required, but not provided
    #[doc(alias = "NM_DEVICE_STATE_REASON_NO_SECRETS")]
    NoSecrets,
    /// 802.1x supplicant disconnected
    #[doc(alias = "NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT")]
    SupplicantDisconnect,
    /// 802.1x supplicant configuration failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED")]
    SupplicantConfigFailed,
    /// 802.1x supplicant failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_SUPPLICANT_FAILED")]
    SupplicantFailed,
    /// 802.1x supplicant took too long to authenticate
    #[doc(alias = "NM_DEVICE_STATE_REASON_SUPPLICANT_TIMEOUT")]
    SupplicantTimeout,
    /// PPP service failed to start
    #[doc(alias = "NM_DEVICE_STATE_REASON_PPP_START_FAILED")]
    PppStartFailed,
    /// PPP service disconnected
    #[doc(alias = "NM_DEVICE_STATE_REASON_PPP_DISCONNECT")]
    PppDisconnect,
    /// PPP failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_PPP_FAILED")]
    PppFailed,
    /// DHCP client failed to start
    #[doc(alias = "NM_DEVICE_STATE_REASON_DHCP_START_FAILED")]
    DhcpStartFailed,
    /// DHCP client error
    #[doc(alias = "NM_DEVICE_STATE_REASON_DHCP_ERROR")]
    DhcpError,
    /// DHCP client failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_DHCP_FAILED")]
    DhcpFailed,
    /// Shared connection service failed to start
    #[doc(alias = "NM_DEVICE_STATE_REASON_SHARED_START_FAILED")]
    SharedStartFailed,
    /// Shared connection service failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_SHARED_FAILED")]
    SharedFailed,
    /// AutoIP service failed to start
    #[doc(alias = "NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED")]
    AutoipStartFailed,
    /// AutoIP service error
    #[doc(alias = "NM_DEVICE_STATE_REASON_AUTOIP_ERROR")]
    AutoipError,
    /// AutoIP service failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_AUTOIP_FAILED")]
    AutoipFailed,
    /// The line is busy
    #[doc(alias = "NM_DEVICE_STATE_REASON_MODEM_BUSY")]
    ModemBusy,
    /// No dial tone
    #[doc(alias = "NM_DEVICE_STATE_REASON_MODEM_NO_DIAL_TONE")]
    ModemNoDialTone,
    /// No carrier could be established
    #[doc(alias = "NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER")]
    ModemNoCarrier,
    /// The dialing request timed out
    #[doc(alias = "NM_DEVICE_STATE_REASON_MODEM_DIAL_TIMEOUT")]
    ModemDialTimeout,
    /// The dialing attempt failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_MODEM_DIAL_FAILED")]
    ModemDialFailed,
    /// Modem initialization failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED")]
    ModemInitFailed,
    /// Failed to select the specified APN
    #[doc(alias = "NM_DEVICE_STATE_REASON_GSM_APN_FAILED")]
    GsmApnFailed,
    /// Not searching for networks
    #[doc(alias = "NM_DEVICE_STATE_REASON_GSM_REGISTRATION_NOT_SEARCHING")]
    GsmRegistrationNotSearching,
    /// Network registration denied
    #[doc(alias = "NM_DEVICE_STATE_REASON_GSM_REGISTRATION_DENIED")]
    GsmRegistrationDenied,
    /// Network registration timed out
    #[doc(alias = "NM_DEVICE_STATE_REASON_GSM_REGISTRATION_TIMEOUT")]
    GsmRegistrationTimeout,
    /// Failed to register with the requested network
    #[doc(alias = "NM_DEVICE_STATE_REASON_GSM_REGISTRATION_FAILED")]
    GsmRegistrationFailed,
    /// PIN check failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_GSM_PIN_CHECK_FAILED")]
    GsmPinCheckFailed,
    /// Necessary firmware for the device may be missing
    #[doc(alias = "NM_DEVICE_STATE_REASON_FIRMWARE_MISSING")]
    FirmwareMissing,
    /// The device was removed
    #[doc(alias = "NM_DEVICE_STATE_REASON_REMOVED")]
    Removed,
    /// NetworkManager went to sleep
    #[doc(alias = "NM_DEVICE_STATE_REASON_SLEEPING")]
    Sleeping,
    /// The device's active connection disappeared
    #[doc(alias = "NM_DEVICE_STATE_REASON_CONNECTION_REMOVED")]
    ConnectionRemoved,
    /// Device disconnected by user or client
    #[doc(alias = "NM_DEVICE_STATE_REASON_USER_REQUESTED")]
    UserRequested,
    /// Carrier/link changed
    #[doc(alias = "NM_DEVICE_STATE_REASON_CARRIER")]
    Carrier,
    /// The device's existing connection was assumed
    #[doc(alias = "NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED")]
    ConnectionAssumed,
    /// The supplicant is now available
    #[doc(alias = "NM_DEVICE_STATE_REASON_SUPPLICANT_AVAILABLE")]
    SupplicantAvailable,
    /// The modem could not be found
    #[doc(alias = "NM_DEVICE_STATE_REASON_MODEM_NOT_FOUND")]
    ModemNotFound,
    /// The Bluetooth connection failed or timed out
    #[doc(alias = "NM_DEVICE_STATE_REASON_BT_FAILED")]
    BtFailed,
    /// GSM Modem's SIM Card not inserted
    #[doc(alias = "NM_DEVICE_STATE_REASON_GSM_SIM_NOT_INSERTED")]
    GsmSimNotInserted,
    /// GSM Modem's SIM Pin required
    #[doc(alias = "NM_DEVICE_STATE_REASON_GSM_SIM_PIN_REQUIRED")]
    GsmSimPinRequired,
    /// GSM Modem's SIM Puk required
    #[doc(alias = "NM_DEVICE_STATE_REASON_GSM_SIM_PUK_REQUIRED")]
    GsmSimPukRequired,
    /// GSM Modem's SIM wrong
    #[doc(alias = "NM_DEVICE_STATE_REASON_GSM_SIM_WRONG")]
    GsmSimWrong,
    /// InfiniBand device does not support connected mode
    #[doc(alias = "NM_DEVICE_STATE_REASON_INFINIBAND_MODE")]
    InfinibandMode,
    /// A dependency of the connection failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED")]
    DependencyFailed,
    /// Problem with the RFC 2684 Ethernet over ADSL bridge
    #[doc(alias = "NM_DEVICE_STATE_REASON_BR2684_FAILED")]
    Br2684Failed,
    /// ModemManager not running
    #[doc(alias = "NM_DEVICE_STATE_REASON_MODEM_MANAGER_UNAVAILABLE")]
    ModemManagerUnavailable,
    /// The Wi-Fi network could not be found
    #[doc(alias = "NM_DEVICE_STATE_REASON_SSID_NOT_FOUND")]
    SsidNotFound,
    /// A secondary connection of the base connection failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_SECONDARY_CONNECTION_FAILED")]
    SecondaryConnectionFailed,
    /// DCB or FCoE setup failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_DCB_FCOE_FAILED")]
    DcbFcoeFailed,
    /// teamd control failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_TEAMD_CONTROL_FAILED")]
    TeamdControlFailed,
    /// Modem failed or no longer available
    #[doc(alias = "NM_DEVICE_STATE_REASON_MODEM_FAILED")]
    ModemFailed,
    /// Modem now ready and available
    #[doc(alias = "NM_DEVICE_STATE_REASON_MODEM_AVAILABLE")]
    ModemAvailable,
    /// SIM PIN was incorrect
    #[doc(alias = "NM_DEVICE_STATE_REASON_SIM_PIN_INCORRECT")]
    SimPinIncorrect,
    /// New connection activation was enqueued
    #[doc(alias = "NM_DEVICE_STATE_REASON_NEW_ACTIVATION")]
    NewActivation,
    /// the device's parent changed
    #[doc(alias = "NM_DEVICE_STATE_REASON_PARENT_CHANGED")]
    ParentChanged,
    /// the device parent's management changed
    #[doc(alias = "NM_DEVICE_STATE_REASON_PARENT_MANAGED_CHANGED")]
    ParentManagedChanged,
    /// problem communicating with Open vSwitch database
    #[doc(alias = "NM_DEVICE_STATE_REASON_OVSDB_FAILED")]
    OvsdbFailed,
    /// a duplicate IP address was detected
    #[doc(alias = "NM_DEVICE_STATE_REASON_IP_ADDRESS_DUPLICATE")]
    IpAddressDuplicate,
    /// The selected IP method is not supported
    #[doc(alias = "NM_DEVICE_STATE_REASON_IP_METHOD_UNSUPPORTED")]
    IpMethodUnsupported,
    /// configuration of SR-IOV parameters failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_SRIOV_CONFIGURATION_FAILED")]
    SriovConfigurationFailed,
    /// The Wi-Fi P2P peer could not be found
    #[doc(alias = "NM_DEVICE_STATE_REASON_PEER_NOT_FOUND")]
    PeerNotFound,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DeviceStateReason {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DeviceStateReason::{}",
            match *self {
                Self::None => "None",
                Self::Unknown => "Unknown",
                Self::NowManaged => "NowManaged",
                Self::NowUnmanaged => "NowUnmanaged",
                Self::ConfigFailed => "ConfigFailed",
                Self::IpConfigUnavailable => "IpConfigUnavailable",
                Self::IpConfigExpired => "IpConfigExpired",
                Self::NoSecrets => "NoSecrets",
                Self::SupplicantDisconnect => "SupplicantDisconnect",
                Self::SupplicantConfigFailed => "SupplicantConfigFailed",
                Self::SupplicantFailed => "SupplicantFailed",
                Self::SupplicantTimeout => "SupplicantTimeout",
                Self::PppStartFailed => "PppStartFailed",
                Self::PppDisconnect => "PppDisconnect",
                Self::PppFailed => "PppFailed",
                Self::DhcpStartFailed => "DhcpStartFailed",
                Self::DhcpError => "DhcpError",
                Self::DhcpFailed => "DhcpFailed",
                Self::SharedStartFailed => "SharedStartFailed",
                Self::SharedFailed => "SharedFailed",
                Self::AutoipStartFailed => "AutoipStartFailed",
                Self::AutoipError => "AutoipError",
                Self::AutoipFailed => "AutoipFailed",
                Self::ModemBusy => "ModemBusy",
                Self::ModemNoDialTone => "ModemNoDialTone",
                Self::ModemNoCarrier => "ModemNoCarrier",
                Self::ModemDialTimeout => "ModemDialTimeout",
                Self::ModemDialFailed => "ModemDialFailed",
                Self::ModemInitFailed => "ModemInitFailed",
                Self::GsmApnFailed => "GsmApnFailed",
                Self::GsmRegistrationNotSearching => "GsmRegistrationNotSearching",
                Self::GsmRegistrationDenied => "GsmRegistrationDenied",
                Self::GsmRegistrationTimeout => "GsmRegistrationTimeout",
                Self::GsmRegistrationFailed => "GsmRegistrationFailed",
                Self::GsmPinCheckFailed => "GsmPinCheckFailed",
                Self::FirmwareMissing => "FirmwareMissing",
                Self::Removed => "Removed",
                Self::Sleeping => "Sleeping",
                Self::ConnectionRemoved => "ConnectionRemoved",
                Self::UserRequested => "UserRequested",
                Self::Carrier => "Carrier",
                Self::ConnectionAssumed => "ConnectionAssumed",
                Self::SupplicantAvailable => "SupplicantAvailable",
                Self::ModemNotFound => "ModemNotFound",
                Self::BtFailed => "BtFailed",
                Self::GsmSimNotInserted => "GsmSimNotInserted",
                Self::GsmSimPinRequired => "GsmSimPinRequired",
                Self::GsmSimPukRequired => "GsmSimPukRequired",
                Self::GsmSimWrong => "GsmSimWrong",
                Self::InfinibandMode => "InfinibandMode",
                Self::DependencyFailed => "DependencyFailed",
                Self::Br2684Failed => "Br2684Failed",
                Self::ModemManagerUnavailable => "ModemManagerUnavailable",
                Self::SsidNotFound => "SsidNotFound",
                Self::SecondaryConnectionFailed => "SecondaryConnectionFailed",
                Self::DcbFcoeFailed => "DcbFcoeFailed",
                Self::TeamdControlFailed => "TeamdControlFailed",
                Self::ModemFailed => "ModemFailed",
                Self::ModemAvailable => "ModemAvailable",
                Self::SimPinIncorrect => "SimPinIncorrect",
                Self::NewActivation => "NewActivation",
                Self::ParentChanged => "ParentChanged",
                Self::ParentManagedChanged => "ParentManagedChanged",
                Self::OvsdbFailed => "OvsdbFailed",
                Self::IpAddressDuplicate => "IpAddressDuplicate",
                Self::IpMethodUnsupported => "IpMethodUnsupported",
                Self::SriovConfigurationFailed => "SriovConfigurationFailed",
                Self::PeerNotFound => "PeerNotFound",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for DeviceStateReason {
    type GlibType = ffi::NMDeviceStateReason;

    fn into_glib(self) -> ffi::NMDeviceStateReason {
        match self {
            Self::None => ffi::NM_DEVICE_STATE_REASON_NONE,
            Self::Unknown => ffi::NM_DEVICE_STATE_REASON_UNKNOWN,
            Self::NowManaged => ffi::NM_DEVICE_STATE_REASON_NOW_MANAGED,
            Self::NowUnmanaged => ffi::NM_DEVICE_STATE_REASON_NOW_UNMANAGED,
            Self::ConfigFailed => ffi::NM_DEVICE_STATE_REASON_CONFIG_FAILED,
            Self::IpConfigUnavailable => ffi::NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE,
            Self::IpConfigExpired => ffi::NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED,
            Self::NoSecrets => ffi::NM_DEVICE_STATE_REASON_NO_SECRETS,
            Self::SupplicantDisconnect => ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT,
            Self::SupplicantConfigFailed => ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED,
            Self::SupplicantFailed => ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_FAILED,
            Self::SupplicantTimeout => ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_TIMEOUT,
            Self::PppStartFailed => ffi::NM_DEVICE_STATE_REASON_PPP_START_FAILED,
            Self::PppDisconnect => ffi::NM_DEVICE_STATE_REASON_PPP_DISCONNECT,
            Self::PppFailed => ffi::NM_DEVICE_STATE_REASON_PPP_FAILED,
            Self::DhcpStartFailed => ffi::NM_DEVICE_STATE_REASON_DHCP_START_FAILED,
            Self::DhcpError => ffi::NM_DEVICE_STATE_REASON_DHCP_ERROR,
            Self::DhcpFailed => ffi::NM_DEVICE_STATE_REASON_DHCP_FAILED,
            Self::SharedStartFailed => ffi::NM_DEVICE_STATE_REASON_SHARED_START_FAILED,
            Self::SharedFailed => ffi::NM_DEVICE_STATE_REASON_SHARED_FAILED,
            Self::AutoipStartFailed => ffi::NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED,
            Self::AutoipError => ffi::NM_DEVICE_STATE_REASON_AUTOIP_ERROR,
            Self::AutoipFailed => ffi::NM_DEVICE_STATE_REASON_AUTOIP_FAILED,
            Self::ModemBusy => ffi::NM_DEVICE_STATE_REASON_MODEM_BUSY,
            Self::ModemNoDialTone => ffi::NM_DEVICE_STATE_REASON_MODEM_NO_DIAL_TONE,
            Self::ModemNoCarrier => ffi::NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER,
            Self::ModemDialTimeout => ffi::NM_DEVICE_STATE_REASON_MODEM_DIAL_TIMEOUT,
            Self::ModemDialFailed => ffi::NM_DEVICE_STATE_REASON_MODEM_DIAL_FAILED,
            Self::ModemInitFailed => ffi::NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED,
            Self::GsmApnFailed => ffi::NM_DEVICE_STATE_REASON_GSM_APN_FAILED,
            Self::GsmRegistrationNotSearching => {
                ffi::NM_DEVICE_STATE_REASON_GSM_REGISTRATION_NOT_SEARCHING
            }
            Self::GsmRegistrationDenied => ffi::NM_DEVICE_STATE_REASON_GSM_REGISTRATION_DENIED,
            Self::GsmRegistrationTimeout => ffi::NM_DEVICE_STATE_REASON_GSM_REGISTRATION_TIMEOUT,
            Self::GsmRegistrationFailed => ffi::NM_DEVICE_STATE_REASON_GSM_REGISTRATION_FAILED,
            Self::GsmPinCheckFailed => ffi::NM_DEVICE_STATE_REASON_GSM_PIN_CHECK_FAILED,
            Self::FirmwareMissing => ffi::NM_DEVICE_STATE_REASON_FIRMWARE_MISSING,
            Self::Removed => ffi::NM_DEVICE_STATE_REASON_REMOVED,
            Self::Sleeping => ffi::NM_DEVICE_STATE_REASON_SLEEPING,
            Self::ConnectionRemoved => ffi::NM_DEVICE_STATE_REASON_CONNECTION_REMOVED,
            Self::UserRequested => ffi::NM_DEVICE_STATE_REASON_USER_REQUESTED,
            Self::Carrier => ffi::NM_DEVICE_STATE_REASON_CARRIER,
            Self::ConnectionAssumed => ffi::NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED,
            Self::SupplicantAvailable => ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_AVAILABLE,
            Self::ModemNotFound => ffi::NM_DEVICE_STATE_REASON_MODEM_NOT_FOUND,
            Self::BtFailed => ffi::NM_DEVICE_STATE_REASON_BT_FAILED,
            Self::GsmSimNotInserted => ffi::NM_DEVICE_STATE_REASON_GSM_SIM_NOT_INSERTED,
            Self::GsmSimPinRequired => ffi::NM_DEVICE_STATE_REASON_GSM_SIM_PIN_REQUIRED,
            Self::GsmSimPukRequired => ffi::NM_DEVICE_STATE_REASON_GSM_SIM_PUK_REQUIRED,
            Self::GsmSimWrong => ffi::NM_DEVICE_STATE_REASON_GSM_SIM_WRONG,
            Self::InfinibandMode => ffi::NM_DEVICE_STATE_REASON_INFINIBAND_MODE,
            Self::DependencyFailed => ffi::NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED,
            Self::Br2684Failed => ffi::NM_DEVICE_STATE_REASON_BR2684_FAILED,
            Self::ModemManagerUnavailable => ffi::NM_DEVICE_STATE_REASON_MODEM_MANAGER_UNAVAILABLE,
            Self::SsidNotFound => ffi::NM_DEVICE_STATE_REASON_SSID_NOT_FOUND,
            Self::SecondaryConnectionFailed => {
                ffi::NM_DEVICE_STATE_REASON_SECONDARY_CONNECTION_FAILED
            }
            Self::DcbFcoeFailed => ffi::NM_DEVICE_STATE_REASON_DCB_FCOE_FAILED,
            Self::TeamdControlFailed => ffi::NM_DEVICE_STATE_REASON_TEAMD_CONTROL_FAILED,
            Self::ModemFailed => ffi::NM_DEVICE_STATE_REASON_MODEM_FAILED,
            Self::ModemAvailable => ffi::NM_DEVICE_STATE_REASON_MODEM_AVAILABLE,
            Self::SimPinIncorrect => ffi::NM_DEVICE_STATE_REASON_SIM_PIN_INCORRECT,
            Self::NewActivation => ffi::NM_DEVICE_STATE_REASON_NEW_ACTIVATION,
            Self::ParentChanged => ffi::NM_DEVICE_STATE_REASON_PARENT_CHANGED,
            Self::ParentManagedChanged => ffi::NM_DEVICE_STATE_REASON_PARENT_MANAGED_CHANGED,
            Self::OvsdbFailed => ffi::NM_DEVICE_STATE_REASON_OVSDB_FAILED,
            Self::IpAddressDuplicate => ffi::NM_DEVICE_STATE_REASON_IP_ADDRESS_DUPLICATE,
            Self::IpMethodUnsupported => ffi::NM_DEVICE_STATE_REASON_IP_METHOD_UNSUPPORTED,
            Self::SriovConfigurationFailed => {
                ffi::NM_DEVICE_STATE_REASON_SRIOV_CONFIGURATION_FAILED
            }
            Self::PeerNotFound => ffi::NM_DEVICE_STATE_REASON_PEER_NOT_FOUND,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMDeviceStateReason> for DeviceStateReason {
    unsafe fn from_glib(value: ffi::NMDeviceStateReason) -> Self {
        match value {
            ffi::NM_DEVICE_STATE_REASON_NONE => Self::None,
            ffi::NM_DEVICE_STATE_REASON_UNKNOWN => Self::Unknown,
            ffi::NM_DEVICE_STATE_REASON_NOW_MANAGED => Self::NowManaged,
            ffi::NM_DEVICE_STATE_REASON_NOW_UNMANAGED => Self::NowUnmanaged,
            ffi::NM_DEVICE_STATE_REASON_CONFIG_FAILED => Self::ConfigFailed,
            ffi::NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE => Self::IpConfigUnavailable,
            ffi::NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED => Self::IpConfigExpired,
            ffi::NM_DEVICE_STATE_REASON_NO_SECRETS => Self::NoSecrets,
            ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT => Self::SupplicantDisconnect,
            ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED => Self::SupplicantConfigFailed,
            ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_FAILED => Self::SupplicantFailed,
            ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_TIMEOUT => Self::SupplicantTimeout,
            ffi::NM_DEVICE_STATE_REASON_PPP_START_FAILED => Self::PppStartFailed,
            ffi::NM_DEVICE_STATE_REASON_PPP_DISCONNECT => Self::PppDisconnect,
            ffi::NM_DEVICE_STATE_REASON_PPP_FAILED => Self::PppFailed,
            ffi::NM_DEVICE_STATE_REASON_DHCP_START_FAILED => Self::DhcpStartFailed,
            ffi::NM_DEVICE_STATE_REASON_DHCP_ERROR => Self::DhcpError,
            ffi::NM_DEVICE_STATE_REASON_DHCP_FAILED => Self::DhcpFailed,
            ffi::NM_DEVICE_STATE_REASON_SHARED_START_FAILED => Self::SharedStartFailed,
            ffi::NM_DEVICE_STATE_REASON_SHARED_FAILED => Self::SharedFailed,
            ffi::NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED => Self::AutoipStartFailed,
            ffi::NM_DEVICE_STATE_REASON_AUTOIP_ERROR => Self::AutoipError,
            ffi::NM_DEVICE_STATE_REASON_AUTOIP_FAILED => Self::AutoipFailed,
            ffi::NM_DEVICE_STATE_REASON_MODEM_BUSY => Self::ModemBusy,
            ffi::NM_DEVICE_STATE_REASON_MODEM_NO_DIAL_TONE => Self::ModemNoDialTone,
            ffi::NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER => Self::ModemNoCarrier,
            ffi::NM_DEVICE_STATE_REASON_MODEM_DIAL_TIMEOUT => Self::ModemDialTimeout,
            ffi::NM_DEVICE_STATE_REASON_MODEM_DIAL_FAILED => Self::ModemDialFailed,
            ffi::NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED => Self::ModemInitFailed,
            ffi::NM_DEVICE_STATE_REASON_GSM_APN_FAILED => Self::GsmApnFailed,
            ffi::NM_DEVICE_STATE_REASON_GSM_REGISTRATION_NOT_SEARCHING => {
                Self::GsmRegistrationNotSearching
            }
            ffi::NM_DEVICE_STATE_REASON_GSM_REGISTRATION_DENIED => Self::GsmRegistrationDenied,
            ffi::NM_DEVICE_STATE_REASON_GSM_REGISTRATION_TIMEOUT => Self::GsmRegistrationTimeout,
            ffi::NM_DEVICE_STATE_REASON_GSM_REGISTRATION_FAILED => Self::GsmRegistrationFailed,
            ffi::NM_DEVICE_STATE_REASON_GSM_PIN_CHECK_FAILED => Self::GsmPinCheckFailed,
            ffi::NM_DEVICE_STATE_REASON_FIRMWARE_MISSING => Self::FirmwareMissing,
            ffi::NM_DEVICE_STATE_REASON_REMOVED => Self::Removed,
            ffi::NM_DEVICE_STATE_REASON_SLEEPING => Self::Sleeping,
            ffi::NM_DEVICE_STATE_REASON_CONNECTION_REMOVED => Self::ConnectionRemoved,
            ffi::NM_DEVICE_STATE_REASON_USER_REQUESTED => Self::UserRequested,
            ffi::NM_DEVICE_STATE_REASON_CARRIER => Self::Carrier,
            ffi::NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED => Self::ConnectionAssumed,
            ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_AVAILABLE => Self::SupplicantAvailable,
            ffi::NM_DEVICE_STATE_REASON_MODEM_NOT_FOUND => Self::ModemNotFound,
            ffi::NM_DEVICE_STATE_REASON_BT_FAILED => Self::BtFailed,
            ffi::NM_DEVICE_STATE_REASON_GSM_SIM_NOT_INSERTED => Self::GsmSimNotInserted,
            ffi::NM_DEVICE_STATE_REASON_GSM_SIM_PIN_REQUIRED => Self::GsmSimPinRequired,
            ffi::NM_DEVICE_STATE_REASON_GSM_SIM_PUK_REQUIRED => Self::GsmSimPukRequired,
            ffi::NM_DEVICE_STATE_REASON_GSM_SIM_WRONG => Self::GsmSimWrong,
            ffi::NM_DEVICE_STATE_REASON_INFINIBAND_MODE => Self::InfinibandMode,
            ffi::NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED => Self::DependencyFailed,
            ffi::NM_DEVICE_STATE_REASON_BR2684_FAILED => Self::Br2684Failed,
            ffi::NM_DEVICE_STATE_REASON_MODEM_MANAGER_UNAVAILABLE => Self::ModemManagerUnavailable,
            ffi::NM_DEVICE_STATE_REASON_SSID_NOT_FOUND => Self::SsidNotFound,
            ffi::NM_DEVICE_STATE_REASON_SECONDARY_CONNECTION_FAILED => {
                Self::SecondaryConnectionFailed
            }
            ffi::NM_DEVICE_STATE_REASON_DCB_FCOE_FAILED => Self::DcbFcoeFailed,
            ffi::NM_DEVICE_STATE_REASON_TEAMD_CONTROL_FAILED => Self::TeamdControlFailed,
            ffi::NM_DEVICE_STATE_REASON_MODEM_FAILED => Self::ModemFailed,
            ffi::NM_DEVICE_STATE_REASON_MODEM_AVAILABLE => Self::ModemAvailable,
            ffi::NM_DEVICE_STATE_REASON_SIM_PIN_INCORRECT => Self::SimPinIncorrect,
            ffi::NM_DEVICE_STATE_REASON_NEW_ACTIVATION => Self::NewActivation,
            ffi::NM_DEVICE_STATE_REASON_PARENT_CHANGED => Self::ParentChanged,
            ffi::NM_DEVICE_STATE_REASON_PARENT_MANAGED_CHANGED => Self::ParentManagedChanged,
            ffi::NM_DEVICE_STATE_REASON_OVSDB_FAILED => Self::OvsdbFailed,
            ffi::NM_DEVICE_STATE_REASON_IP_ADDRESS_DUPLICATE => Self::IpAddressDuplicate,
            ffi::NM_DEVICE_STATE_REASON_IP_METHOD_UNSUPPORTED => Self::IpMethodUnsupported,
            ffi::NM_DEVICE_STATE_REASON_SRIOV_CONFIGURATION_FAILED => {
                Self::SriovConfigurationFailed
            }
            ffi::NM_DEVICE_STATE_REASON_PEER_NOT_FOUND => Self::PeerNotFound,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for DeviceStateReason {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_device_state_reason_get_type()) }
    }
}

impl glib::value::ValueType for DeviceStateReason {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for DeviceStateReason {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DeviceStateReason {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// [`DeviceType`][crate::DeviceType] values indicate the type of hardware represented by a
/// device object.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMDeviceType")]
pub enum DeviceType {
    /// unknown device
    #[doc(alias = "NM_DEVICE_TYPE_UNKNOWN")]
    Unknown,
    /// a wired ethernet device
    #[doc(alias = "NM_DEVICE_TYPE_ETHERNET")]
    Ethernet,
    /// an 802.11 Wi-Fi device
    #[doc(alias = "NM_DEVICE_TYPE_WIFI")]
    Wifi,
    /// not used
    #[doc(alias = "NM_DEVICE_TYPE_UNUSED1")]
    Unused1,
    /// not used
    #[doc(alias = "NM_DEVICE_TYPE_UNUSED2")]
    Unused2,
    /// a Bluetooth device supporting PAN or DUN access protocols
    #[doc(alias = "NM_DEVICE_TYPE_BT")]
    Bt,
    /// an OLPC XO mesh networking device
    #[doc(alias = "NM_DEVICE_TYPE_OLPC_MESH")]
    OlpcMesh,
    /// an 802.16e Mobile WiMAX broadband device
    #[doc(alias = "NM_DEVICE_TYPE_WIMAX")]
    Wimax,
    /// a modem supporting analog telephone, CDMA/EVDO,
    /// GSM/UMTS, or LTE network access protocols
    #[doc(alias = "NM_DEVICE_TYPE_MODEM")]
    Modem,
    /// an IP-over-InfiniBand device
    #[doc(alias = "NM_DEVICE_TYPE_INFINIBAND")]
    Infiniband,
    /// a bond master interface
    #[doc(alias = "NM_DEVICE_TYPE_BOND")]
    Bond,
    /// an 802.1Q VLAN interface
    #[doc(alias = "NM_DEVICE_TYPE_VLAN")]
    Vlan,
    /// ADSL modem
    #[doc(alias = "NM_DEVICE_TYPE_ADSL")]
    Adsl,
    /// a bridge master interface
    #[doc(alias = "NM_DEVICE_TYPE_BRIDGE")]
    Bridge,
    /// generic support for unrecognized device types
    #[doc(alias = "NM_DEVICE_TYPE_GENERIC")]
    Generic,
    /// a team master interface
    #[doc(alias = "NM_DEVICE_TYPE_TEAM")]
    Team,
    /// a TUN or TAP interface
    #[doc(alias = "NM_DEVICE_TYPE_TUN")]
    Tun,
    /// a IP tunnel interface
    #[doc(alias = "NM_DEVICE_TYPE_IP_TUNNEL")]
    IpTunnel,
    /// a MACVLAN interface
    #[doc(alias = "NM_DEVICE_TYPE_MACVLAN")]
    Macvlan,
    /// a VXLAN interface
    #[doc(alias = "NM_DEVICE_TYPE_VXLAN")]
    Vxlan,
    /// a VETH interface
    #[doc(alias = "NM_DEVICE_TYPE_VETH")]
    Veth,
    /// a MACsec interface
    #[doc(alias = "NM_DEVICE_TYPE_MACSEC")]
    Macsec,
    /// a dummy interface
    #[doc(alias = "NM_DEVICE_TYPE_DUMMY")]
    Dummy,
    /// a PPP interface
    #[doc(alias = "NM_DEVICE_TYPE_PPP")]
    Ppp,
    /// a Open vSwitch interface
    #[doc(alias = "NM_DEVICE_TYPE_OVS_INTERFACE")]
    OvsInterface,
    /// a Open vSwitch port
    #[doc(alias = "NM_DEVICE_TYPE_OVS_PORT")]
    OvsPort,
    /// a Open vSwitch bridge
    #[doc(alias = "NM_DEVICE_TYPE_OVS_BRIDGE")]
    OvsBridge,
    /// a IEEE 802.15.4 (WPAN) MAC Layer Device
    #[doc(alias = "NM_DEVICE_TYPE_WPAN")]
    Wpan,
    /// 6LoWPAN interface
    #[doc(alias = "NM_DEVICE_TYPE_6LOWPAN")]
    _6lowpan,
    /// a WireGuard interface
    #[doc(alias = "NM_DEVICE_TYPE_WIREGUARD")]
    Wireguard,
    /// an 802.11 Wi-Fi P2P device. Since: 1.16.
    #[doc(alias = "NM_DEVICE_TYPE_WIFI_P2P")]
    WifiP2p,
    /// A VRF (Virtual Routing and Forwarding) interface. Since: 1.24.
    #[doc(alias = "NM_DEVICE_TYPE_VRF")]
    Vrf,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DeviceType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DeviceType::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::Ethernet => "Ethernet",
                Self::Wifi => "Wifi",
                Self::Unused1 => "Unused1",
                Self::Unused2 => "Unused2",
                Self::Bt => "Bt",
                Self::OlpcMesh => "OlpcMesh",
                Self::Wimax => "Wimax",
                Self::Modem => "Modem",
                Self::Infiniband => "Infiniband",
                Self::Bond => "Bond",
                Self::Vlan => "Vlan",
                Self::Adsl => "Adsl",
                Self::Bridge => "Bridge",
                Self::Generic => "Generic",
                Self::Team => "Team",
                Self::Tun => "Tun",
                Self::IpTunnel => "IpTunnel",
                Self::Macvlan => "Macvlan",
                Self::Vxlan => "Vxlan",
                Self::Veth => "Veth",
                Self::Macsec => "Macsec",
                Self::Dummy => "Dummy",
                Self::Ppp => "Ppp",
                Self::OvsInterface => "OvsInterface",
                Self::OvsPort => "OvsPort",
                Self::OvsBridge => "OvsBridge",
                Self::Wpan => "Wpan",
                Self::_6lowpan => "_6lowpan",
                Self::Wireguard => "Wireguard",
                Self::WifiP2p => "WifiP2p",
                Self::Vrf => "Vrf",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for DeviceType {
    type GlibType = ffi::NMDeviceType;

    fn into_glib(self) -> ffi::NMDeviceType {
        match self {
            Self::Unknown => ffi::NM_DEVICE_TYPE_UNKNOWN,
            Self::Ethernet => ffi::NM_DEVICE_TYPE_ETHERNET,
            Self::Wifi => ffi::NM_DEVICE_TYPE_WIFI,
            Self::Unused1 => ffi::NM_DEVICE_TYPE_UNUSED1,
            Self::Unused2 => ffi::NM_DEVICE_TYPE_UNUSED2,
            Self::Bt => ffi::NM_DEVICE_TYPE_BT,
            Self::OlpcMesh => ffi::NM_DEVICE_TYPE_OLPC_MESH,
            Self::Wimax => ffi::NM_DEVICE_TYPE_WIMAX,
            Self::Modem => ffi::NM_DEVICE_TYPE_MODEM,
            Self::Infiniband => ffi::NM_DEVICE_TYPE_INFINIBAND,
            Self::Bond => ffi::NM_DEVICE_TYPE_BOND,
            Self::Vlan => ffi::NM_DEVICE_TYPE_VLAN,
            Self::Adsl => ffi::NM_DEVICE_TYPE_ADSL,
            Self::Bridge => ffi::NM_DEVICE_TYPE_BRIDGE,
            Self::Generic => ffi::NM_DEVICE_TYPE_GENERIC,
            Self::Team => ffi::NM_DEVICE_TYPE_TEAM,
            Self::Tun => ffi::NM_DEVICE_TYPE_TUN,
            Self::IpTunnel => ffi::NM_DEVICE_TYPE_IP_TUNNEL,
            Self::Macvlan => ffi::NM_DEVICE_TYPE_MACVLAN,
            Self::Vxlan => ffi::NM_DEVICE_TYPE_VXLAN,
            Self::Veth => ffi::NM_DEVICE_TYPE_VETH,
            Self::Macsec => ffi::NM_DEVICE_TYPE_MACSEC,
            Self::Dummy => ffi::NM_DEVICE_TYPE_DUMMY,
            Self::Ppp => ffi::NM_DEVICE_TYPE_PPP,
            Self::OvsInterface => ffi::NM_DEVICE_TYPE_OVS_INTERFACE,
            Self::OvsPort => ffi::NM_DEVICE_TYPE_OVS_PORT,
            Self::OvsBridge => ffi::NM_DEVICE_TYPE_OVS_BRIDGE,
            Self::Wpan => ffi::NM_DEVICE_TYPE_WPAN,
            Self::_6lowpan => ffi::NM_DEVICE_TYPE_6LOWPAN,
            Self::Wireguard => ffi::NM_DEVICE_TYPE_WIREGUARD,
            Self::WifiP2p => ffi::NM_DEVICE_TYPE_WIFI_P2P,
            Self::Vrf => ffi::NM_DEVICE_TYPE_VRF,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMDeviceType> for DeviceType {
    unsafe fn from_glib(value: ffi::NMDeviceType) -> Self {
        match value {
            ffi::NM_DEVICE_TYPE_UNKNOWN => Self::Unknown,
            ffi::NM_DEVICE_TYPE_ETHERNET => Self::Ethernet,
            ffi::NM_DEVICE_TYPE_WIFI => Self::Wifi,
            ffi::NM_DEVICE_TYPE_UNUSED1 => Self::Unused1,
            ffi::NM_DEVICE_TYPE_UNUSED2 => Self::Unused2,
            ffi::NM_DEVICE_TYPE_BT => Self::Bt,
            ffi::NM_DEVICE_TYPE_OLPC_MESH => Self::OlpcMesh,
            ffi::NM_DEVICE_TYPE_WIMAX => Self::Wimax,
            ffi::NM_DEVICE_TYPE_MODEM => Self::Modem,
            ffi::NM_DEVICE_TYPE_INFINIBAND => Self::Infiniband,
            ffi::NM_DEVICE_TYPE_BOND => Self::Bond,
            ffi::NM_DEVICE_TYPE_VLAN => Self::Vlan,
            ffi::NM_DEVICE_TYPE_ADSL => Self::Adsl,
            ffi::NM_DEVICE_TYPE_BRIDGE => Self::Bridge,
            ffi::NM_DEVICE_TYPE_GENERIC => Self::Generic,
            ffi::NM_DEVICE_TYPE_TEAM => Self::Team,
            ffi::NM_DEVICE_TYPE_TUN => Self::Tun,
            ffi::NM_DEVICE_TYPE_IP_TUNNEL => Self::IpTunnel,
            ffi::NM_DEVICE_TYPE_MACVLAN => Self::Macvlan,
            ffi::NM_DEVICE_TYPE_VXLAN => Self::Vxlan,
            ffi::NM_DEVICE_TYPE_VETH => Self::Veth,
            ffi::NM_DEVICE_TYPE_MACSEC => Self::Macsec,
            ffi::NM_DEVICE_TYPE_DUMMY => Self::Dummy,
            ffi::NM_DEVICE_TYPE_PPP => Self::Ppp,
            ffi::NM_DEVICE_TYPE_OVS_INTERFACE => Self::OvsInterface,
            ffi::NM_DEVICE_TYPE_OVS_PORT => Self::OvsPort,
            ffi::NM_DEVICE_TYPE_OVS_BRIDGE => Self::OvsBridge,
            ffi::NM_DEVICE_TYPE_WPAN => Self::Wpan,
            ffi::NM_DEVICE_TYPE_6LOWPAN => Self::_6lowpan,
            ffi::NM_DEVICE_TYPE_WIREGUARD => Self::Wireguard,
            ffi::NM_DEVICE_TYPE_WIFI_P2P => Self::WifiP2p,
            ffi::NM_DEVICE_TYPE_VRF => Self::Vrf,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for DeviceType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_device_type_get_type()) }
    }
}

impl glib::value::ValueType for DeviceType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for DeviceType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DeviceType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// The tunneling mode.
#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMIPTunnelMode")]
pub enum IPTunnelMode {
    /// Unknown/unset tunnel mode
    #[doc(alias = "NM_IP_TUNNEL_MODE_UNKNOWN")]
    Unknown,
    /// IP in IP tunnel
    #[doc(alias = "NM_IP_TUNNEL_MODE_IPIP")]
    Ipip,
    /// GRE tunnel
    #[doc(alias = "NM_IP_TUNNEL_MODE_GRE")]
    Gre,
    /// SIT tunnel
    #[doc(alias = "NM_IP_TUNNEL_MODE_SIT")]
    Sit,
    /// ISATAP tunnel
    #[doc(alias = "NM_IP_TUNNEL_MODE_ISATAP")]
    Isatap,
    /// VTI tunnel
    #[doc(alias = "NM_IP_TUNNEL_MODE_VTI")]
    Vti,
    /// IPv6 in IPv6 tunnel
    #[doc(alias = "NM_IP_TUNNEL_MODE_IP6IP6")]
    Ip6ip6,
    /// IPv4 in IPv6 tunnel
    #[doc(alias = "NM_IP_TUNNEL_MODE_IPIP6")]
    Ipip6,
    /// IPv6 GRE tunnel
    #[doc(alias = "NM_IP_TUNNEL_MODE_IP6GRE")]
    Ip6gre,
    /// IPv6 VTI tunnel
    #[doc(alias = "NM_IP_TUNNEL_MODE_VTI6")]
    Vti6,
    /// GRETAP tunnel
    #[doc(alias = "NM_IP_TUNNEL_MODE_GRETAP")]
    Gretap,
    /// IPv6 GRETAP tunnel
    #[doc(alias = "NM_IP_TUNNEL_MODE_IP6GRETAP")]
    Ip6gretap,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
impl fmt::Display for IPTunnelMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "IPTunnelMode::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::Ipip => "Ipip",
                Self::Gre => "Gre",
                Self::Sit => "Sit",
                Self::Isatap => "Isatap",
                Self::Vti => "Vti",
                Self::Ip6ip6 => "Ip6ip6",
                Self::Ipip6 => "Ipip6",
                Self::Ip6gre => "Ip6gre",
                Self::Vti6 => "Vti6",
                Self::Gretap => "Gretap",
                Self::Ip6gretap => "Ip6gretap",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl IntoGlib for IPTunnelMode {
    type GlibType = ffi::NMIPTunnelMode;

    fn into_glib(self) -> ffi::NMIPTunnelMode {
        match self {
            Self::Unknown => ffi::NM_IP_TUNNEL_MODE_UNKNOWN,
            Self::Ipip => ffi::NM_IP_TUNNEL_MODE_IPIP,
            Self::Gre => ffi::NM_IP_TUNNEL_MODE_GRE,
            Self::Sit => ffi::NM_IP_TUNNEL_MODE_SIT,
            Self::Isatap => ffi::NM_IP_TUNNEL_MODE_ISATAP,
            Self::Vti => ffi::NM_IP_TUNNEL_MODE_VTI,
            Self::Ip6ip6 => ffi::NM_IP_TUNNEL_MODE_IP6IP6,
            Self::Ipip6 => ffi::NM_IP_TUNNEL_MODE_IPIP6,
            Self::Ip6gre => ffi::NM_IP_TUNNEL_MODE_IP6GRE,
            Self::Vti6 => ffi::NM_IP_TUNNEL_MODE_VTI6,
            Self::Gretap => ffi::NM_IP_TUNNEL_MODE_GRETAP,
            Self::Ip6gretap => ffi::NM_IP_TUNNEL_MODE_IP6GRETAP,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl FromGlib<ffi::NMIPTunnelMode> for IPTunnelMode {
    unsafe fn from_glib(value: ffi::NMIPTunnelMode) -> Self {
        match value {
            ffi::NM_IP_TUNNEL_MODE_UNKNOWN => Self::Unknown,
            ffi::NM_IP_TUNNEL_MODE_IPIP => Self::Ipip,
            ffi::NM_IP_TUNNEL_MODE_GRE => Self::Gre,
            ffi::NM_IP_TUNNEL_MODE_SIT => Self::Sit,
            ffi::NM_IP_TUNNEL_MODE_ISATAP => Self::Isatap,
            ffi::NM_IP_TUNNEL_MODE_VTI => Self::Vti,
            ffi::NM_IP_TUNNEL_MODE_IP6IP6 => Self::Ip6ip6,
            ffi::NM_IP_TUNNEL_MODE_IPIP6 => Self::Ipip6,
            ffi::NM_IP_TUNNEL_MODE_IP6GRE => Self::Ip6gre,
            ffi::NM_IP_TUNNEL_MODE_VTI6 => Self::Vti6,
            ffi::NM_IP_TUNNEL_MODE_GRETAP => Self::Gretap,
            ffi::NM_IP_TUNNEL_MODE_IP6GRETAP => Self::Ip6gretap,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
impl StaticType for IPTunnelMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_ip_tunnel_mode_get_type()) }
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
impl glib::value::ValueType for IPTunnelMode {
    type Type = Self;
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
unsafe impl<'a> FromValue<'a> for IPTunnelMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
impl ToValue for IPTunnelMode {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// The type of the callback for `NMKeyfileReadHandler` and `NMKeyfileWriteHandler`.
/// Depending on the type, you can interpret `NMKeyfileHandlerData`.
#[cfg(any(feature = "v1_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMKeyfileHandlerType")]
pub enum KeyfileHandlerType {
    /// a warning.
    #[doc(alias = "NM_KEYFILE_HANDLER_TYPE_WARN")]
    Warn,
    /// for handling certificates while writing
    ///  a connection to keyfile.
    #[doc(alias = "NM_KEYFILE_HANDLER_TYPE_WRITE_CERT")]
    WriteCert,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
impl fmt::Display for KeyfileHandlerType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "KeyfileHandlerType::{}",
            match *self {
                Self::Warn => "Warn",
                Self::WriteCert => "WriteCert",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
#[doc(hidden)]
impl IntoGlib for KeyfileHandlerType {
    type GlibType = ffi::NMKeyfileHandlerType;

    fn into_glib(self) -> ffi::NMKeyfileHandlerType {
        match self {
            Self::Warn => ffi::NM_KEYFILE_HANDLER_TYPE_WARN,
            Self::WriteCert => ffi::NM_KEYFILE_HANDLER_TYPE_WRITE_CERT,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
#[doc(hidden)]
impl FromGlib<ffi::NMKeyfileHandlerType> for KeyfileHandlerType {
    unsafe fn from_glib(value: ffi::NMKeyfileHandlerType) -> Self {
        match value {
            ffi::NM_KEYFILE_HANDLER_TYPE_WARN => Self::Warn,
            ffi::NM_KEYFILE_HANDLER_TYPE_WRITE_CERT => Self::WriteCert,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
impl StaticType for KeyfileHandlerType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_keyfile_handler_type_get_type()) }
    }
}

#[cfg(any(feature = "v1_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
impl glib::value::ValueType for KeyfileHandlerType {
    type Type = Self;
}

#[cfg(any(feature = "v1_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
unsafe impl<'a> FromValue<'a> for KeyfileHandlerType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
impl ToValue for KeyfileHandlerType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// The severity level of [`KeyfileHandlerType::Warn`][crate::KeyfileHandlerType::Warn] events.
#[cfg(any(feature = "v1_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMKeyfileWarnSeverity")]
pub enum KeyfileWarnSeverity {
    /// debug message
    #[doc(alias = "NM_KEYFILE_WARN_SEVERITY_DEBUG")]
    Debug,
    /// info message
    #[doc(alias = "NM_KEYFILE_WARN_SEVERITY_INFO")]
    Info,
    /// info message about a missing file
    #[doc(alias = "NM_KEYFILE_WARN_SEVERITY_INFO_MISSING_FILE")]
    InfoMissingFile,
    /// a warning message
    #[doc(alias = "NM_KEYFILE_WARN_SEVERITY_WARN")]
    Warn,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
impl fmt::Display for KeyfileWarnSeverity {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "KeyfileWarnSeverity::{}",
            match *self {
                Self::Debug => "Debug",
                Self::Info => "Info",
                Self::InfoMissingFile => "InfoMissingFile",
                Self::Warn => "Warn",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
#[doc(hidden)]
impl IntoGlib for KeyfileWarnSeverity {
    type GlibType = ffi::NMKeyfileWarnSeverity;

    fn into_glib(self) -> ffi::NMKeyfileWarnSeverity {
        match self {
            Self::Debug => ffi::NM_KEYFILE_WARN_SEVERITY_DEBUG,
            Self::Info => ffi::NM_KEYFILE_WARN_SEVERITY_INFO,
            Self::InfoMissingFile => ffi::NM_KEYFILE_WARN_SEVERITY_INFO_MISSING_FILE,
            Self::Warn => ffi::NM_KEYFILE_WARN_SEVERITY_WARN,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
#[doc(hidden)]
impl FromGlib<ffi::NMKeyfileWarnSeverity> for KeyfileWarnSeverity {
    unsafe fn from_glib(value: ffi::NMKeyfileWarnSeverity) -> Self {
        match value {
            ffi::NM_KEYFILE_WARN_SEVERITY_DEBUG => Self::Debug,
            ffi::NM_KEYFILE_WARN_SEVERITY_INFO => Self::Info,
            ffi::NM_KEYFILE_WARN_SEVERITY_INFO_MISSING_FILE => Self::InfoMissingFile,
            ffi::NM_KEYFILE_WARN_SEVERITY_WARN => Self::Warn,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
impl StaticType for KeyfileWarnSeverity {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_keyfile_warn_severity_get_type()) }
    }
}

#[cfg(any(feature = "v1_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
impl glib::value::ValueType for KeyfileWarnSeverity {
    type Type = Self;
}

#[cfg(any(feature = "v1_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
unsafe impl<'a> FromValue<'a> for KeyfileWarnSeverity {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_30")))]
impl ToValue for KeyfileWarnSeverity {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// Errors related to the main "network management" interface of NetworkManager.
/// These may be returned from [`Client`][crate::Client] methods that invoke D-Bus operations on
/// the "org.freedesktop.NetworkManager" interface, and correspond to D-Bus
/// errors in that namespace.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMManagerError")]
pub enum ManagerError {
    /// unknown or unclassified error
    #[doc(alias = "NM_MANAGER_ERROR_FAILED")]
    Failed,
    /// Permission denied.
    #[doc(alias = "NM_MANAGER_ERROR_PERMISSION_DENIED")]
    PermissionDenied,
    /// The requested connection is not known.
    #[doc(alias = "NM_MANAGER_ERROR_UNKNOWN_CONNECTION")]
    UnknownConnection,
    /// The requested device is not known.
    #[doc(alias = "NM_MANAGER_ERROR_UNKNOWN_DEVICE")]
    UnknownDevice,
    /// The requested connection cannot be
    ///  activated at this time.
    #[doc(alias = "NM_MANAGER_ERROR_CONNECTION_NOT_AVAILABLE")]
    ConnectionNotAvailable,
    /// The request could not be completed
    ///  because a required connection is not active.
    #[doc(alias = "NM_MANAGER_ERROR_CONNECTION_NOT_ACTIVE")]
    ConnectionNotActive,
    /// The connection to be activated was
    ///  already active on another device.
    #[doc(alias = "NM_MANAGER_ERROR_CONNECTION_ALREADY_ACTIVE")]
    ConnectionAlreadyActive,
    /// An activation request failed due to a
    ///  dependency being unavailable.
    #[doc(alias = "NM_MANAGER_ERROR_DEPENDENCY_FAILED")]
    DependencyFailed,
    /// The manager is already in the requested
    ///  sleep/wake state.
    #[doc(alias = "NM_MANAGER_ERROR_ALREADY_ASLEEP_OR_AWAKE")]
    AlreadyAsleepOrAwake,
    /// The network is already
    ///  enabled/disabled.
    #[doc(alias = "NM_MANAGER_ERROR_ALREADY_ENABLED_OR_DISABLED")]
    AlreadyEnabledOrDisabled,
    /// Unknown log level in SetLogging
    #[doc(alias = "NM_MANAGER_ERROR_UNKNOWN_LOG_LEVEL")]
    UnknownLogLevel,
    /// Unknown log domain in SetLogging
    #[doc(alias = "NM_MANAGER_ERROR_UNKNOWN_LOG_DOMAIN")]
    UnknownLogDomain,
    /// Invalid arguments for D-Bus request
    #[doc(alias = "NM_MANAGER_ERROR_INVALID_ARGUMENTS")]
    InvalidArguments,
    /// A plug-in was needed to complete the
    ///  activation but is not available.
    #[doc(alias = "NM_MANAGER_ERROR_MISSING_PLUGIN")]
    MissingPlugin,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ManagerError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ManagerError::{}",
            match *self {
                Self::Failed => "Failed",
                Self::PermissionDenied => "PermissionDenied",
                Self::UnknownConnection => "UnknownConnection",
                Self::UnknownDevice => "UnknownDevice",
                Self::ConnectionNotAvailable => "ConnectionNotAvailable",
                Self::ConnectionNotActive => "ConnectionNotActive",
                Self::ConnectionAlreadyActive => "ConnectionAlreadyActive",
                Self::DependencyFailed => "DependencyFailed",
                Self::AlreadyAsleepOrAwake => "AlreadyAsleepOrAwake",
                Self::AlreadyEnabledOrDisabled => "AlreadyEnabledOrDisabled",
                Self::UnknownLogLevel => "UnknownLogLevel",
                Self::UnknownLogDomain => "UnknownLogDomain",
                Self::InvalidArguments => "InvalidArguments",
                Self::MissingPlugin => "MissingPlugin",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for ManagerError {
    type GlibType = ffi::NMManagerError;

    fn into_glib(self) -> ffi::NMManagerError {
        match self {
            Self::Failed => ffi::NM_MANAGER_ERROR_FAILED,
            Self::PermissionDenied => ffi::NM_MANAGER_ERROR_PERMISSION_DENIED,
            Self::UnknownConnection => ffi::NM_MANAGER_ERROR_UNKNOWN_CONNECTION,
            Self::UnknownDevice => ffi::NM_MANAGER_ERROR_UNKNOWN_DEVICE,
            Self::ConnectionNotAvailable => ffi::NM_MANAGER_ERROR_CONNECTION_NOT_AVAILABLE,
            Self::ConnectionNotActive => ffi::NM_MANAGER_ERROR_CONNECTION_NOT_ACTIVE,
            Self::ConnectionAlreadyActive => ffi::NM_MANAGER_ERROR_CONNECTION_ALREADY_ACTIVE,
            Self::DependencyFailed => ffi::NM_MANAGER_ERROR_DEPENDENCY_FAILED,
            Self::AlreadyAsleepOrAwake => ffi::NM_MANAGER_ERROR_ALREADY_ASLEEP_OR_AWAKE,
            Self::AlreadyEnabledOrDisabled => ffi::NM_MANAGER_ERROR_ALREADY_ENABLED_OR_DISABLED,
            Self::UnknownLogLevel => ffi::NM_MANAGER_ERROR_UNKNOWN_LOG_LEVEL,
            Self::UnknownLogDomain => ffi::NM_MANAGER_ERROR_UNKNOWN_LOG_DOMAIN,
            Self::InvalidArguments => ffi::NM_MANAGER_ERROR_INVALID_ARGUMENTS,
            Self::MissingPlugin => ffi::NM_MANAGER_ERROR_MISSING_PLUGIN,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMManagerError> for ManagerError {
    unsafe fn from_glib(value: ffi::NMManagerError) -> Self {
        match value {
            ffi::NM_MANAGER_ERROR_FAILED => Self::Failed,
            ffi::NM_MANAGER_ERROR_PERMISSION_DENIED => Self::PermissionDenied,
            ffi::NM_MANAGER_ERROR_UNKNOWN_CONNECTION => Self::UnknownConnection,
            ffi::NM_MANAGER_ERROR_UNKNOWN_DEVICE => Self::UnknownDevice,
            ffi::NM_MANAGER_ERROR_CONNECTION_NOT_AVAILABLE => Self::ConnectionNotAvailable,
            ffi::NM_MANAGER_ERROR_CONNECTION_NOT_ACTIVE => Self::ConnectionNotActive,
            ffi::NM_MANAGER_ERROR_CONNECTION_ALREADY_ACTIVE => Self::ConnectionAlreadyActive,
            ffi::NM_MANAGER_ERROR_DEPENDENCY_FAILED => Self::DependencyFailed,
            ffi::NM_MANAGER_ERROR_ALREADY_ASLEEP_OR_AWAKE => Self::AlreadyAsleepOrAwake,
            ffi::NM_MANAGER_ERROR_ALREADY_ENABLED_OR_DISABLED => Self::AlreadyEnabledOrDisabled,
            ffi::NM_MANAGER_ERROR_UNKNOWN_LOG_LEVEL => Self::UnknownLogLevel,
            ffi::NM_MANAGER_ERROR_UNKNOWN_LOG_DOMAIN => Self::UnknownLogDomain,
            ffi::NM_MANAGER_ERROR_INVALID_ARGUMENTS => Self::InvalidArguments,
            ffi::NM_MANAGER_ERROR_MISSING_PLUGIN => Self::MissingPlugin,
            value => Self::__Unknown(value),
        }
    }
}

impl ErrorDomain for ManagerError {
    fn domain() -> Quark {
        unsafe { from_glib(ffi::nm_manager_error_quark()) }
    }

    fn code(self) -> i32 {
        self.into_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            ffi::NM_MANAGER_ERROR_FAILED => Some(Self::Failed),
            ffi::NM_MANAGER_ERROR_PERMISSION_DENIED => Some(Self::PermissionDenied),
            ffi::NM_MANAGER_ERROR_UNKNOWN_CONNECTION => Some(Self::UnknownConnection),
            ffi::NM_MANAGER_ERROR_UNKNOWN_DEVICE => Some(Self::UnknownDevice),
            ffi::NM_MANAGER_ERROR_CONNECTION_NOT_AVAILABLE => Some(Self::ConnectionNotAvailable),
            ffi::NM_MANAGER_ERROR_CONNECTION_NOT_ACTIVE => Some(Self::ConnectionNotActive),
            ffi::NM_MANAGER_ERROR_CONNECTION_ALREADY_ACTIVE => Some(Self::ConnectionAlreadyActive),
            ffi::NM_MANAGER_ERROR_DEPENDENCY_FAILED => Some(Self::DependencyFailed),
            ffi::NM_MANAGER_ERROR_ALREADY_ASLEEP_OR_AWAKE => Some(Self::AlreadyAsleepOrAwake),
            ffi::NM_MANAGER_ERROR_ALREADY_ENABLED_OR_DISABLED => {
                Some(Self::AlreadyEnabledOrDisabled)
            }
            ffi::NM_MANAGER_ERROR_UNKNOWN_LOG_LEVEL => Some(Self::UnknownLogLevel),
            ffi::NM_MANAGER_ERROR_UNKNOWN_LOG_DOMAIN => Some(Self::UnknownLogDomain),
            ffi::NM_MANAGER_ERROR_INVALID_ARGUMENTS => Some(Self::InvalidArguments),
            ffi::NM_MANAGER_ERROR_MISSING_PLUGIN => Some(Self::MissingPlugin),
            _ => Some(Self::Failed),
        }
    }
}

impl StaticType for ManagerError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_manager_error_get_type()) }
    }
}

impl glib::value::ValueType for ManagerError {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ManagerError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ManagerError {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// The NMMetered enum has two different purposes: one is to configure
/// "connection.metered" setting of a connection profile in [`SettingConnection`][crate::SettingConnection], and
/// the other is to express the actual metered state of the [`Device`][crate::Device] at a given moment.
///
/// For the connection profile only [`Unknown`][Self::Unknown], [`No`][Self::No]
/// and [`Yes`][Self::Yes] are allowed.
///
/// The device's metered state at runtime is determined by the profile
/// which is currently active. If the profile explicitly specifies [`No`][Self::No]
/// or [`Yes`][Self::Yes], then the device's metered state is as such.
/// If the connection profile leaves it undecided at [`Unknown`][Self::Unknown] (the default),
/// then NetworkManager tries to guess the metered state, for example based on the
/// device type or on DHCP options (like Android devices exposing a "ANDROID_METERED"
/// DHCP vendor option). This then leads to either [`GuessNo`][Self::GuessNo] or [`GuessYes`][Self::GuessYes].
///
/// Most applications probably should treat the runtime state [`GuessYes`][Self::GuessYes]
/// like [`Yes`][Self::Yes], and all other states as not metered.
///
/// Note that the per-device metered states are then combined to a global metered
/// state. This is basically the metered state of the device with the best default
/// route. However, that generalization of a global metered state may not be correct
/// if the default routes for IPv4 and IPv6 are on different devices, or if policy
/// routing is configured. In general, the global metered state tries to express whether
/// the traffic is likely metered, but since that depends on the traffic itself,
/// there is not one answer in all cases. Hence, an application may want to consider
/// the per-device's metered states.
#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMMetered")]
pub enum Metered {
    /// The metered status is unknown
    #[doc(alias = "NM_METERED_UNKNOWN")]
    Unknown,
    /// Metered, the value was explicitly configured
    #[doc(alias = "NM_METERED_YES")]
    Yes,
    /// Not metered, the value was explicitly configured
    #[doc(alias = "NM_METERED_NO")]
    No,
    /// Metered, the value was guessed
    #[doc(alias = "NM_METERED_GUESS_YES")]
    GuessYes,
    /// Not metered, the value was guessed
    #[doc(alias = "NM_METERED_GUESS_NO")]
    GuessNo,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
impl fmt::Display for Metered {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Metered::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::Yes => "Yes",
                Self::No => "No",
                Self::GuessYes => "GuessYes",
                Self::GuessNo => "GuessNo",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl IntoGlib for Metered {
    type GlibType = ffi::NMMetered;

    fn into_glib(self) -> ffi::NMMetered {
        match self {
            Self::Unknown => ffi::NM_METERED_UNKNOWN,
            Self::Yes => ffi::NM_METERED_YES,
            Self::No => ffi::NM_METERED_NO,
            Self::GuessYes => ffi::NM_METERED_GUESS_YES,
            Self::GuessNo => ffi::NM_METERED_GUESS_NO,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl FromGlib<ffi::NMMetered> for Metered {
    unsafe fn from_glib(value: ffi::NMMetered) -> Self {
        match value {
            ffi::NM_METERED_UNKNOWN => Self::Unknown,
            ffi::NM_METERED_YES => Self::Yes,
            ffi::NM_METERED_NO => Self::No,
            ffi::NM_METERED_GUESS_YES => Self::GuessYes,
            ffi::NM_METERED_GUESS_NO => Self::GuessNo,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
impl StaticType for Metered {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_metered_get_type()) }
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
impl glib::value::ValueType for Metered {
    type Type = Self;
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
unsafe impl<'a> FromValue<'a> for Metered {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
impl ToValue for Metered {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// The result of a checkpoint Rollback() operation for a specific device.
#[cfg(any(feature = "v1_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMRollbackResult")]
pub enum RollbackResult {
    /// the rollback succeeded.
    #[doc(alias = "NM_ROLLBACK_RESULT_OK")]
    Ok,
    /// the device no longer exists.
    #[doc(alias = "NM_ROLLBACK_RESULT_ERR_NO_DEVICE")]
    ErrNoDevice,
    /// the device is now unmanaged.
    #[doc(alias = "NM_ROLLBACK_RESULT_ERR_DEVICE_UNMANAGED")]
    ErrDeviceUnmanaged,
    /// other errors during rollback.
    #[doc(alias = "NM_ROLLBACK_RESULT_ERR_FAILED")]
    ErrFailed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
impl fmt::Display for RollbackResult {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "RollbackResult::{}",
            match *self {
                Self::Ok => "Ok",
                Self::ErrNoDevice => "ErrNoDevice",
                Self::ErrDeviceUnmanaged => "ErrDeviceUnmanaged",
                Self::ErrFailed => "ErrFailed",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
#[doc(hidden)]
impl IntoGlib for RollbackResult {
    type GlibType = ffi::NMRollbackResult;

    fn into_glib(self) -> ffi::NMRollbackResult {
        match self {
            Self::Ok => ffi::NM_ROLLBACK_RESULT_OK,
            Self::ErrNoDevice => ffi::NM_ROLLBACK_RESULT_ERR_NO_DEVICE,
            Self::ErrDeviceUnmanaged => ffi::NM_ROLLBACK_RESULT_ERR_DEVICE_UNMANAGED,
            Self::ErrFailed => ffi::NM_ROLLBACK_RESULT_ERR_FAILED,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_4")))]
#[doc(hidden)]
impl FromGlib<ffi::NMRollbackResult> for RollbackResult {
    unsafe fn from_glib(value: ffi::NMRollbackResult) -> Self {
        match value {
            ffi::NM_ROLLBACK_RESULT_OK => Self::Ok,
            ffi::NM_ROLLBACK_RESULT_ERR_NO_DEVICE => Self::ErrNoDevice,
            ffi::NM_ROLLBACK_RESULT_ERR_DEVICE_UNMANAGED => Self::ErrDeviceUnmanaged,
            ffi::NM_ROLLBACK_RESULT_ERR_FAILED => Self::ErrFailed,
            value => Self::__Unknown(value),
        }
    }
}

/// [`SecretAgentError`][crate::SecretAgentError] values are passed by secret agents back to NetworkManager
/// when they encounter problems retrieving secrets on behalf of NM. They
/// correspond to errors in the "org.freedesktop.NetworkManager.SecretManager"
/// namespace.
///
/// Client APIs such as `nm_client_activate_connection()` will not see these error
/// codes; instead, the secret agent manager will translate them to the
/// corresponding [`AgentManagerError`][crate::AgentManagerError] codes.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSecretAgentError")]
pub enum SecretAgentError {
    /// unknown or unclassified error
    #[doc(alias = "NM_SECRET_AGENT_ERROR_FAILED")]
    Failed,
    /// the caller (ie, NetworkManager) is
    ///  not authorized to make this request
    #[doc(alias = "NM_SECRET_AGENT_ERROR_PERMISSION_DENIED")]
    PermissionDenied,
    /// the connection for which secrets
    ///  were requested is invalid
    #[doc(alias = "NM_SECRET_AGENT_ERROR_INVALID_CONNECTION")]
    InvalidConnection,
    /// the request was canceled by the user
    #[doc(alias = "NM_SECRET_AGENT_ERROR_USER_CANCELED")]
    UserCanceled,
    /// the agent canceled the request
    ///  because it was requested to do so by NetworkManager
    #[doc(alias = "NM_SECRET_AGENT_ERROR_AGENT_CANCELED")]
    AgentCanceled,
    /// the agent cannot find any secrets for this
    ///  connection
    #[doc(alias = "NM_SECRET_AGENT_ERROR_NO_SECRETS")]
    NoSecrets,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SecretAgentError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SecretAgentError::{}",
            match *self {
                Self::Failed => "Failed",
                Self::PermissionDenied => "PermissionDenied",
                Self::InvalidConnection => "InvalidConnection",
                Self::UserCanceled => "UserCanceled",
                Self::AgentCanceled => "AgentCanceled",
                Self::NoSecrets => "NoSecrets",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for SecretAgentError {
    type GlibType = ffi::NMSecretAgentError;

    fn into_glib(self) -> ffi::NMSecretAgentError {
        match self {
            Self::Failed => ffi::NM_SECRET_AGENT_ERROR_FAILED,
            Self::PermissionDenied => ffi::NM_SECRET_AGENT_ERROR_PERMISSION_DENIED,
            Self::InvalidConnection => ffi::NM_SECRET_AGENT_ERROR_INVALID_CONNECTION,
            Self::UserCanceled => ffi::NM_SECRET_AGENT_ERROR_USER_CANCELED,
            Self::AgentCanceled => ffi::NM_SECRET_AGENT_ERROR_AGENT_CANCELED,
            Self::NoSecrets => ffi::NM_SECRET_AGENT_ERROR_NO_SECRETS,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSecretAgentError> for SecretAgentError {
    unsafe fn from_glib(value: ffi::NMSecretAgentError) -> Self {
        match value {
            ffi::NM_SECRET_AGENT_ERROR_FAILED => Self::Failed,
            ffi::NM_SECRET_AGENT_ERROR_PERMISSION_DENIED => Self::PermissionDenied,
            ffi::NM_SECRET_AGENT_ERROR_INVALID_CONNECTION => Self::InvalidConnection,
            ffi::NM_SECRET_AGENT_ERROR_USER_CANCELED => Self::UserCanceled,
            ffi::NM_SECRET_AGENT_ERROR_AGENT_CANCELED => Self::AgentCanceled,
            ffi::NM_SECRET_AGENT_ERROR_NO_SECRETS => Self::NoSecrets,
            value => Self::__Unknown(value),
        }
    }
}

impl ErrorDomain for SecretAgentError {
    fn domain() -> Quark {
        unsafe { from_glib(ffi::nm_secret_agent_error_quark()) }
    }

    fn code(self) -> i32 {
        self.into_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            ffi::NM_SECRET_AGENT_ERROR_FAILED => Some(Self::Failed),
            ffi::NM_SECRET_AGENT_ERROR_PERMISSION_DENIED => Some(Self::PermissionDenied),
            ffi::NM_SECRET_AGENT_ERROR_INVALID_CONNECTION => Some(Self::InvalidConnection),
            ffi::NM_SECRET_AGENT_ERROR_USER_CANCELED => Some(Self::UserCanceled),
            ffi::NM_SECRET_AGENT_ERROR_AGENT_CANCELED => Some(Self::AgentCanceled),
            ffi::NM_SECRET_AGENT_ERROR_NO_SECRETS => Some(Self::NoSecrets),
            _ => Some(Self::Failed),
        }
    }
}

impl StaticType for SecretAgentError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_secret_agent_error_get_type()) }
    }
}

impl glib::value::ValueType for SecretAgentError {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SecretAgentError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SecretAgentError {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// [`Setting8021xCKFormat`][crate::Setting8021xCKFormat] values indicate the general type of a certificate
/// or private key
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSetting8021xCKFormat")]
pub enum Setting8021xCKFormat {
    /// unknown file format
    #[doc(alias = "NM_SETTING_802_1X_CK_FORMAT_UNKNOWN")]
    Unknown,
    /// file contains an X.509 format certificate
    #[doc(alias = "NM_SETTING_802_1X_CK_FORMAT_X509")]
    X509,
    /// file contains an old-style OpenSSL PEM
    /// or DER private key
    #[doc(alias = "NM_SETTING_802_1X_CK_FORMAT_RAW_KEY")]
    RawKey,
    /// file contains a PKCS#<!-- -->12 certificate
    /// and private key
    #[doc(alias = "NM_SETTING_802_1X_CK_FORMAT_PKCS12")]
    Pkcs12,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Setting8021xCKFormat {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Setting8021xCKFormat::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::X509 => "X509",
                Self::RawKey => "RawKey",
                Self::Pkcs12 => "Pkcs12",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for Setting8021xCKFormat {
    type GlibType = ffi::NMSetting8021xCKFormat;

    fn into_glib(self) -> ffi::NMSetting8021xCKFormat {
        match self {
            Self::Unknown => ffi::NM_SETTING_802_1X_CK_FORMAT_UNKNOWN,
            Self::X509 => ffi::NM_SETTING_802_1X_CK_FORMAT_X509,
            Self::RawKey => ffi::NM_SETTING_802_1X_CK_FORMAT_RAW_KEY,
            Self::Pkcs12 => ffi::NM_SETTING_802_1X_CK_FORMAT_PKCS12,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSetting8021xCKFormat> for Setting8021xCKFormat {
    unsafe fn from_glib(value: ffi::NMSetting8021xCKFormat) -> Self {
        match value {
            ffi::NM_SETTING_802_1X_CK_FORMAT_UNKNOWN => Self::Unknown,
            ffi::NM_SETTING_802_1X_CK_FORMAT_X509 => Self::X509,
            ffi::NM_SETTING_802_1X_CK_FORMAT_RAW_KEY => Self::RawKey,
            ffi::NM_SETTING_802_1X_CK_FORMAT_PKCS12 => Self::Pkcs12,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for Setting8021xCKFormat {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_802_1x_ck_format_get_type()) }
    }
}

impl glib::value::ValueType for Setting8021xCKFormat {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for Setting8021xCKFormat {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for Setting8021xCKFormat {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// [`Setting8021xCKScheme`][crate::Setting8021xCKScheme] values indicate how a certificate or private key is
/// stored in the setting properties, either as a blob of the item's data, or as
/// a path to a certificate or private key file on the filesystem
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSetting8021xCKScheme")]
pub enum Setting8021xCKScheme {
    /// unknown certificate or private key
    /// scheme
    #[doc(alias = "NM_SETTING_802_1X_CK_SCHEME_UNKNOWN")]
    Unknown,
    /// certificate or key is stored as the raw
    /// item data
    #[doc(alias = "NM_SETTING_802_1X_CK_SCHEME_BLOB")]
    Blob,
    /// certificate or key is stored as a path
    /// to a file containing the certificate or key data
    #[doc(alias = "NM_SETTING_802_1X_CK_SCHEME_PATH")]
    Path,
    /// certificate or key is stored as a
    /// URI of an object on a PKCS`11` token
    #[doc(alias = "NM_SETTING_802_1X_CK_SCHEME_PKCS11")]
    Pkcs11,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Setting8021xCKScheme {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Setting8021xCKScheme::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::Blob => "Blob",
                Self::Path => "Path",
                Self::Pkcs11 => "Pkcs11",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for Setting8021xCKScheme {
    type GlibType = ffi::NMSetting8021xCKScheme;

    fn into_glib(self) -> ffi::NMSetting8021xCKScheme {
        match self {
            Self::Unknown => ffi::NM_SETTING_802_1X_CK_SCHEME_UNKNOWN,
            Self::Blob => ffi::NM_SETTING_802_1X_CK_SCHEME_BLOB,
            Self::Path => ffi::NM_SETTING_802_1X_CK_SCHEME_PATH,
            Self::Pkcs11 => ffi::NM_SETTING_802_1X_CK_SCHEME_PKCS11,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSetting8021xCKScheme> for Setting8021xCKScheme {
    unsafe fn from_glib(value: ffi::NMSetting8021xCKScheme) -> Self {
        match value {
            ffi::NM_SETTING_802_1X_CK_SCHEME_UNKNOWN => Self::Unknown,
            ffi::NM_SETTING_802_1X_CK_SCHEME_BLOB => Self::Blob,
            ffi::NM_SETTING_802_1X_CK_SCHEME_PATH => Self::Path,
            ffi::NM_SETTING_802_1X_CK_SCHEME_PKCS11 => Self::Pkcs11,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for Setting8021xCKScheme {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_802_1x_ck_scheme_get_type()) }
    }
}

impl glib::value::ValueType for Setting8021xCKScheme {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for Setting8021xCKScheme {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for Setting8021xCKScheme {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// These flags modify the comparison behavior when comparing two settings or
/// two connections.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingCompareFlags")]
pub enum SettingCompareFlags {
    /// match all properties exactly
    #[doc(alias = "NM_SETTING_COMPARE_FLAG_EXACT")]
    Exact,
    /// match only important attributes, like SSID,
    ///  type, security settings, etc. Does not match, for example, connection ID
    ///  or UUID.
    #[doc(alias = "NM_SETTING_COMPARE_FLAG_FUZZY")]
    Fuzzy,
    /// ignore the connection's ID
    #[doc(alias = "NM_SETTING_COMPARE_FLAG_IGNORE_ID")]
    IgnoreId,
    /// ignore all secrets
    #[doc(alias = "NM_SETTING_COMPARE_FLAG_IGNORE_SECRETS")]
    IgnoreSecrets,
    /// ignore secrets for which
    ///  the secret's flags indicate the secret is owned by a user secret agent
    ///  (ie, the secret's flag includes [`SettingSecretFlags::AGENT_OWNED`][crate::SettingSecretFlags::AGENT_OWNED])
    #[doc(alias = "NM_SETTING_COMPARE_FLAG_IGNORE_AGENT_OWNED_SECRETS")]
    IgnoreAgentOwnedSecrets,
    /// ignore secrets for which
    ///  the secret's flags indicate the secret should not be saved to persistent
    ///  storage (ie, the secret's flag includes [`SettingSecretFlags::NOT_SAVED`][crate::SettingSecretFlags::NOT_SAVED])
    #[doc(alias = "NM_SETTING_COMPARE_FLAG_IGNORE_NOT_SAVED_SECRETS")]
    IgnoreNotSavedSecrets,
    /// if this flag is set,
    ///  `nm_setting_diff()` and `nm_connection_diff()` will also include properties that
    ///  are set to their default value. See also [`DiffResultNoDefault`][Self::DiffResultNoDefault].
    #[doc(alias = "NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT")]
    DiffResultWithDefault,
    /// if this flag is set,
    ///  `nm_setting_diff()` and `nm_connection_diff()` will not include properties that
    ///  are set to their default value. This is the opposite of
    ///  [`DiffResultWithDefault`][Self::DiffResultWithDefault]. If both flags are set together,
    ///  [`DiffResultWithDefault`][Self::DiffResultWithDefault] wins. If both flags are unset,
    ///  this means to exclude default properties if there is a setting to compare,
    ///  but include all properties, if the setting 'b' is missing. This is the legacy
    ///  behaviour of libnm-util, where `nm_setting_diff()` behaved differently depending
    ///  on whether the setting 'b' was available. If [`DiffResultWithDefault`][Self::DiffResultWithDefault]
    ///  is set, `nm_setting_diff()` will also set the flags [`SettingDiffResult::InADefault`][crate::SettingDiffResult::InADefault]
    ///  and [`SettingDiffResult::InBDefault`][crate::SettingDiffResult::InBDefault], if the values are default values.
    #[doc(alias = "NM_SETTING_COMPARE_FLAG_DIFF_RESULT_NO_DEFAULT")]
    DiffResultNoDefault,
    /// ignore the connection's timestamp
    #[doc(alias = "NM_SETTING_COMPARE_FLAG_IGNORE_TIMESTAMP")]
    IgnoreTimestamp,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SettingCompareFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingCompareFlags::{}",
            match *self {
                Self::Exact => "Exact",
                Self::Fuzzy => "Fuzzy",
                Self::IgnoreId => "IgnoreId",
                Self::IgnoreSecrets => "IgnoreSecrets",
                Self::IgnoreAgentOwnedSecrets => "IgnoreAgentOwnedSecrets",
                Self::IgnoreNotSavedSecrets => "IgnoreNotSavedSecrets",
                Self::DiffResultWithDefault => "DiffResultWithDefault",
                Self::DiffResultNoDefault => "DiffResultNoDefault",
                Self::IgnoreTimestamp => "IgnoreTimestamp",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for SettingCompareFlags {
    type GlibType = ffi::NMSettingCompareFlags;

    fn into_glib(self) -> ffi::NMSettingCompareFlags {
        match self {
            Self::Exact => ffi::NM_SETTING_COMPARE_FLAG_EXACT,
            Self::Fuzzy => ffi::NM_SETTING_COMPARE_FLAG_FUZZY,
            Self::IgnoreId => ffi::NM_SETTING_COMPARE_FLAG_IGNORE_ID,
            Self::IgnoreSecrets => ffi::NM_SETTING_COMPARE_FLAG_IGNORE_SECRETS,
            Self::IgnoreAgentOwnedSecrets => {
                ffi::NM_SETTING_COMPARE_FLAG_IGNORE_AGENT_OWNED_SECRETS
            }
            Self::IgnoreNotSavedSecrets => ffi::NM_SETTING_COMPARE_FLAG_IGNORE_NOT_SAVED_SECRETS,
            Self::DiffResultWithDefault => ffi::NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT,
            Self::DiffResultNoDefault => ffi::NM_SETTING_COMPARE_FLAG_DIFF_RESULT_NO_DEFAULT,
            Self::IgnoreTimestamp => ffi::NM_SETTING_COMPARE_FLAG_IGNORE_TIMESTAMP,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingCompareFlags> for SettingCompareFlags {
    unsafe fn from_glib(value: ffi::NMSettingCompareFlags) -> Self {
        match value {
            ffi::NM_SETTING_COMPARE_FLAG_EXACT => Self::Exact,
            ffi::NM_SETTING_COMPARE_FLAG_FUZZY => Self::Fuzzy,
            ffi::NM_SETTING_COMPARE_FLAG_IGNORE_ID => Self::IgnoreId,
            ffi::NM_SETTING_COMPARE_FLAG_IGNORE_SECRETS => Self::IgnoreSecrets,
            ffi::NM_SETTING_COMPARE_FLAG_IGNORE_AGENT_OWNED_SECRETS => {
                Self::IgnoreAgentOwnedSecrets
            }
            ffi::NM_SETTING_COMPARE_FLAG_IGNORE_NOT_SAVED_SECRETS => Self::IgnoreNotSavedSecrets,
            ffi::NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT => Self::DiffResultWithDefault,
            ffi::NM_SETTING_COMPARE_FLAG_DIFF_RESULT_NO_DEFAULT => Self::DiffResultNoDefault,
            ffi::NM_SETTING_COMPARE_FLAG_IGNORE_TIMESTAMP => Self::IgnoreTimestamp,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SettingCompareFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_compare_flags_get_type()) }
    }
}

impl glib::value::ValueType for SettingCompareFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SettingCompareFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SettingCompareFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// [`SettingConnectionAutoconnectSlaves`][crate::SettingConnectionAutoconnectSlaves] values indicate whether slave connections
/// should be activated when master is activated.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingConnectionAutoconnectSlaves")]
pub enum SettingConnectionAutoconnectSlaves {
    /// default value
    #[doc(alias = "NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_DEFAULT")]
    Default,
    /// slaves are not brought up when
    ///  master is activated
    #[doc(alias = "NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_NO")]
    No,
    /// slaves are brought up when
    ///  master is activated
    #[doc(alias = "NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_YES")]
    Yes,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SettingConnectionAutoconnectSlaves {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingConnectionAutoconnectSlaves::{}",
            match *self {
                Self::Default => "Default",
                Self::No => "No",
                Self::Yes => "Yes",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for SettingConnectionAutoconnectSlaves {
    type GlibType = ffi::NMSettingConnectionAutoconnectSlaves;

    fn into_glib(self) -> ffi::NMSettingConnectionAutoconnectSlaves {
        match self {
            Self::Default => ffi::NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_DEFAULT,
            Self::No => ffi::NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_NO,
            Self::Yes => ffi::NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_YES,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingConnectionAutoconnectSlaves> for SettingConnectionAutoconnectSlaves {
    unsafe fn from_glib(value: ffi::NMSettingConnectionAutoconnectSlaves) -> Self {
        match value {
            ffi::NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_DEFAULT => Self::Default,
            ffi::NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_NO => Self::No,
            ffi::NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_YES => Self::Yes,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SettingConnectionAutoconnectSlaves {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_connection_autoconnect_slaves_get_type()) }
    }
}

impl glib::value::ValueType for SettingConnectionAutoconnectSlaves {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SettingConnectionAutoconnectSlaves {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SettingConnectionAutoconnectSlaves {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// [`SettingConnectionDnsOverTls`][crate::SettingConnectionDnsOverTls] values indicate whether DNSOverTls should be enabled.
#[cfg(any(feature = "v1_34", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_34")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingConnectionDnsOverTls")]
pub enum SettingConnectionDnsOverTls {
    /// default value
    #[doc(alias = "NM_SETTING_CONNECTION_DNS_OVER_TLS_DEFAULT")]
    Default,
    /// disable DNSOverTls
    #[doc(alias = "NM_SETTING_CONNECTION_DNS_OVER_TLS_NO")]
    No,
    /// enable opportunistic mode
    #[doc(alias = "NM_SETTING_CONNECTION_DNS_OVER_TLS_OPPORTUNISTIC")]
    Opportunistic,
    /// enable strict mode
    #[doc(alias = "NM_SETTING_CONNECTION_DNS_OVER_TLS_YES")]
    Yes,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_34", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_34")))]
impl fmt::Display for SettingConnectionDnsOverTls {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingConnectionDnsOverTls::{}",
            match *self {
                Self::Default => "Default",
                Self::No => "No",
                Self::Opportunistic => "Opportunistic",
                Self::Yes => "Yes",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_34", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_34")))]
#[doc(hidden)]
impl IntoGlib for SettingConnectionDnsOverTls {
    type GlibType = ffi::NMSettingConnectionDnsOverTls;

    fn into_glib(self) -> ffi::NMSettingConnectionDnsOverTls {
        match self {
            Self::Default => ffi::NM_SETTING_CONNECTION_DNS_OVER_TLS_DEFAULT,
            Self::No => ffi::NM_SETTING_CONNECTION_DNS_OVER_TLS_NO,
            Self::Opportunistic => ffi::NM_SETTING_CONNECTION_DNS_OVER_TLS_OPPORTUNISTIC,
            Self::Yes => ffi::NM_SETTING_CONNECTION_DNS_OVER_TLS_YES,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_34", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_34")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingConnectionDnsOverTls> for SettingConnectionDnsOverTls {
    unsafe fn from_glib(value: ffi::NMSettingConnectionDnsOverTls) -> Self {
        match value {
            ffi::NM_SETTING_CONNECTION_DNS_OVER_TLS_DEFAULT => Self::Default,
            ffi::NM_SETTING_CONNECTION_DNS_OVER_TLS_NO => Self::No,
            ffi::NM_SETTING_CONNECTION_DNS_OVER_TLS_OPPORTUNISTIC => Self::Opportunistic,
            ffi::NM_SETTING_CONNECTION_DNS_OVER_TLS_YES => Self::Yes,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_34", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_34")))]
impl StaticType for SettingConnectionDnsOverTls {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_connection_dns_over_tls_get_type()) }
    }
}

#[cfg(any(feature = "v1_34", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_34")))]
impl glib::value::ValueType for SettingConnectionDnsOverTls {
    type Type = Self;
}

#[cfg(any(feature = "v1_34", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_34")))]
unsafe impl<'a> FromValue<'a> for SettingConnectionDnsOverTls {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_34", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_34")))]
impl ToValue for SettingConnectionDnsOverTls {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// [`SettingConnectionLldp`][crate::SettingConnectionLldp] values indicate whether LLDP should be enabled.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingConnectionLldp")]
pub enum SettingConnectionLldp {
    /// default value
    #[doc(alias = "NM_SETTING_CONNECTION_LLDP_DEFAULT")]
    Default,
    /// disable LLDP
    #[doc(alias = "NM_SETTING_CONNECTION_LLDP_DISABLE")]
    Disable,
    /// enable reception of LLDP frames
    #[doc(alias = "NM_SETTING_CONNECTION_LLDP_ENABLE_RX")]
    EnableRx,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SettingConnectionLldp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingConnectionLldp::{}",
            match *self {
                Self::Default => "Default",
                Self::Disable => "Disable",
                Self::EnableRx => "EnableRx",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for SettingConnectionLldp {
    type GlibType = ffi::NMSettingConnectionLldp;

    fn into_glib(self) -> ffi::NMSettingConnectionLldp {
        match self {
            Self::Default => ffi::NM_SETTING_CONNECTION_LLDP_DEFAULT,
            Self::Disable => ffi::NM_SETTING_CONNECTION_LLDP_DISABLE,
            Self::EnableRx => ffi::NM_SETTING_CONNECTION_LLDP_ENABLE_RX,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingConnectionLldp> for SettingConnectionLldp {
    unsafe fn from_glib(value: ffi::NMSettingConnectionLldp) -> Self {
        match value {
            ffi::NM_SETTING_CONNECTION_LLDP_DEFAULT => Self::Default,
            ffi::NM_SETTING_CONNECTION_LLDP_DISABLE => Self::Disable,
            ffi::NM_SETTING_CONNECTION_LLDP_ENABLE_RX => Self::EnableRx,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SettingConnectionLldp {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_connection_lldp_get_type()) }
    }
}

impl glib::value::ValueType for SettingConnectionLldp {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SettingConnectionLldp {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SettingConnectionLldp {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// [`SettingConnectionLlmnr`][crate::SettingConnectionLlmnr] values indicate whether LLMNR should be enabled.
#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingConnectionLlmnr")]
pub enum SettingConnectionLlmnr {
    /// default value
    #[doc(alias = "NM_SETTING_CONNECTION_LLMNR_DEFAULT")]
    Default,
    /// disable LLMNR
    #[doc(alias = "NM_SETTING_CONNECTION_LLMNR_NO")]
    No,
    /// support only resolving, do not register hostname
    #[doc(alias = "NM_SETTING_CONNECTION_LLMNR_RESOLVE")]
    Resolve,
    /// enable LLMNR
    #[doc(alias = "NM_SETTING_CONNECTION_LLMNR_YES")]
    Yes,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
impl fmt::Display for SettingConnectionLlmnr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingConnectionLlmnr::{}",
            match *self {
                Self::Default => "Default",
                Self::No => "No",
                Self::Resolve => "Resolve",
                Self::Yes => "Yes",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
#[doc(hidden)]
impl IntoGlib for SettingConnectionLlmnr {
    type GlibType = ffi::NMSettingConnectionLlmnr;

    fn into_glib(self) -> ffi::NMSettingConnectionLlmnr {
        match self {
            Self::Default => ffi::NM_SETTING_CONNECTION_LLMNR_DEFAULT,
            Self::No => ffi::NM_SETTING_CONNECTION_LLMNR_NO,
            Self::Resolve => ffi::NM_SETTING_CONNECTION_LLMNR_RESOLVE,
            Self::Yes => ffi::NM_SETTING_CONNECTION_LLMNR_YES,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingConnectionLlmnr> for SettingConnectionLlmnr {
    unsafe fn from_glib(value: ffi::NMSettingConnectionLlmnr) -> Self {
        match value {
            ffi::NM_SETTING_CONNECTION_LLMNR_DEFAULT => Self::Default,
            ffi::NM_SETTING_CONNECTION_LLMNR_NO => Self::No,
            ffi::NM_SETTING_CONNECTION_LLMNR_RESOLVE => Self::Resolve,
            ffi::NM_SETTING_CONNECTION_LLMNR_YES => Self::Yes,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
impl StaticType for SettingConnectionLlmnr {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_connection_llmnr_get_type()) }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
impl glib::value::ValueType for SettingConnectionLlmnr {
    type Type = Self;
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
unsafe impl<'a> FromValue<'a> for SettingConnectionLlmnr {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
impl ToValue for SettingConnectionLlmnr {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// [`SettingConnectionMdns`][crate::SettingConnectionMdns] values indicate whether mDNS should be enabled.
#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingConnectionMdns")]
pub enum SettingConnectionMdns {
    /// default value
    #[doc(alias = "NM_SETTING_CONNECTION_MDNS_DEFAULT")]
    Default,
    /// disable mDNS
    #[doc(alias = "NM_SETTING_CONNECTION_MDNS_NO")]
    No,
    /// support only resolving, do not register hostname
    #[doc(alias = "NM_SETTING_CONNECTION_MDNS_RESOLVE")]
    Resolve,
    /// enable mDNS
    #[doc(alias = "NM_SETTING_CONNECTION_MDNS_YES")]
    Yes,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
impl fmt::Display for SettingConnectionMdns {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingConnectionMdns::{}",
            match *self {
                Self::Default => "Default",
                Self::No => "No",
                Self::Resolve => "Resolve",
                Self::Yes => "Yes",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl IntoGlib for SettingConnectionMdns {
    type GlibType = ffi::NMSettingConnectionMdns;

    fn into_glib(self) -> ffi::NMSettingConnectionMdns {
        match self {
            Self::Default => ffi::NM_SETTING_CONNECTION_MDNS_DEFAULT,
            Self::No => ffi::NM_SETTING_CONNECTION_MDNS_NO,
            Self::Resolve => ffi::NM_SETTING_CONNECTION_MDNS_RESOLVE,
            Self::Yes => ffi::NM_SETTING_CONNECTION_MDNS_YES,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingConnectionMdns> for SettingConnectionMdns {
    unsafe fn from_glib(value: ffi::NMSettingConnectionMdns) -> Self {
        match value {
            ffi::NM_SETTING_CONNECTION_MDNS_DEFAULT => Self::Default,
            ffi::NM_SETTING_CONNECTION_MDNS_NO => Self::No,
            ffi::NM_SETTING_CONNECTION_MDNS_RESOLVE => Self::Resolve,
            ffi::NM_SETTING_CONNECTION_MDNS_YES => Self::Yes,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
impl StaticType for SettingConnectionMdns {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_connection_mdns_get_type()) }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
impl glib::value::ValueType for SettingConnectionMdns {
    type Type = Self;
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
unsafe impl<'a> FromValue<'a> for SettingConnectionMdns {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
impl ToValue for SettingConnectionMdns {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// These values indicate the result of a setting difference operation.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingDiffResult")]
pub enum SettingDiffResult {
    /// unknown result
    #[doc(alias = "NM_SETTING_DIFF_RESULT_UNKNOWN")]
    Unknown,
    /// the property is present in setting A
    #[doc(alias = "NM_SETTING_DIFF_RESULT_IN_A")]
    InA,
    /// the property is present in setting B
    #[doc(alias = "NM_SETTING_DIFF_RESULT_IN_B")]
    InB,
    /// the property is present in
    /// setting A but is set to the default value. This flag is only set,
    /// if you specify [`SettingCompareFlags::DiffResultWithDefault`][crate::SettingCompareFlags::DiffResultWithDefault].
    #[doc(alias = "NM_SETTING_DIFF_RESULT_IN_A_DEFAULT")]
    InADefault,
    /// analog to [`InADefault`][Self::InADefault].
    #[doc(alias = "NM_SETTING_DIFF_RESULT_IN_B_DEFAULT")]
    InBDefault,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SettingDiffResult {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingDiffResult::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::InA => "InA",
                Self::InB => "InB",
                Self::InADefault => "InADefault",
                Self::InBDefault => "InBDefault",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for SettingDiffResult {
    type GlibType = ffi::NMSettingDiffResult;

    fn into_glib(self) -> ffi::NMSettingDiffResult {
        match self {
            Self::Unknown => ffi::NM_SETTING_DIFF_RESULT_UNKNOWN,
            Self::InA => ffi::NM_SETTING_DIFF_RESULT_IN_A,
            Self::InB => ffi::NM_SETTING_DIFF_RESULT_IN_B,
            Self::InADefault => ffi::NM_SETTING_DIFF_RESULT_IN_A_DEFAULT,
            Self::InBDefault => ffi::NM_SETTING_DIFF_RESULT_IN_B_DEFAULT,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingDiffResult> for SettingDiffResult {
    unsafe fn from_glib(value: ffi::NMSettingDiffResult) -> Self {
        match value {
            ffi::NM_SETTING_DIFF_RESULT_UNKNOWN => Self::Unknown,
            ffi::NM_SETTING_DIFF_RESULT_IN_A => Self::InA,
            ffi::NM_SETTING_DIFF_RESULT_IN_B => Self::InB,
            ffi::NM_SETTING_DIFF_RESULT_IN_A_DEFAULT => Self::InADefault,
            ffi::NM_SETTING_DIFF_RESULT_IN_B_DEFAULT => Self::InBDefault,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SettingDiffResult {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_diff_result_get_type()) }
    }
}

impl glib::value::ValueType for SettingDiffResult {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SettingDiffResult {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SettingDiffResult {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// [`SettingIP6ConfigAddrGenMode`][crate::SettingIP6ConfigAddrGenMode] controls how the Interface Identifier for
/// RFC4862 Stateless Address Autoconfiguration is created.
#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingIP6ConfigAddrGenMode")]
pub enum SettingIP6ConfigAddrGenMode {
    /// The Interface Identifier is derived
    /// from the interface hardware address.
    #[doc(alias = "NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64")]
    Eui64,
    /// The Interface Identifier
    /// is created by using a cryptographically secure hash of a secret host-specific
    /// key along with the connection identification and the network address as
    /// specified by RFC7217.
    #[doc(alias = "NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY")]
    StablePrivacy,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
impl fmt::Display for SettingIP6ConfigAddrGenMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingIP6ConfigAddrGenMode::{}",
            match *self {
                Self::Eui64 => "Eui64",
                Self::StablePrivacy => "StablePrivacy",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl IntoGlib for SettingIP6ConfigAddrGenMode {
    type GlibType = ffi::NMSettingIP6ConfigAddrGenMode;

    fn into_glib(self) -> ffi::NMSettingIP6ConfigAddrGenMode {
        match self {
            Self::Eui64 => ffi::NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64,
            Self::StablePrivacy => ffi::NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingIP6ConfigAddrGenMode> for SettingIP6ConfigAddrGenMode {
    unsafe fn from_glib(value: ffi::NMSettingIP6ConfigAddrGenMode) -> Self {
        match value {
            ffi::NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64 => Self::Eui64,
            ffi::NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY => Self::StablePrivacy,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
impl StaticType for SettingIP6ConfigAddrGenMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_ip6_config_addr_gen_mode_get_type()) }
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
impl glib::value::ValueType for SettingIP6ConfigAddrGenMode {
    type Type = Self;
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
unsafe impl<'a> FromValue<'a> for SettingIP6ConfigAddrGenMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_2")))]
impl ToValue for SettingIP6ConfigAddrGenMode {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// [`SettingIP6ConfigPrivacy`][crate::SettingIP6ConfigPrivacy] values indicate if and how IPv6 Privacy
/// Extensions are used (RFC4941).
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingIP6ConfigPrivacy")]
pub enum SettingIP6ConfigPrivacy {
    /// unknown or no value specified
    #[doc(alias = "NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN")]
    Unknown,
    /// IPv6 Privacy Extensions are disabled
    #[doc(alias = "NM_SETTING_IP6_CONFIG_PRIVACY_DISABLED")]
    Disabled,
    /// IPv6 Privacy Extensions
    /// are enabled, but public addresses are preferred over temporary addresses
    #[doc(alias = "NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR")]
    PreferPublicAddr,
    /// IPv6 Privacy Extensions
    /// are enabled and temporary addresses are preferred over public addresses
    #[doc(alias = "NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR")]
    PreferTempAddr,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SettingIP6ConfigPrivacy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingIP6ConfigPrivacy::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::Disabled => "Disabled",
                Self::PreferPublicAddr => "PreferPublicAddr",
                Self::PreferTempAddr => "PreferTempAddr",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for SettingIP6ConfigPrivacy {
    type GlibType = ffi::NMSettingIP6ConfigPrivacy;

    fn into_glib(self) -> ffi::NMSettingIP6ConfigPrivacy {
        match self {
            Self::Unknown => ffi::NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN,
            Self::Disabled => ffi::NM_SETTING_IP6_CONFIG_PRIVACY_DISABLED,
            Self::PreferPublicAddr => ffi::NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR,
            Self::PreferTempAddr => ffi::NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingIP6ConfigPrivacy> for SettingIP6ConfigPrivacy {
    unsafe fn from_glib(value: ffi::NMSettingIP6ConfigPrivacy) -> Self {
        match value {
            ffi::NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN => Self::Unknown,
            ffi::NM_SETTING_IP6_CONFIG_PRIVACY_DISABLED => Self::Disabled,
            ffi::NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR => Self::PreferPublicAddr,
            ffi::NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR => Self::PreferTempAddr,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SettingIP6ConfigPrivacy {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_ip6_config_privacy_get_type()) }
    }
}

impl glib::value::ValueType for SettingIP6ConfigPrivacy {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SettingIP6ConfigPrivacy {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SettingIP6ConfigPrivacy {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// Controls if and how the MAC address of a device is randomzied.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingMacRandomization")]
pub enum SettingMacRandomization {
    /// the default value, which unless
    /// overridden by user-controlled defaults configuration, is "never".
    #[doc(alias = "NM_SETTING_MAC_RANDOMIZATION_DEFAULT")]
    Default,
    /// the device's MAC address is always used.
    #[doc(alias = "NM_SETTING_MAC_RANDOMIZATION_NEVER")]
    Never,
    /// a random MAC address is used.
    #[doc(alias = "NM_SETTING_MAC_RANDOMIZATION_ALWAYS")]
    Always,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SettingMacRandomization {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingMacRandomization::{}",
            match *self {
                Self::Default => "Default",
                Self::Never => "Never",
                Self::Always => "Always",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for SettingMacRandomization {
    type GlibType = ffi::NMSettingMacRandomization;

    fn into_glib(self) -> ffi::NMSettingMacRandomization {
        match self {
            Self::Default => ffi::NM_SETTING_MAC_RANDOMIZATION_DEFAULT,
            Self::Never => ffi::NM_SETTING_MAC_RANDOMIZATION_NEVER,
            Self::Always => ffi::NM_SETTING_MAC_RANDOMIZATION_ALWAYS,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingMacRandomization> for SettingMacRandomization {
    unsafe fn from_glib(value: ffi::NMSettingMacRandomization) -> Self {
        match value {
            ffi::NM_SETTING_MAC_RANDOMIZATION_DEFAULT => Self::Default,
            ffi::NM_SETTING_MAC_RANDOMIZATION_NEVER => Self::Never,
            ffi::NM_SETTING_MAC_RANDOMIZATION_ALWAYS => Self::Always,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SettingMacRandomization {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_mac_randomization_get_type()) }
    }
}

impl glib::value::ValueType for SettingMacRandomization {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SettingMacRandomization {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SettingMacRandomization {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// [`SettingMacsecMode`][crate::SettingMacsecMode] controls how the CAK (Connectivity Association Key) used
/// in MKA (MACsec Key Agreement) is obtained.
#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingMacsecMode")]
pub enum SettingMacsecMode {
    /// The CAK is pre-shared
    #[doc(alias = "NM_SETTING_MACSEC_MODE_PSK")]
    Psk,
    /// The CAK is the result of participation in EAP
    #[doc(alias = "NM_SETTING_MACSEC_MODE_EAP")]
    Eap,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
impl fmt::Display for SettingMacsecMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingMacsecMode::{}",
            match *self {
                Self::Psk => "Psk",
                Self::Eap => "Eap",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
#[doc(hidden)]
impl IntoGlib for SettingMacsecMode {
    type GlibType = ffi::NMSettingMacsecMode;

    fn into_glib(self) -> ffi::NMSettingMacsecMode {
        match self {
            Self::Psk => ffi::NM_SETTING_MACSEC_MODE_PSK,
            Self::Eap => ffi::NM_SETTING_MACSEC_MODE_EAP,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingMacsecMode> for SettingMacsecMode {
    unsafe fn from_glib(value: ffi::NMSettingMacsecMode) -> Self {
        match value {
            ffi::NM_SETTING_MACSEC_MODE_PSK => Self::Psk,
            ffi::NM_SETTING_MACSEC_MODE_EAP => Self::Eap,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
impl StaticType for SettingMacsecMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_macsec_mode_get_type()) }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
impl glib::value::ValueType for SettingMacsecMode {
    type Type = Self;
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
unsafe impl<'a> FromValue<'a> for SettingMacsecMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
impl ToValue for SettingMacsecMode {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// [`SettingMacsecValidation`][crate::SettingMacsecValidation] specifies a validation mode for incoming frames.
#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingMacsecValidation")]
pub enum SettingMacsecValidation {
    /// All incoming frames are accepted if
    ///  possible
    #[doc(alias = "NM_SETTING_MACSEC_VALIDATION_DISABLE")]
    Disable,
    /// Non protected, invalid, or impossible to
    ///  verify frames are accepted and counted as "invalid"
    #[doc(alias = "NM_SETTING_MACSEC_VALIDATION_CHECK")]
    Check,
    /// Non protected, invalid, or impossible to
    ///  verify frames are dropped
    #[doc(alias = "NM_SETTING_MACSEC_VALIDATION_STRICT")]
    Strict,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
impl fmt::Display for SettingMacsecValidation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingMacsecValidation::{}",
            match *self {
                Self::Disable => "Disable",
                Self::Check => "Check",
                Self::Strict => "Strict",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
#[doc(hidden)]
impl IntoGlib for SettingMacsecValidation {
    type GlibType = ffi::NMSettingMacsecValidation;

    fn into_glib(self) -> ffi::NMSettingMacsecValidation {
        match self {
            Self::Disable => ffi::NM_SETTING_MACSEC_VALIDATION_DISABLE,
            Self::Check => ffi::NM_SETTING_MACSEC_VALIDATION_CHECK,
            Self::Strict => ffi::NM_SETTING_MACSEC_VALIDATION_STRICT,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingMacsecValidation> for SettingMacsecValidation {
    unsafe fn from_glib(value: ffi::NMSettingMacsecValidation) -> Self {
        match value {
            ffi::NM_SETTING_MACSEC_VALIDATION_DISABLE => Self::Disable,
            ffi::NM_SETTING_MACSEC_VALIDATION_CHECK => Self::Check,
            ffi::NM_SETTING_MACSEC_VALIDATION_STRICT => Self::Strict,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
impl StaticType for SettingMacsecValidation {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_macsec_validation_get_type()) }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
impl glib::value::ValueType for SettingMacsecValidation {
    type Type = Self;
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
unsafe impl<'a> FromValue<'a> for SettingMacsecValidation {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
impl ToValue for SettingMacsecValidation {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingMacvlanMode")]
pub enum SettingMacvlanMode {
    /// unknown/unset mode
    #[doc(alias = "NM_SETTING_MACVLAN_MODE_UNKNOWN")]
    Unknown,
    /// Virtual Ethernet Port Aggregator mode
    #[doc(alias = "NM_SETTING_MACVLAN_MODE_VEPA")]
    Vepa,
    /// bridge mode
    #[doc(alias = "NM_SETTING_MACVLAN_MODE_BRIDGE")]
    Bridge,
    /// private mode
    #[doc(alias = "NM_SETTING_MACVLAN_MODE_PRIVATE")]
    Private,
    /// passthru mode
    #[doc(alias = "NM_SETTING_MACVLAN_MODE_PASSTHRU")]
    Passthru,
    /// source mode
    #[doc(alias = "NM_SETTING_MACVLAN_MODE_SOURCE")]
    Source,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SettingMacvlanMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingMacvlanMode::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::Vepa => "Vepa",
                Self::Bridge => "Bridge",
                Self::Private => "Private",
                Self::Passthru => "Passthru",
                Self::Source => "Source",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for SettingMacvlanMode {
    type GlibType = ffi::NMSettingMacvlanMode;

    fn into_glib(self) -> ffi::NMSettingMacvlanMode {
        match self {
            Self::Unknown => ffi::NM_SETTING_MACVLAN_MODE_UNKNOWN,
            Self::Vepa => ffi::NM_SETTING_MACVLAN_MODE_VEPA,
            Self::Bridge => ffi::NM_SETTING_MACVLAN_MODE_BRIDGE,
            Self::Private => ffi::NM_SETTING_MACVLAN_MODE_PRIVATE,
            Self::Passthru => ffi::NM_SETTING_MACVLAN_MODE_PASSTHRU,
            Self::Source => ffi::NM_SETTING_MACVLAN_MODE_SOURCE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingMacvlanMode> for SettingMacvlanMode {
    unsafe fn from_glib(value: ffi::NMSettingMacvlanMode) -> Self {
        match value {
            ffi::NM_SETTING_MACVLAN_MODE_UNKNOWN => Self::Unknown,
            ffi::NM_SETTING_MACVLAN_MODE_VEPA => Self::Vepa,
            ffi::NM_SETTING_MACVLAN_MODE_BRIDGE => Self::Bridge,
            ffi::NM_SETTING_MACVLAN_MODE_PRIVATE => Self::Private,
            ffi::NM_SETTING_MACVLAN_MODE_PASSTHRU => Self::Passthru,
            ffi::NM_SETTING_MACVLAN_MODE_SOURCE => Self::Source,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SettingMacvlanMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_macvlan_mode_get_type()) }
    }
}

impl glib::value::ValueType for SettingMacvlanMode {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SettingMacvlanMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SettingMacvlanMode {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// The Proxy method.
#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingProxyMethod")]
pub enum SettingProxyMethod {
    /// No Proxy for the Connection
    #[doc(alias = "NM_SETTING_PROXY_METHOD_NONE")]
    None,
    /// DHCP obtained Proxy/ Manual override
    #[doc(alias = "NM_SETTING_PROXY_METHOD_AUTO")]
    Auto,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
impl fmt::Display for SettingProxyMethod {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingProxyMethod::{}",
            match *self {
                Self::None => "None",
                Self::Auto => "Auto",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
#[doc(hidden)]
impl IntoGlib for SettingProxyMethod {
    type GlibType = ffi::NMSettingProxyMethod;

    fn into_glib(self) -> ffi::NMSettingProxyMethod {
        match self {
            Self::None => ffi::NM_SETTING_PROXY_METHOD_NONE,
            Self::Auto => ffi::NM_SETTING_PROXY_METHOD_AUTO,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingProxyMethod> for SettingProxyMethod {
    unsafe fn from_glib(value: ffi::NMSettingProxyMethod) -> Self {
        match value {
            ffi::NM_SETTING_PROXY_METHOD_NONE => Self::None,
            ffi::NM_SETTING_PROXY_METHOD_AUTO => Self::Auto,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
impl StaticType for SettingProxyMethod {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_proxy_method_get_type()) }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
impl glib::value::ValueType for SettingProxyMethod {
    type Type = Self;
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
unsafe impl<'a> FromValue<'a> for SettingProxyMethod {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_6")))]
impl ToValue for SettingProxyMethod {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// The parity setting of a serial port.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingSerialParity")]
pub enum SettingSerialParity {
    /// No parity bits (default)
    #[doc(alias = "NM_SETTING_SERIAL_PARITY_NONE")]
    None,
    /// Even parity
    #[doc(alias = "NM_SETTING_SERIAL_PARITY_EVEN")]
    Even,
    /// Odd parity
    #[doc(alias = "NM_SETTING_SERIAL_PARITY_ODD")]
    Odd,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SettingSerialParity {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingSerialParity::{}",
            match *self {
                Self::None => "None",
                Self::Even => "Even",
                Self::Odd => "Odd",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for SettingSerialParity {
    type GlibType = ffi::NMSettingSerialParity;

    fn into_glib(self) -> ffi::NMSettingSerialParity {
        match self {
            Self::None => ffi::NM_SETTING_SERIAL_PARITY_NONE,
            Self::Even => ffi::NM_SETTING_SERIAL_PARITY_EVEN,
            Self::Odd => ffi::NM_SETTING_SERIAL_PARITY_ODD,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingSerialParity> for SettingSerialParity {
    unsafe fn from_glib(value: ffi::NMSettingSerialParity) -> Self {
        match value {
            ffi::NM_SETTING_SERIAL_PARITY_NONE => Self::None,
            ffi::NM_SETTING_SERIAL_PARITY_EVEN => Self::Even,
            ffi::NM_SETTING_SERIAL_PARITY_ODD => Self::Odd,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SettingSerialParity {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_serial_parity_get_type()) }
    }
}

impl glib::value::ValueType for SettingSerialParity {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SettingSerialParity {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SettingSerialParity {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// [`SettingTunMode`][crate::SettingTunMode] values indicate the device type (TUN/TAP)
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingTunMode")]
pub enum SettingTunMode {
    /// an unknown device type
    #[doc(alias = "NM_SETTING_TUN_MODE_UNKNOWN")]
    Unknown,
    /// a TUN device
    #[doc(alias = "NM_SETTING_TUN_MODE_TUN")]
    Tun,
    /// a TAP device
    #[doc(alias = "NM_SETTING_TUN_MODE_TAP")]
    Tap,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SettingTunMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingTunMode::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::Tun => "Tun",
                Self::Tap => "Tap",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for SettingTunMode {
    type GlibType = ffi::NMSettingTunMode;

    fn into_glib(self) -> ffi::NMSettingTunMode {
        match self {
            Self::Unknown => ffi::NM_SETTING_TUN_MODE_UNKNOWN,
            Self::Tun => ffi::NM_SETTING_TUN_MODE_TUN,
            Self::Tap => ffi::NM_SETTING_TUN_MODE_TAP,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingTunMode> for SettingTunMode {
    unsafe fn from_glib(value: ffi::NMSettingTunMode) -> Self {
        match value {
            ffi::NM_SETTING_TUN_MODE_UNKNOWN => Self::Unknown,
            ffi::NM_SETTING_TUN_MODE_TUN => Self::Tun,
            ffi::NM_SETTING_TUN_MODE_TAP => Self::Tap,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SettingTunMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_tun_mode_get_type()) }
    }
}

impl glib::value::ValueType for SettingTunMode {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SettingTunMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SettingTunMode {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// These flags indicate whether wireless powersave must be enabled.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingWirelessPowersave")]
pub enum SettingWirelessPowersave {
    /// use the default value
    #[doc(alias = "NM_SETTING_WIRELESS_POWERSAVE_DEFAULT")]
    Default,
    /// don't touch existing setting
    #[doc(alias = "NM_SETTING_WIRELESS_POWERSAVE_IGNORE")]
    Ignore,
    /// disable powersave
    #[doc(alias = "NM_SETTING_WIRELESS_POWERSAVE_DISABLE")]
    Disable,
    /// enable powersave
    #[doc(alias = "NM_SETTING_WIRELESS_POWERSAVE_ENABLE")]
    Enable,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SettingWirelessPowersave {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingWirelessPowersave::{}",
            match *self {
                Self::Default => "Default",
                Self::Ignore => "Ignore",
                Self::Disable => "Disable",
                Self::Enable => "Enable",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for SettingWirelessPowersave {
    type GlibType = ffi::NMSettingWirelessPowersave;

    fn into_glib(self) -> ffi::NMSettingWirelessPowersave {
        match self {
            Self::Default => ffi::NM_SETTING_WIRELESS_POWERSAVE_DEFAULT,
            Self::Ignore => ffi::NM_SETTING_WIRELESS_POWERSAVE_IGNORE,
            Self::Disable => ffi::NM_SETTING_WIRELESS_POWERSAVE_DISABLE,
            Self::Enable => ffi::NM_SETTING_WIRELESS_POWERSAVE_ENABLE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingWirelessPowersave> for SettingWirelessPowersave {
    unsafe fn from_glib(value: ffi::NMSettingWirelessPowersave) -> Self {
        match value {
            ffi::NM_SETTING_WIRELESS_POWERSAVE_DEFAULT => Self::Default,
            ffi::NM_SETTING_WIRELESS_POWERSAVE_IGNORE => Self::Ignore,
            ffi::NM_SETTING_WIRELESS_POWERSAVE_DISABLE => Self::Disable,
            ffi::NM_SETTING_WIRELESS_POWERSAVE_ENABLE => Self::Enable,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SettingWirelessPowersave {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_wireless_powersave_get_type()) }
    }
}

impl glib::value::ValueType for SettingWirelessPowersave {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SettingWirelessPowersave {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SettingWirelessPowersave {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// These flags indicate whether FILS must be enabled.
#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingWirelessSecurityFils")]
pub enum SettingWirelessSecurityFils {
    /// use the default value
    #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_FILS_DEFAULT")]
    Default,
    /// disable FILS
    #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_FILS_DISABLE")]
    Disable,
    /// enable FILS if the supplicant and the AP support it
    #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_FILS_OPTIONAL")]
    Optional,
    /// require FILS and fail if not available
    #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_FILS_REQUIRED")]
    Required,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
impl fmt::Display for SettingWirelessSecurityFils {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingWirelessSecurityFils::{}",
            match *self {
                Self::Default => "Default",
                Self::Disable => "Disable",
                Self::Optional => "Optional",
                Self::Required => "Required",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl IntoGlib for SettingWirelessSecurityFils {
    type GlibType = ffi::NMSettingWirelessSecurityFils;

    fn into_glib(self) -> ffi::NMSettingWirelessSecurityFils {
        match self {
            Self::Default => ffi::NM_SETTING_WIRELESS_SECURITY_FILS_DEFAULT,
            Self::Disable => ffi::NM_SETTING_WIRELESS_SECURITY_FILS_DISABLE,
            Self::Optional => ffi::NM_SETTING_WIRELESS_SECURITY_FILS_OPTIONAL,
            Self::Required => ffi::NM_SETTING_WIRELESS_SECURITY_FILS_REQUIRED,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingWirelessSecurityFils> for SettingWirelessSecurityFils {
    unsafe fn from_glib(value: ffi::NMSettingWirelessSecurityFils) -> Self {
        match value {
            ffi::NM_SETTING_WIRELESS_SECURITY_FILS_DEFAULT => Self::Default,
            ffi::NM_SETTING_WIRELESS_SECURITY_FILS_DISABLE => Self::Disable,
            ffi::NM_SETTING_WIRELESS_SECURITY_FILS_OPTIONAL => Self::Optional,
            ffi::NM_SETTING_WIRELESS_SECURITY_FILS_REQUIRED => Self::Required,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
impl StaticType for SettingWirelessSecurityFils {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_wireless_security_fils_get_type()) }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
impl glib::value::ValueType for SettingWirelessSecurityFils {
    type Type = Self;
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
unsafe impl<'a> FromValue<'a> for SettingWirelessSecurityFils {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
impl ToValue for SettingWirelessSecurityFils {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// These flags indicate whether PMF must be enabled.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingWirelessSecurityPmf")]
pub enum SettingWirelessSecurityPmf {
    /// use the default value
    #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_PMF_DEFAULT")]
    Default,
    /// disable PMF
    #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_PMF_DISABLE")]
    Disable,
    /// enable PMF if the supplicant and the AP support it
    #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_PMF_OPTIONAL")]
    Optional,
    /// require PMF and fail if not available
    #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_PMF_REQUIRED")]
    Required,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SettingWirelessSecurityPmf {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingWirelessSecurityPmf::{}",
            match *self {
                Self::Default => "Default",
                Self::Disable => "Disable",
                Self::Optional => "Optional",
                Self::Required => "Required",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for SettingWirelessSecurityPmf {
    type GlibType = ffi::NMSettingWirelessSecurityPmf;

    fn into_glib(self) -> ffi::NMSettingWirelessSecurityPmf {
        match self {
            Self::Default => ffi::NM_SETTING_WIRELESS_SECURITY_PMF_DEFAULT,
            Self::Disable => ffi::NM_SETTING_WIRELESS_SECURITY_PMF_DISABLE,
            Self::Optional => ffi::NM_SETTING_WIRELESS_SECURITY_PMF_OPTIONAL,
            Self::Required => ffi::NM_SETTING_WIRELESS_SECURITY_PMF_REQUIRED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingWirelessSecurityPmf> for SettingWirelessSecurityPmf {
    unsafe fn from_glib(value: ffi::NMSettingWirelessSecurityPmf) -> Self {
        match value {
            ffi::NM_SETTING_WIRELESS_SECURITY_PMF_DEFAULT => Self::Default,
            ffi::NM_SETTING_WIRELESS_SECURITY_PMF_DISABLE => Self::Disable,
            ffi::NM_SETTING_WIRELESS_SECURITY_PMF_OPTIONAL => Self::Optional,
            ffi::NM_SETTING_WIRELESS_SECURITY_PMF_REQUIRED => Self::Required,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SettingWirelessSecurityPmf {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_wireless_security_pmf_get_type()) }
    }
}

impl glib::value::ValueType for SettingWirelessSecurityPmf {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SettingWirelessSecurityPmf {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SettingWirelessSecurityPmf {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// Errors related to the settings/persistent configuration interface of
/// NetworkManager.
///
/// These may be returned from [`Client`][crate::Client] methods that invoke D-Bus operations on
/// the "org.freedesktop.NetworkManager.Settings" interface, and correspond to
/// D-Bus errors in that namespace.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingsError")]
pub enum SettingsError {
    /// unknown or unclassified error
    #[doc(alias = "NM_SETTINGS_ERROR_FAILED")]
    Failed,
    /// permission denied
    #[doc(alias = "NM_SETTINGS_ERROR_PERMISSION_DENIED")]
    PermissionDenied,
    /// the requested operation is not supported by any
    ///  active settings backend
    #[doc(alias = "NM_SETTINGS_ERROR_NOT_SUPPORTED")]
    NotSupported,
    /// the connection was invalid
    #[doc(alias = "NM_SETTINGS_ERROR_INVALID_CONNECTION")]
    InvalidConnection,
    /// attempted to modify a read-only connection
    #[doc(alias = "NM_SETTINGS_ERROR_READ_ONLY_CONNECTION")]
    ReadOnlyConnection,
    /// a connection with that UUID already exists
    #[doc(alias = "NM_SETTINGS_ERROR_UUID_EXISTS")]
    UuidExists,
    /// attempted to set an invalid hostname
    #[doc(alias = "NM_SETTINGS_ERROR_INVALID_HOSTNAME")]
    InvalidHostname,
    /// invalid arguments
    #[doc(alias = "NM_SETTINGS_ERROR_INVALID_ARGUMENTS")]
    InvalidArguments,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SettingsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingsError::{}",
            match *self {
                Self::Failed => "Failed",
                Self::PermissionDenied => "PermissionDenied",
                Self::NotSupported => "NotSupported",
                Self::InvalidConnection => "InvalidConnection",
                Self::ReadOnlyConnection => "ReadOnlyConnection",
                Self::UuidExists => "UuidExists",
                Self::InvalidHostname => "InvalidHostname",
                Self::InvalidArguments => "InvalidArguments",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for SettingsError {
    type GlibType = ffi::NMSettingsError;

    fn into_glib(self) -> ffi::NMSettingsError {
        match self {
            Self::Failed => ffi::NM_SETTINGS_ERROR_FAILED,
            Self::PermissionDenied => ffi::NM_SETTINGS_ERROR_PERMISSION_DENIED,
            Self::NotSupported => ffi::NM_SETTINGS_ERROR_NOT_SUPPORTED,
            Self::InvalidConnection => ffi::NM_SETTINGS_ERROR_INVALID_CONNECTION,
            Self::ReadOnlyConnection => ffi::NM_SETTINGS_ERROR_READ_ONLY_CONNECTION,
            Self::UuidExists => ffi::NM_SETTINGS_ERROR_UUID_EXISTS,
            Self::InvalidHostname => ffi::NM_SETTINGS_ERROR_INVALID_HOSTNAME,
            Self::InvalidArguments => ffi::NM_SETTINGS_ERROR_INVALID_ARGUMENTS,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingsError> for SettingsError {
    unsafe fn from_glib(value: ffi::NMSettingsError) -> Self {
        match value {
            ffi::NM_SETTINGS_ERROR_FAILED => Self::Failed,
            ffi::NM_SETTINGS_ERROR_PERMISSION_DENIED => Self::PermissionDenied,
            ffi::NM_SETTINGS_ERROR_NOT_SUPPORTED => Self::NotSupported,
            ffi::NM_SETTINGS_ERROR_INVALID_CONNECTION => Self::InvalidConnection,
            ffi::NM_SETTINGS_ERROR_READ_ONLY_CONNECTION => Self::ReadOnlyConnection,
            ffi::NM_SETTINGS_ERROR_UUID_EXISTS => Self::UuidExists,
            ffi::NM_SETTINGS_ERROR_INVALID_HOSTNAME => Self::InvalidHostname,
            ffi::NM_SETTINGS_ERROR_INVALID_ARGUMENTS => Self::InvalidArguments,
            value => Self::__Unknown(value),
        }
    }
}

impl ErrorDomain for SettingsError {
    fn domain() -> Quark {
        unsafe { from_glib(ffi::nm_settings_error_quark()) }
    }

    fn code(self) -> i32 {
        self.into_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            ffi::NM_SETTINGS_ERROR_FAILED => Some(Self::Failed),
            ffi::NM_SETTINGS_ERROR_PERMISSION_DENIED => Some(Self::PermissionDenied),
            ffi::NM_SETTINGS_ERROR_NOT_SUPPORTED => Some(Self::NotSupported),
            ffi::NM_SETTINGS_ERROR_INVALID_CONNECTION => Some(Self::InvalidConnection),
            ffi::NM_SETTINGS_ERROR_READ_ONLY_CONNECTION => Some(Self::ReadOnlyConnection),
            ffi::NM_SETTINGS_ERROR_UUID_EXISTS => Some(Self::UuidExists),
            ffi::NM_SETTINGS_ERROR_INVALID_HOSTNAME => Some(Self::InvalidHostname),
            ffi::NM_SETTINGS_ERROR_INVALID_ARGUMENTS => Some(Self::InvalidArguments),
            _ => Some(Self::Failed),
        }
    }
}

impl StaticType for SettingsError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_settings_error_get_type()) }
    }
}

impl glib::value::ValueType for SettingsError {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SettingsError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SettingsError {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// [`SriovVFVlanProtocol`][crate::SriovVFVlanProtocol] indicates the VLAN protocol to use.
#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSriovVFVlanProtocol")]
pub enum SriovVFVlanProtocol {
    /// use 802.1Q
    #[doc(alias = "NM_SRIOV_VF_VLAN_PROTOCOL_802_1Q")]
    _1q,
    /// use 802.1ad
    #[doc(alias = "NM_SRIOV_VF_VLAN_PROTOCOL_802_1AD")]
    _1ad,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
impl fmt::Display for SriovVFVlanProtocol {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SriovVFVlanProtocol::{}",
            match *self {
                Self::_1q => "_1q",
                Self::_1ad => "_1ad",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
#[doc(hidden)]
impl IntoGlib for SriovVFVlanProtocol {
    type GlibType = ffi::NMSriovVFVlanProtocol;

    fn into_glib(self) -> ffi::NMSriovVFVlanProtocol {
        match self {
            Self::_1q => ffi::NM_SRIOV_VF_VLAN_PROTOCOL_802_1Q,
            Self::_1ad => ffi::NM_SRIOV_VF_VLAN_PROTOCOL_802_1AD,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSriovVFVlanProtocol> for SriovVFVlanProtocol {
    unsafe fn from_glib(value: ffi::NMSriovVFVlanProtocol) -> Self {
        match value {
            ffi::NM_SRIOV_VF_VLAN_PROTOCOL_802_1Q => Self::_1q,
            ffi::NM_SRIOV_VF_VLAN_PROTOCOL_802_1AD => Self::_1ad,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
impl StaticType for SriovVFVlanProtocol {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_sriov_vf_vlan_protocol_get_type()) }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
impl glib::value::ValueType for SriovVFVlanProtocol {
    type Type = Self;
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
unsafe impl<'a> FromValue<'a> for SriovVFVlanProtocol {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
impl ToValue for SriovVFVlanProtocol {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// [`State`][crate::State] values indicate the current overall networking state.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMState")]
pub enum State {
    /// Networking state is unknown. This indicates a daemon error
    ///  that makes it unable to reasonably assess the state. In such event the
    ///  applications are expected to assume Internet connectivity might be present
    ///  and not disable controls that require network access.
    ///  The graphical shells may hide the network accessibility indicator altogether
    ///  since no meaningful status indication can be provided.
    #[doc(alias = "NM_STATE_UNKNOWN")]
    Unknown,
    /// Networking is not enabled, the system is being suspended or
    ///  resumed from suspend.
    #[doc(alias = "NM_STATE_ASLEEP")]
    Asleep,
    /// There is no active network connection.
    ///  The graphical shell should indicate no network connectivity and the
    ///  applications should not attempt to access the network.
    #[doc(alias = "NM_STATE_DISCONNECTED")]
    Disconnected,
    /// Network connections are being cleaned up.
    ///  The applications should tear down their network sessions.
    #[doc(alias = "NM_STATE_DISCONNECTING")]
    Disconnecting,
    /// A network connection is being started
    ///  The graphical shell should indicate the network is being connected while
    ///  the applications should still make no attempts to connect the network.
    #[doc(alias = "NM_STATE_CONNECTING")]
    Connecting,
    /// There is only local IPv4 and/or IPv6 connectivity,
    ///  but no default route to access the Internet. The graphical shell should
    ///  indicate no network connectivity.
    #[doc(alias = "NM_STATE_CONNECTED_LOCAL")]
    ConnectedLocal,
    /// There is only site-wide IPv4 and/or IPv6 connectivity.
    ///  This means a default route is available, but the Internet connectivity check
    ///  (see "Connectivity" property) did not succeed. The graphical shell should
    ///  indicate limited network connectivity.
    #[doc(alias = "NM_STATE_CONNECTED_SITE")]
    ConnectedSite,
    /// There is global IPv4 and/or IPv6 Internet connectivity
    ///  This means the Internet connectivity check succeeded, the graphical shell should
    ///  indicate full network connectivity.
    #[doc(alias = "NM_STATE_CONNECTED_GLOBAL")]
    ConnectedGlobal,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for State {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "State::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::Asleep => "Asleep",
                Self::Disconnected => "Disconnected",
                Self::Disconnecting => "Disconnecting",
                Self::Connecting => "Connecting",
                Self::ConnectedLocal => "ConnectedLocal",
                Self::ConnectedSite => "ConnectedSite",
                Self::ConnectedGlobal => "ConnectedGlobal",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for State {
    type GlibType = ffi::NMState;

    fn into_glib(self) -> ffi::NMState {
        match self {
            Self::Unknown => ffi::NM_STATE_UNKNOWN,
            Self::Asleep => ffi::NM_STATE_ASLEEP,
            Self::Disconnected => ffi::NM_STATE_DISCONNECTED,
            Self::Disconnecting => ffi::NM_STATE_DISCONNECTING,
            Self::Connecting => ffi::NM_STATE_CONNECTING,
            Self::ConnectedLocal => ffi::NM_STATE_CONNECTED_LOCAL,
            Self::ConnectedSite => ffi::NM_STATE_CONNECTED_SITE,
            Self::ConnectedGlobal => ffi::NM_STATE_CONNECTED_GLOBAL,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMState> for State {
    unsafe fn from_glib(value: ffi::NMState) -> Self {
        match value {
            ffi::NM_STATE_UNKNOWN => Self::Unknown,
            ffi::NM_STATE_ASLEEP => Self::Asleep,
            ffi::NM_STATE_DISCONNECTED => Self::Disconnected,
            ffi::NM_STATE_DISCONNECTING => Self::Disconnecting,
            ffi::NM_STATE_CONNECTING => Self::Connecting,
            ffi::NM_STATE_CONNECTED_LOCAL => Self::ConnectedLocal,
            ffi::NM_STATE_CONNECTED_SITE => Self::ConnectedSite,
            ffi::NM_STATE_CONNECTED_GLOBAL => Self::ConnectedGlobal,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for State {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_state_get_type()) }
    }
}

impl glib::value::ValueType for State {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for State {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for State {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// An boolean value that can be overridden by a default.
#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMTernary")]
pub enum Ternary {
    /// use the globally-configured default value.
    #[doc(alias = "NM_TERNARY_DEFAULT")]
    Default,
    /// the option is disabled.
    #[doc(alias = "NM_TERNARY_FALSE")]
    False,
    /// the option is enabled.
    #[doc(alias = "NM_TERNARY_TRUE")]
    True,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
impl fmt::Display for Ternary {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Ternary::{}",
            match *self {
                Self::Default => "Default",
                Self::False => "False",
                Self::True => "True",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
#[doc(hidden)]
impl IntoGlib for Ternary {
    type GlibType = ffi::NMTernary;

    fn into_glib(self) -> ffi::NMTernary {
        match self {
            Self::Default => ffi::NM_TERNARY_DEFAULT,
            Self::False => ffi::NM_TERNARY_FALSE,
            Self::True => ffi::NM_TERNARY_TRUE,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
#[doc(hidden)]
impl FromGlib<ffi::NMTernary> for Ternary {
    unsafe fn from_glib(value: ffi::NMTernary) -> Self {
        match value {
            ffi::NM_TERNARY_DEFAULT => Self::Default,
            ffi::NM_TERNARY_FALSE => Self::False,
            ffi::NM_TERNARY_TRUE => Self::True,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
impl StaticType for Ternary {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_ternary_get_type()) }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
impl glib::value::ValueType for Ternary {
    type Type = Self;
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
unsafe impl<'a> FromValue<'a> for Ternary {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
impl ToValue for Ternary {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// Describes generic security mechanisms that 802.11 access points may offer.
/// Used with [`utils_security_valid()`][crate::utils_security_valid()] for checking whether a given access
/// point is compatible with a network device.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMUtilsSecurityType")]
pub enum UtilsSecurityType {
    /// unknown or invalid security, placeholder and not used
    #[doc(alias = "NMU_SEC_INVALID")]
    Invalid,
    /// unencrypted and open
    #[doc(alias = "NMU_SEC_NONE")]
    None,
    /// static WEP keys are used for encryption
    #[doc(alias = "NMU_SEC_STATIC_WEP")]
    StaticWep,
    /// Cisco LEAP is used for authentication and for generating the
    /// dynamic WEP keys automatically
    #[doc(alias = "NMU_SEC_LEAP")]
    Leap,
    /// standard 802.1x is used for authentication and
    /// generating the dynamic WEP keys automatically
    #[doc(alias = "NMU_SEC_DYNAMIC_WEP")]
    DynamicWep,
    /// WPA1 is used with Pre-Shared Keys (PSK)
    #[doc(alias = "NMU_SEC_WPA_PSK")]
    WpaPsk,
    /// WPA1 is used with 802.1x authentication
    #[doc(alias = "NMU_SEC_WPA_ENTERPRISE")]
    WpaEnterprise,
    /// WPA2/RSN is used with Pre-Shared Keys (PSK)
    #[doc(alias = "NMU_SEC_WPA2_PSK")]
    Wpa2Psk,
    /// WPA2 is used with 802.1x authentication
    #[doc(alias = "NMU_SEC_WPA2_ENTERPRISE")]
    Wpa2Enterprise,
    /// is used with WPA3 Enterprise
    #[doc(alias = "NMU_SEC_SAE")]
    Sae,
    /// is used with Enhanced Open
    #[doc(alias = "NMU_SEC_OWE")]
    Owe,
    /// is used with WPA3 Enterprise Suite-B 192 bit mode. Since: 1.30.
    #[doc(alias = "NMU_SEC_WPA3_SUITE_B_192")]
    Wpa3SuiteB192,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for UtilsSecurityType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "UtilsSecurityType::{}",
            match *self {
                Self::Invalid => "Invalid",
                Self::None => "None",
                Self::StaticWep => "StaticWep",
                Self::Leap => "Leap",
                Self::DynamicWep => "DynamicWep",
                Self::WpaPsk => "WpaPsk",
                Self::WpaEnterprise => "WpaEnterprise",
                Self::Wpa2Psk => "Wpa2Psk",
                Self::Wpa2Enterprise => "Wpa2Enterprise",
                Self::Sae => "Sae",
                Self::Owe => "Owe",
                Self::Wpa3SuiteB192 => "Wpa3SuiteB192",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for UtilsSecurityType {
    type GlibType = ffi::NMUtilsSecurityType;

    fn into_glib(self) -> ffi::NMUtilsSecurityType {
        match self {
            Self::Invalid => ffi::NMU_SEC_INVALID,
            Self::None => ffi::NMU_SEC_NONE,
            Self::StaticWep => ffi::NMU_SEC_STATIC_WEP,
            Self::Leap => ffi::NMU_SEC_LEAP,
            Self::DynamicWep => ffi::NMU_SEC_DYNAMIC_WEP,
            Self::WpaPsk => ffi::NMU_SEC_WPA_PSK,
            Self::WpaEnterprise => ffi::NMU_SEC_WPA_ENTERPRISE,
            Self::Wpa2Psk => ffi::NMU_SEC_WPA2_PSK,
            Self::Wpa2Enterprise => ffi::NMU_SEC_WPA2_ENTERPRISE,
            Self::Sae => ffi::NMU_SEC_SAE,
            Self::Owe => ffi::NMU_SEC_OWE,
            Self::Wpa3SuiteB192 => ffi::NMU_SEC_WPA3_SUITE_B_192,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMUtilsSecurityType> for UtilsSecurityType {
    unsafe fn from_glib(value: ffi::NMUtilsSecurityType) -> Self {
        match value {
            ffi::NMU_SEC_INVALID => Self::Invalid,
            ffi::NMU_SEC_NONE => Self::None,
            ffi::NMU_SEC_STATIC_WEP => Self::StaticWep,
            ffi::NMU_SEC_LEAP => Self::Leap,
            ffi::NMU_SEC_DYNAMIC_WEP => Self::DynamicWep,
            ffi::NMU_SEC_WPA_PSK => Self::WpaPsk,
            ffi::NMU_SEC_WPA_ENTERPRISE => Self::WpaEnterprise,
            ffi::NMU_SEC_WPA2_PSK => Self::Wpa2Psk,
            ffi::NMU_SEC_WPA2_ENTERPRISE => Self::Wpa2Enterprise,
            ffi::NMU_SEC_SAE => Self::Sae,
            ffi::NMU_SEC_OWE => Self::Owe,
            ffi::NMU_SEC_WPA3_SUITE_B_192 => Self::Wpa3SuiteB192,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for UtilsSecurityType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_utils_security_type_get_type()) }
    }
}

impl glib::value::ValueType for UtilsSecurityType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for UtilsSecurityType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for UtilsSecurityType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// A selector for traffic priority maps; these map Linux SKB priorities
/// to 802.1p priorities used in VLANs.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMVlanPriorityMap")]
pub enum VlanPriorityMap {
    /// map for incoming data
    #[doc(alias = "NM_VLAN_INGRESS_MAP")]
    IngressMap,
    /// map for outgoing data
    #[doc(alias = "NM_VLAN_EGRESS_MAP")]
    EgressMap,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for VlanPriorityMap {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "VlanPriorityMap::{}",
            match *self {
                Self::IngressMap => "IngressMap",
                Self::EgressMap => "EgressMap",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for VlanPriorityMap {
    type GlibType = ffi::NMVlanPriorityMap;

    fn into_glib(self) -> ffi::NMVlanPriorityMap {
        match self {
            Self::IngressMap => ffi::NM_VLAN_INGRESS_MAP,
            Self::EgressMap => ffi::NM_VLAN_EGRESS_MAP,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMVlanPriorityMap> for VlanPriorityMap {
    unsafe fn from_glib(value: ffi::NMVlanPriorityMap) -> Self {
        match value {
            ffi::NM_VLAN_INGRESS_MAP => Self::IngressMap,
            ffi::NM_VLAN_EGRESS_MAP => Self::EgressMap,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for VlanPriorityMap {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_vlan_priority_map_get_type()) }
    }
}

impl glib::value::ValueType for VlanPriorityMap {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for VlanPriorityMap {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for VlanPriorityMap {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// VPN connection states
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMVpnConnectionState")]
pub enum VpnConnectionState {
    /// The state of the VPN connection is
    ///  unknown.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_UNKNOWN")]
    Unknown,
    /// The VPN connection is preparing to
    ///  connect.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_PREPARE")]
    Prepare,
    /// The VPN connection needs authorization
    ///  credentials.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_NEED_AUTH")]
    NeedAuth,
    /// The VPN connection is being established.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_CONNECT")]
    Connect,
    /// The VPN connection is getting an IP
    ///  address.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_IP_CONFIG_GET")]
    IpConfigGet,
    /// The VPN connection is active.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_ACTIVATED")]
    Activated,
    /// The VPN connection failed.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_FAILED")]
    Failed,
    /// The VPN connection is disconnected.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_DISCONNECTED")]
    Disconnected,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for VpnConnectionState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "VpnConnectionState::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::Prepare => "Prepare",
                Self::NeedAuth => "NeedAuth",
                Self::Connect => "Connect",
                Self::IpConfigGet => "IpConfigGet",
                Self::Activated => "Activated",
                Self::Failed => "Failed",
                Self::Disconnected => "Disconnected",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for VpnConnectionState {
    type GlibType = ffi::NMVpnConnectionState;

    fn into_glib(self) -> ffi::NMVpnConnectionState {
        match self {
            Self::Unknown => ffi::NM_VPN_CONNECTION_STATE_UNKNOWN,
            Self::Prepare => ffi::NM_VPN_CONNECTION_STATE_PREPARE,
            Self::NeedAuth => ffi::NM_VPN_CONNECTION_STATE_NEED_AUTH,
            Self::Connect => ffi::NM_VPN_CONNECTION_STATE_CONNECT,
            Self::IpConfigGet => ffi::NM_VPN_CONNECTION_STATE_IP_CONFIG_GET,
            Self::Activated => ffi::NM_VPN_CONNECTION_STATE_ACTIVATED,
            Self::Failed => ffi::NM_VPN_CONNECTION_STATE_FAILED,
            Self::Disconnected => ffi::NM_VPN_CONNECTION_STATE_DISCONNECTED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMVpnConnectionState> for VpnConnectionState {
    unsafe fn from_glib(value: ffi::NMVpnConnectionState) -> Self {
        match value {
            ffi::NM_VPN_CONNECTION_STATE_UNKNOWN => Self::Unknown,
            ffi::NM_VPN_CONNECTION_STATE_PREPARE => Self::Prepare,
            ffi::NM_VPN_CONNECTION_STATE_NEED_AUTH => Self::NeedAuth,
            ffi::NM_VPN_CONNECTION_STATE_CONNECT => Self::Connect,
            ffi::NM_VPN_CONNECTION_STATE_IP_CONFIG_GET => Self::IpConfigGet,
            ffi::NM_VPN_CONNECTION_STATE_ACTIVATED => Self::Activated,
            ffi::NM_VPN_CONNECTION_STATE_FAILED => Self::Failed,
            ffi::NM_VPN_CONNECTION_STATE_DISCONNECTED => Self::Disconnected,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for VpnConnectionState {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_vpn_connection_state_get_type()) }
    }
}

impl glib::value::ValueType for VpnConnectionState {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for VpnConnectionState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for VpnConnectionState {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// VPN connection state reasons
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMVpnConnectionStateReason")]
pub enum VpnConnectionStateReason {
    /// The reason for the VPN connection
    ///  state change is unknown.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_REASON_UNKNOWN")]
    Unknown,
    /// No reason was given for the VPN
    ///  connection state change.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_REASON_NONE")]
    None,
    /// The VPN connection changed
    ///  state because the user disconnected it.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_REASON_USER_DISCONNECTED")]
    UserDisconnected,
    /// The VPN connection
    ///  changed state because the device it was using was disconnected.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED")]
    DeviceDisconnected,
    /// The service providing the
    ///  VPN connection was stopped.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_REASON_SERVICE_STOPPED")]
    ServiceStopped,
    /// The IP config of the VPN
    ///  connection was invalid.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_REASON_IP_CONFIG_INVALID")]
    IpConfigInvalid,
    /// The connection attempt to
    ///  the VPN service timed out.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_REASON_CONNECT_TIMEOUT")]
    ConnectTimeout,
    /// A timeout occurred
    ///  while starting the service providing the VPN connection.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT")]
    ServiceStartTimeout,
    /// Starting the service
    ///  starting the service providing the VPN connection failed.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_FAILED")]
    ServiceStartFailed,
    /// Necessary secrets for the VPN
    ///  connection were not provided.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS")]
    NoSecrets,
    /// Authentication to the VPN
    ///  server failed.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_REASON_LOGIN_FAILED")]
    LoginFailed,
    /// The connection was
    ///  deleted from settings.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_REASON_CONNECTION_REMOVED")]
    ConnectionRemoved,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for VpnConnectionStateReason {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "VpnConnectionStateReason::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::None => "None",
                Self::UserDisconnected => "UserDisconnected",
                Self::DeviceDisconnected => "DeviceDisconnected",
                Self::ServiceStopped => "ServiceStopped",
                Self::IpConfigInvalid => "IpConfigInvalid",
                Self::ConnectTimeout => "ConnectTimeout",
                Self::ServiceStartTimeout => "ServiceStartTimeout",
                Self::ServiceStartFailed => "ServiceStartFailed",
                Self::NoSecrets => "NoSecrets",
                Self::LoginFailed => "LoginFailed",
                Self::ConnectionRemoved => "ConnectionRemoved",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for VpnConnectionStateReason {
    type GlibType = ffi::NMVpnConnectionStateReason;

    fn into_glib(self) -> ffi::NMVpnConnectionStateReason {
        match self {
            Self::Unknown => ffi::NM_VPN_CONNECTION_STATE_REASON_UNKNOWN,
            Self::None => ffi::NM_VPN_CONNECTION_STATE_REASON_NONE,
            Self::UserDisconnected => ffi::NM_VPN_CONNECTION_STATE_REASON_USER_DISCONNECTED,
            Self::DeviceDisconnected => ffi::NM_VPN_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED,
            Self::ServiceStopped => ffi::NM_VPN_CONNECTION_STATE_REASON_SERVICE_STOPPED,
            Self::IpConfigInvalid => ffi::NM_VPN_CONNECTION_STATE_REASON_IP_CONFIG_INVALID,
            Self::ConnectTimeout => ffi::NM_VPN_CONNECTION_STATE_REASON_CONNECT_TIMEOUT,
            Self::ServiceStartTimeout => ffi::NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT,
            Self::ServiceStartFailed => ffi::NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_FAILED,
            Self::NoSecrets => ffi::NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS,
            Self::LoginFailed => ffi::NM_VPN_CONNECTION_STATE_REASON_LOGIN_FAILED,
            Self::ConnectionRemoved => ffi::NM_VPN_CONNECTION_STATE_REASON_CONNECTION_REMOVED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMVpnConnectionStateReason> for VpnConnectionStateReason {
    unsafe fn from_glib(value: ffi::NMVpnConnectionStateReason) -> Self {
        match value {
            ffi::NM_VPN_CONNECTION_STATE_REASON_UNKNOWN => Self::Unknown,
            ffi::NM_VPN_CONNECTION_STATE_REASON_NONE => Self::None,
            ffi::NM_VPN_CONNECTION_STATE_REASON_USER_DISCONNECTED => Self::UserDisconnected,
            ffi::NM_VPN_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED => Self::DeviceDisconnected,
            ffi::NM_VPN_CONNECTION_STATE_REASON_SERVICE_STOPPED => Self::ServiceStopped,
            ffi::NM_VPN_CONNECTION_STATE_REASON_IP_CONFIG_INVALID => Self::IpConfigInvalid,
            ffi::NM_VPN_CONNECTION_STATE_REASON_CONNECT_TIMEOUT => Self::ConnectTimeout,
            ffi::NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT => Self::ServiceStartTimeout,
            ffi::NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_FAILED => Self::ServiceStartFailed,
            ffi::NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS => Self::NoSecrets,
            ffi::NM_VPN_CONNECTION_STATE_REASON_LOGIN_FAILED => Self::LoginFailed,
            ffi::NM_VPN_CONNECTION_STATE_REASON_CONNECTION_REMOVED => Self::ConnectionRemoved,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for VpnConnectionStateReason {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_vpn_connection_state_reason_get_type()) }
    }
}

impl glib::value::ValueType for VpnConnectionStateReason {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for VpnConnectionStateReason {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for VpnConnectionStateReason {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// Returned by the VPN service plugin to indicate errors. These codes correspond
/// to errors in the "org.freedesktop.NetworkManager.VPN.Error" namespace.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMVpnPluginError")]
pub enum VpnPluginError {
    /// unknown or unclassified error
    #[doc(alias = "NM_VPN_PLUGIN_ERROR_FAILED")]
    Failed,
    /// the plugin is already starting,
    ///  and another connect request was received
    #[doc(alias = "NM_VPN_PLUGIN_ERROR_STARTING_IN_PROGRESS")]
    StartingInProgress,
    /// the plugin is already connected, and
    ///  another connect request was received
    #[doc(alias = "NM_VPN_PLUGIN_ERROR_ALREADY_STARTED")]
    AlreadyStarted,
    /// the plugin is already stopping,
    ///  and another stop request was received
    #[doc(alias = "NM_VPN_PLUGIN_ERROR_STOPPING_IN_PROGRESS")]
    StoppingInProgress,
    /// the plugin is already stopped, and
    ///  another disconnect request was received
    #[doc(alias = "NM_VPN_PLUGIN_ERROR_ALREADY_STOPPED")]
    AlreadyStopped,
    /// the operation could not be performed in
    ///  this state
    #[doc(alias = "NM_VPN_PLUGIN_ERROR_WRONG_STATE")]
    WrongState,
    /// the operation could not be performed as
    ///  the request contained malformed arguments, or arguments of unexpected type.
    ///  Usually means that one of the VPN setting data items or secrets was not of
    ///  the expected type (ie int, string, bool, etc).
    #[doc(alias = "NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS")]
    BadArguments,
    /// a child process failed to launch
    #[doc(alias = "NM_VPN_PLUGIN_ERROR_LAUNCH_FAILED")]
    LaunchFailed,
    /// the operation could not be performed
    ///  because the connection was invalid. Usually means that the connection's
    ///  VPN setting was missing some required data item or secret.
    #[doc(alias = "NM_VPN_PLUGIN_ERROR_INVALID_CONNECTION")]
    InvalidConnection,
    /// the operation could not be
    ///  performed as the plugin does not support interactive operations, such as
    ///  ConnectInteractive() or NewSecrets()
    #[doc(alias = "NM_VPN_PLUGIN_ERROR_INTERACTIVE_NOT_SUPPORTED")]
    InteractiveNotSupported,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for VpnPluginError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "VpnPluginError::{}",
            match *self {
                Self::Failed => "Failed",
                Self::StartingInProgress => "StartingInProgress",
                Self::AlreadyStarted => "AlreadyStarted",
                Self::StoppingInProgress => "StoppingInProgress",
                Self::AlreadyStopped => "AlreadyStopped",
                Self::WrongState => "WrongState",
                Self::BadArguments => "BadArguments",
                Self::LaunchFailed => "LaunchFailed",
                Self::InvalidConnection => "InvalidConnection",
                Self::InteractiveNotSupported => "InteractiveNotSupported",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for VpnPluginError {
    type GlibType = ffi::NMVpnPluginError;

    fn into_glib(self) -> ffi::NMVpnPluginError {
        match self {
            Self::Failed => ffi::NM_VPN_PLUGIN_ERROR_FAILED,
            Self::StartingInProgress => ffi::NM_VPN_PLUGIN_ERROR_STARTING_IN_PROGRESS,
            Self::AlreadyStarted => ffi::NM_VPN_PLUGIN_ERROR_ALREADY_STARTED,
            Self::StoppingInProgress => ffi::NM_VPN_PLUGIN_ERROR_STOPPING_IN_PROGRESS,
            Self::AlreadyStopped => ffi::NM_VPN_PLUGIN_ERROR_ALREADY_STOPPED,
            Self::WrongState => ffi::NM_VPN_PLUGIN_ERROR_WRONG_STATE,
            Self::BadArguments => ffi::NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,
            Self::LaunchFailed => ffi::NM_VPN_PLUGIN_ERROR_LAUNCH_FAILED,
            Self::InvalidConnection => ffi::NM_VPN_PLUGIN_ERROR_INVALID_CONNECTION,
            Self::InteractiveNotSupported => ffi::NM_VPN_PLUGIN_ERROR_INTERACTIVE_NOT_SUPPORTED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMVpnPluginError> for VpnPluginError {
    unsafe fn from_glib(value: ffi::NMVpnPluginError) -> Self {
        match value {
            ffi::NM_VPN_PLUGIN_ERROR_FAILED => Self::Failed,
            ffi::NM_VPN_PLUGIN_ERROR_STARTING_IN_PROGRESS => Self::StartingInProgress,
            ffi::NM_VPN_PLUGIN_ERROR_ALREADY_STARTED => Self::AlreadyStarted,
            ffi::NM_VPN_PLUGIN_ERROR_STOPPING_IN_PROGRESS => Self::StoppingInProgress,
            ffi::NM_VPN_PLUGIN_ERROR_ALREADY_STOPPED => Self::AlreadyStopped,
            ffi::NM_VPN_PLUGIN_ERROR_WRONG_STATE => Self::WrongState,
            ffi::NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS => Self::BadArguments,
            ffi::NM_VPN_PLUGIN_ERROR_LAUNCH_FAILED => Self::LaunchFailed,
            ffi::NM_VPN_PLUGIN_ERROR_INVALID_CONNECTION => Self::InvalidConnection,
            ffi::NM_VPN_PLUGIN_ERROR_INTERACTIVE_NOT_SUPPORTED => Self::InteractiveNotSupported,
            value => Self::__Unknown(value),
        }
    }
}

impl ErrorDomain for VpnPluginError {
    fn domain() -> Quark {
        unsafe { from_glib(ffi::nm_vpn_plugin_error_quark()) }
    }

    fn code(self) -> i32 {
        self.into_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            ffi::NM_VPN_PLUGIN_ERROR_FAILED => Some(Self::Failed),
            ffi::NM_VPN_PLUGIN_ERROR_STARTING_IN_PROGRESS => Some(Self::StartingInProgress),
            ffi::NM_VPN_PLUGIN_ERROR_ALREADY_STARTED => Some(Self::AlreadyStarted),
            ffi::NM_VPN_PLUGIN_ERROR_STOPPING_IN_PROGRESS => Some(Self::StoppingInProgress),
            ffi::NM_VPN_PLUGIN_ERROR_ALREADY_STOPPED => Some(Self::AlreadyStopped),
            ffi::NM_VPN_PLUGIN_ERROR_WRONG_STATE => Some(Self::WrongState),
            ffi::NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS => Some(Self::BadArguments),
            ffi::NM_VPN_PLUGIN_ERROR_LAUNCH_FAILED => Some(Self::LaunchFailed),
            ffi::NM_VPN_PLUGIN_ERROR_INVALID_CONNECTION => Some(Self::InvalidConnection),
            ffi::NM_VPN_PLUGIN_ERROR_INTERACTIVE_NOT_SUPPORTED => {
                Some(Self::InteractiveNotSupported)
            }
            _ => Some(Self::Failed),
        }
    }
}

impl StaticType for VpnPluginError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_vpn_plugin_error_get_type()) }
    }
}

impl glib::value::ValueType for VpnPluginError {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for VpnPluginError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for VpnPluginError {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// VPN plugin failure reasons
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMVpnPluginFailure")]
pub enum VpnPluginFailure {
    /// Login failed.
    #[doc(alias = "NM_VPN_PLUGIN_FAILURE_LOGIN_FAILED")]
    LoginFailed,
    /// Connect failed.
    #[doc(alias = "NM_VPN_PLUGIN_FAILURE_CONNECT_FAILED")]
    ConnectFailed,
    /// Invalid IP configuration returned from
    ///  the VPN plugin.
    #[doc(alias = "NM_VPN_PLUGIN_FAILURE_BAD_IP_CONFIG")]
    BadIpConfig,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for VpnPluginFailure {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "VpnPluginFailure::{}",
            match *self {
                Self::LoginFailed => "LoginFailed",
                Self::ConnectFailed => "ConnectFailed",
                Self::BadIpConfig => "BadIpConfig",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for VpnPluginFailure {
    type GlibType = ffi::NMVpnPluginFailure;

    fn into_glib(self) -> ffi::NMVpnPluginFailure {
        match self {
            Self::LoginFailed => ffi::NM_VPN_PLUGIN_FAILURE_LOGIN_FAILED,
            Self::ConnectFailed => ffi::NM_VPN_PLUGIN_FAILURE_CONNECT_FAILED,
            Self::BadIpConfig => ffi::NM_VPN_PLUGIN_FAILURE_BAD_IP_CONFIG,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMVpnPluginFailure> for VpnPluginFailure {
    unsafe fn from_glib(value: ffi::NMVpnPluginFailure) -> Self {
        match value {
            ffi::NM_VPN_PLUGIN_FAILURE_LOGIN_FAILED => Self::LoginFailed,
            ffi::NM_VPN_PLUGIN_FAILURE_CONNECT_FAILED => Self::ConnectFailed,
            ffi::NM_VPN_PLUGIN_FAILURE_BAD_IP_CONFIG => Self::BadIpConfig,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for VpnPluginFailure {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_vpn_plugin_failure_get_type()) }
    }
}

impl glib::value::ValueType for VpnPluginFailure {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for VpnPluginFailure {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for VpnPluginFailure {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// VPN daemon states
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMVpnServiceState")]
pub enum VpnServiceState {
    /// The state of the VPN plugin is unknown.
    #[doc(alias = "NM_VPN_SERVICE_STATE_UNKNOWN")]
    Unknown,
    /// The VPN plugin is initialized.
    #[doc(alias = "NM_VPN_SERVICE_STATE_INIT")]
    Init,
    /// Not used.
    #[doc(alias = "NM_VPN_SERVICE_STATE_SHUTDOWN")]
    Shutdown,
    /// The plugin is attempting to connect to a VPN server.
    #[doc(alias = "NM_VPN_SERVICE_STATE_STARTING")]
    Starting,
    /// The plugin has connected to a VPN server.
    #[doc(alias = "NM_VPN_SERVICE_STATE_STARTED")]
    Started,
    /// The plugin is disconnecting from the VPN server.
    #[doc(alias = "NM_VPN_SERVICE_STATE_STOPPING")]
    Stopping,
    /// The plugin has disconnected from the VPN server.
    #[doc(alias = "NM_VPN_SERVICE_STATE_STOPPED")]
    Stopped,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for VpnServiceState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "VpnServiceState::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::Init => "Init",
                Self::Shutdown => "Shutdown",
                Self::Starting => "Starting",
                Self::Started => "Started",
                Self::Stopping => "Stopping",
                Self::Stopped => "Stopped",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for VpnServiceState {
    type GlibType = ffi::NMVpnServiceState;

    fn into_glib(self) -> ffi::NMVpnServiceState {
        match self {
            Self::Unknown => ffi::NM_VPN_SERVICE_STATE_UNKNOWN,
            Self::Init => ffi::NM_VPN_SERVICE_STATE_INIT,
            Self::Shutdown => ffi::NM_VPN_SERVICE_STATE_SHUTDOWN,
            Self::Starting => ffi::NM_VPN_SERVICE_STATE_STARTING,
            Self::Started => ffi::NM_VPN_SERVICE_STATE_STARTED,
            Self::Stopping => ffi::NM_VPN_SERVICE_STATE_STOPPING,
            Self::Stopped => ffi::NM_VPN_SERVICE_STATE_STOPPED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMVpnServiceState> for VpnServiceState {
    unsafe fn from_glib(value: ffi::NMVpnServiceState) -> Self {
        match value {
            ffi::NM_VPN_SERVICE_STATE_UNKNOWN => Self::Unknown,
            ffi::NM_VPN_SERVICE_STATE_INIT => Self::Init,
            ffi::NM_VPN_SERVICE_STATE_SHUTDOWN => Self::Shutdown,
            ffi::NM_VPN_SERVICE_STATE_STARTING => Self::Starting,
            ffi::NM_VPN_SERVICE_STATE_STARTED => Self::Started,
            ffi::NM_VPN_SERVICE_STATE_STOPPING => Self::Stopping,
            ffi::NM_VPN_SERVICE_STATE_STOPPED => Self::Stopped,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for VpnServiceState {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_vpn_service_state_get_type()) }
    }
}

impl glib::value::ValueType for VpnServiceState {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for VpnServiceState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for VpnServiceState {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// The [`WepKeyType`][crate::WepKeyType] values specify how any WEP keys present in the setting
/// are interpreted. There are no standards governing how to hash the various WEP
/// key/passphrase formats into the actual WEP key. Unfortunately some WEP keys
/// can be interpreted in multiple ways, requiring the setting to specify how to
/// interpret the any WEP keys. For example, the key "732f2d712e4a394a375d366931"
/// is both a valid Hexadecimal WEP key and a WEP passphrase. Further, many
/// ASCII keys are also valid WEP passphrases, but since passphrases and ASCII
/// keys are hashed differently to determine the actual WEP key the type must be
/// specified.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMWepKeyType")]
pub enum WepKeyType {
    /// unknown WEP key type
    #[doc(alias = "NM_WEP_KEY_TYPE_UNKNOWN")]
    Unknown,
    /// indicates a hexadecimal or ASCII formatted WEP key.
    /// Hex keys are either 10 or 26 hexadecimal characters (ie "5f782f2f5f" or
    /// "732f2d712e4a394a375d366931"), while ASCII keys are either 5 or 13 ASCII
    /// characters (ie "abcde" or "blahblah99$*1").
    #[doc(alias = "NM_WEP_KEY_TYPE_KEY")]
    Key,
    /// indicates a WEP passphrase (ex "I bought a duck
    /// on my way back from the market 235Q&^%^*%") instead of a hexadecimal or ASCII
    /// key. Passphrases are between 8 and 64 characters inclusive and are hashed
    /// the actual WEP key using the MD5 hash algorithm.
    #[doc(alias = "NM_WEP_KEY_TYPE_PASSPHRASE")]
    Passphrase,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for WepKeyType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "WepKeyType::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::Key => "Key",
                Self::Passphrase => "Passphrase",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for WepKeyType {
    type GlibType = ffi::NMWepKeyType;

    fn into_glib(self) -> ffi::NMWepKeyType {
        match self {
            Self::Unknown => ffi::NM_WEP_KEY_TYPE_UNKNOWN,
            Self::Key => ffi::NM_WEP_KEY_TYPE_KEY,
            Self::Passphrase => ffi::NM_WEP_KEY_TYPE_PASSPHRASE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMWepKeyType> for WepKeyType {
    unsafe fn from_glib(value: ffi::NMWepKeyType) -> Self {
        match value {
            ffi::NM_WEP_KEY_TYPE_UNKNOWN => Self::Unknown,
            ffi::NM_WEP_KEY_TYPE_KEY => Self::Key,
            ffi::NM_WEP_KEY_TYPE_PASSPHRASE => Self::Passphrase,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for WepKeyType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_wep_key_type_get_type()) }
    }
}

impl glib::value::ValueType for WepKeyType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for WepKeyType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for WepKeyType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// WiMAX network type.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMWimaxNspNetworkType")]
pub enum WimaxNspNetworkType {
    /// unknown network type
    #[doc(alias = "NM_WIMAX_NSP_NETWORK_TYPE_UNKNOWN")]
    Unknown,
    /// home network
    #[doc(alias = "NM_WIMAX_NSP_NETWORK_TYPE_HOME")]
    Home,
    /// partner network
    #[doc(alias = "NM_WIMAX_NSP_NETWORK_TYPE_PARTNER")]
    Partner,
    /// roaming partner network
    #[doc(alias = "NM_WIMAX_NSP_NETWORK_TYPE_ROAMING_PARTNER")]
    RoamingPartner,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for WimaxNspNetworkType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "WimaxNspNetworkType::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::Home => "Home",
                Self::Partner => "Partner",
                Self::RoamingPartner => "RoamingPartner",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for WimaxNspNetworkType {
    type GlibType = ffi::NMWimaxNspNetworkType;

    fn into_glib(self) -> ffi::NMWimaxNspNetworkType {
        match self {
            Self::Unknown => ffi::NM_WIMAX_NSP_NETWORK_TYPE_UNKNOWN,
            Self::Home => ffi::NM_WIMAX_NSP_NETWORK_TYPE_HOME,
            Self::Partner => ffi::NM_WIMAX_NSP_NETWORK_TYPE_PARTNER,
            Self::RoamingPartner => ffi::NM_WIMAX_NSP_NETWORK_TYPE_ROAMING_PARTNER,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMWimaxNspNetworkType> for WimaxNspNetworkType {
    unsafe fn from_glib(value: ffi::NMWimaxNspNetworkType) -> Self {
        match value {
            ffi::NM_WIMAX_NSP_NETWORK_TYPE_UNKNOWN => Self::Unknown,
            ffi::NM_WIMAX_NSP_NETWORK_TYPE_HOME => Self::Home,
            ffi::NM_WIMAX_NSP_NETWORK_TYPE_PARTNER => Self::Partner,
            ffi::NM_WIMAX_NSP_NETWORK_TYPE_ROAMING_PARTNER => Self::RoamingPartner,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for WimaxNspNetworkType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_wimax_nsp_network_type_get_type()) }
    }
}

impl glib::value::ValueType for WimaxNspNetworkType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for WimaxNspNetworkType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for WimaxNspNetworkType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// Indicates the 802.11 mode an access point or device is currently in.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NM80211Mode")]
pub enum _80211Mode {
    /// the device or access point mode is unknown
    #[doc(alias = "NM_802_11_MODE_UNKNOWN")]
    Unknown,
    /// for both devices and access point objects, indicates
    ///  the object is part of an Ad-Hoc 802.11 network without a central
    ///  coordinating access point.
    #[doc(alias = "NM_802_11_MODE_ADHOC")]
    Adhoc,
    /// the device or access point is in infrastructure mode.
    ///  For devices, this indicates the device is an 802.11 client/station. For
    ///  access point objects, this indicates the object is an access point that
    ///  provides connectivity to clients.
    #[doc(alias = "NM_802_11_MODE_INFRA")]
    Infra,
    /// the device is an access point/hotspot. Not valid for
    ///  access point objects; used only for hotspot mode on the local machine.
    #[doc(alias = "NM_802_11_MODE_AP")]
    Ap,
    /// the device is a 802.11s mesh point. Since: 1.20.
    #[doc(alias = "NM_802_11_MODE_MESH")]
    Mesh,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for _80211Mode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "_80211Mode::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::Adhoc => "Adhoc",
                Self::Infra => "Infra",
                Self::Ap => "Ap",
                Self::Mesh => "Mesh",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for _80211Mode {
    type GlibType = ffi::NM80211Mode;

    fn into_glib(self) -> ffi::NM80211Mode {
        match self {
            Self::Unknown => ffi::NM_802_11_MODE_UNKNOWN,
            Self::Adhoc => ffi::NM_802_11_MODE_ADHOC,
            Self::Infra => ffi::NM_802_11_MODE_INFRA,
            Self::Ap => ffi::NM_802_11_MODE_AP,
            Self::Mesh => ffi::NM_802_11_MODE_MESH,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NM80211Mode> for _80211Mode {
    unsafe fn from_glib(value: ffi::NM80211Mode) -> Self {
        match value {
            ffi::NM_802_11_MODE_UNKNOWN => Self::Unknown,
            ffi::NM_802_11_MODE_ADHOC => Self::Adhoc,
            ffi::NM_802_11_MODE_INFRA => Self::Infra,
            ffi::NM_802_11_MODE_AP => Self::Ap,
            ffi::NM_802_11_MODE_MESH => Self::Mesh,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for _80211Mode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_802_11_mode_get_type()) }
    }
}

impl glib::value::ValueType for _80211Mode {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for _80211Mode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for _80211Mode {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}
