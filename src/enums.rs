// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::value::Value;
use glib::Quark;
use glib::StaticType;
use glib::Type;
use gobject_sys;
use nm_sys;
use std::fmt;

/// `ActiveConnectionState` values indicate the state of a connection to a
/// specific network while it is starting, connected, or disconnecting from that
/// network.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ActiveConnectionState {
    Unknown,
    Activating,
    Activated,
    Deactivating,
    Deactivated,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ActiveConnectionState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ActiveConnectionState::{}",
            match *self {
                ActiveConnectionState::Unknown => "Unknown",
                ActiveConnectionState::Activating => "Activating",
                ActiveConnectionState::Activated => "Activated",
                ActiveConnectionState::Deactivating => "Deactivating",
                ActiveConnectionState::Deactivated => "Deactivated",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ActiveConnectionState {
    type GlibType = nm_sys::NMActiveConnectionState;

    fn to_glib(&self) -> nm_sys::NMActiveConnectionState {
        match *self {
            ActiveConnectionState::Unknown => nm_sys::NM_ACTIVE_CONNECTION_STATE_UNKNOWN,
            ActiveConnectionState::Activating => nm_sys::NM_ACTIVE_CONNECTION_STATE_ACTIVATING,
            ActiveConnectionState::Activated => nm_sys::NM_ACTIVE_CONNECTION_STATE_ACTIVATED,
            ActiveConnectionState::Deactivating => nm_sys::NM_ACTIVE_CONNECTION_STATE_DEACTIVATING,
            ActiveConnectionState::Deactivated => nm_sys::NM_ACTIVE_CONNECTION_STATE_DEACTIVATED,
            ActiveConnectionState::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMActiveConnectionState> for ActiveConnectionState {
    fn from_glib(value: nm_sys::NMActiveConnectionState) -> Self {
        match value {
            0 => ActiveConnectionState::Unknown,
            1 => ActiveConnectionState::Activating,
            2 => ActiveConnectionState::Activated,
            3 => ActiveConnectionState::Deactivating,
            4 => ActiveConnectionState::Deactivated,
            value => ActiveConnectionState::__Unknown(value),
        }
    }
}

impl StaticType for ActiveConnectionState {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_active_connection_state_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ActiveConnectionState {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ActiveConnectionState {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ActiveConnectionState {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// Active connection state reasons.
#[cfg(any(feature = "v1_8", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ActiveConnectionStateReason {
    Unknown,
    None,
    UserDisconnected,
    DeviceDisconnected,
    ServiceStopped,
    IpConfigInvalid,
    ConnectTimeout,
    ServiceStartTimeout,
    ServiceStartFailed,
    NoSecrets,
    LoginFailed,
    ConnectionRemoved,
    DependencyFailed,
    DeviceRealizeFailed,
    DeviceRemoved,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
impl fmt::Display for ActiveConnectionStateReason {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ActiveConnectionStateReason::{}",
            match *self {
                ActiveConnectionStateReason::Unknown => "Unknown",
                ActiveConnectionStateReason::None => "None",
                ActiveConnectionStateReason::UserDisconnected => "UserDisconnected",
                ActiveConnectionStateReason::DeviceDisconnected => "DeviceDisconnected",
                ActiveConnectionStateReason::ServiceStopped => "ServiceStopped",
                ActiveConnectionStateReason::IpConfigInvalid => "IpConfigInvalid",
                ActiveConnectionStateReason::ConnectTimeout => "ConnectTimeout",
                ActiveConnectionStateReason::ServiceStartTimeout => "ServiceStartTimeout",
                ActiveConnectionStateReason::ServiceStartFailed => "ServiceStartFailed",
                ActiveConnectionStateReason::NoSecrets => "NoSecrets",
                ActiveConnectionStateReason::LoginFailed => "LoginFailed",
                ActiveConnectionStateReason::ConnectionRemoved => "ConnectionRemoved",
                ActiveConnectionStateReason::DependencyFailed => "DependencyFailed",
                ActiveConnectionStateReason::DeviceRealizeFailed => "DeviceRealizeFailed",
                ActiveConnectionStateReason::DeviceRemoved => "DeviceRemoved",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for ActiveConnectionStateReason {
    type GlibType = nm_sys::NMActiveConnectionStateReason;

    fn to_glib(&self) -> nm_sys::NMActiveConnectionStateReason {
        match *self {
            ActiveConnectionStateReason::Unknown => {
                nm_sys::NM_ACTIVE_CONNECTION_STATE_REASON_UNKNOWN
            }
            ActiveConnectionStateReason::None => nm_sys::NM_ACTIVE_CONNECTION_STATE_REASON_NONE,
            ActiveConnectionStateReason::UserDisconnected => {
                nm_sys::NM_ACTIVE_CONNECTION_STATE_REASON_USER_DISCONNECTED
            }
            ActiveConnectionStateReason::DeviceDisconnected => {
                nm_sys::NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED
            }
            ActiveConnectionStateReason::ServiceStopped => {
                nm_sys::NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_STOPPED
            }
            ActiveConnectionStateReason::IpConfigInvalid => {
                nm_sys::NM_ACTIVE_CONNECTION_STATE_REASON_IP_CONFIG_INVALID
            }
            ActiveConnectionStateReason::ConnectTimeout => {
                nm_sys::NM_ACTIVE_CONNECTION_STATE_REASON_CONNECT_TIMEOUT
            }
            ActiveConnectionStateReason::ServiceStartTimeout => {
                nm_sys::NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT
            }
            ActiveConnectionStateReason::ServiceStartFailed => {
                nm_sys::NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_FAILED
            }
            ActiveConnectionStateReason::NoSecrets => {
                nm_sys::NM_ACTIVE_CONNECTION_STATE_REASON_NO_SECRETS
            }
            ActiveConnectionStateReason::LoginFailed => {
                nm_sys::NM_ACTIVE_CONNECTION_STATE_REASON_LOGIN_FAILED
            }
            ActiveConnectionStateReason::ConnectionRemoved => {
                nm_sys::NM_ACTIVE_CONNECTION_STATE_REASON_CONNECTION_REMOVED
            }
            ActiveConnectionStateReason::DependencyFailed => {
                nm_sys::NM_ACTIVE_CONNECTION_STATE_REASON_DEPENDENCY_FAILED
            }
            ActiveConnectionStateReason::DeviceRealizeFailed => {
                nm_sys::NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REALIZE_FAILED
            }
            ActiveConnectionStateReason::DeviceRemoved => {
                nm_sys::NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REMOVED
            }
            ActiveConnectionStateReason::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMActiveConnectionStateReason> for ActiveConnectionStateReason {
    fn from_glib(value: nm_sys::NMActiveConnectionStateReason) -> Self {
        match value {
            0 => ActiveConnectionStateReason::Unknown,
            1 => ActiveConnectionStateReason::None,
            2 => ActiveConnectionStateReason::UserDisconnected,
            3 => ActiveConnectionStateReason::DeviceDisconnected,
            4 => ActiveConnectionStateReason::ServiceStopped,
            5 => ActiveConnectionStateReason::IpConfigInvalid,
            6 => ActiveConnectionStateReason::ConnectTimeout,
            7 => ActiveConnectionStateReason::ServiceStartTimeout,
            8 => ActiveConnectionStateReason::ServiceStartFailed,
            9 => ActiveConnectionStateReason::NoSecrets,
            10 => ActiveConnectionStateReason::LoginFailed,
            11 => ActiveConnectionStateReason::ConnectionRemoved,
            12 => ActiveConnectionStateReason::DependencyFailed,
            13 => ActiveConnectionStateReason::DeviceRealizeFailed,
            14 => ActiveConnectionStateReason::DeviceRemoved,
            value => ActiveConnectionStateReason::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
impl StaticType for ActiveConnectionStateReason {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_active_connection_state_reason_get_type()) }
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
impl<'a> FromValueOptional<'a> for ActiveConnectionStateReason {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
impl<'a> FromValue<'a> for ActiveConnectionStateReason {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
impl SetValue for ActiveConnectionStateReason {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// Errors returned from the secret-agent manager.
///
/// These errors may be returned from operations that could cause secrets to be
/// requested (such as `nm_client_activate_connection`), and correspond to D-Bus
/// errors in the "org.freedesktop.NetworkManager.AgentManager" namespace.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum AgentManagerError {
    Failed,
    PermissionDenied,
    InvalidIdentifier,
    NotRegistered,
    NoSecrets,
    UserCanceled,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AgentManagerError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AgentManagerError::{}",
            match *self {
                AgentManagerError::Failed => "Failed",
                AgentManagerError::PermissionDenied => "PermissionDenied",
                AgentManagerError::InvalidIdentifier => "InvalidIdentifier",
                AgentManagerError::NotRegistered => "NotRegistered",
                AgentManagerError::NoSecrets => "NoSecrets",
                AgentManagerError::UserCanceled => "UserCanceled",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for AgentManagerError {
    type GlibType = nm_sys::NMAgentManagerError;

    fn to_glib(&self) -> nm_sys::NMAgentManagerError {
        match *self {
            AgentManagerError::Failed => nm_sys::NM_AGENT_MANAGER_ERROR_FAILED,
            AgentManagerError::PermissionDenied => nm_sys::NM_AGENT_MANAGER_ERROR_PERMISSION_DENIED,
            AgentManagerError::InvalidIdentifier => {
                nm_sys::NM_AGENT_MANAGER_ERROR_INVALID_IDENTIFIER
            }
            AgentManagerError::NotRegistered => nm_sys::NM_AGENT_MANAGER_ERROR_NOT_REGISTERED,
            AgentManagerError::NoSecrets => nm_sys::NM_AGENT_MANAGER_ERROR_NO_SECRETS,
            AgentManagerError::UserCanceled => nm_sys::NM_AGENT_MANAGER_ERROR_USER_CANCELED,
            AgentManagerError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMAgentManagerError> for AgentManagerError {
    fn from_glib(value: nm_sys::NMAgentManagerError) -> Self {
        match value {
            0 => AgentManagerError::Failed,
            1 => AgentManagerError::PermissionDenied,
            2 => AgentManagerError::InvalidIdentifier,
            3 => AgentManagerError::NotRegistered,
            4 => AgentManagerError::NoSecrets,
            5 => AgentManagerError::UserCanceled,
            value => AgentManagerError::__Unknown(value),
        }
    }
}

impl ErrorDomain for AgentManagerError {
    fn domain() -> Quark {
        unsafe { from_glib(nm_sys::nm_agent_manager_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            0 => Some(AgentManagerError::Failed),
            1 => Some(AgentManagerError::PermissionDenied),
            2 => Some(AgentManagerError::InvalidIdentifier),
            3 => Some(AgentManagerError::NotRegistered),
            4 => Some(AgentManagerError::NoSecrets),
            5 => Some(AgentManagerError::UserCanceled),
            _ => Some(AgentManagerError::Failed),
        }
    }
}

impl StaticType for AgentManagerError {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_agent_manager_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for AgentManagerError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for AgentManagerError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for AgentManagerError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// `Capability` names the numbers in the Capabilities property.
/// Capabilities are positive numbers. They are part of stable API
/// and a certain capability number is guaranteed not to change.
///
/// The range 0x7000 - 0x7FFF of capabilities is guaranteed not to be
/// used by upstream NetworkManager. It could thus be used for downstream
/// extensions.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum Capability {
    Team,
    Ovs,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Capability {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Capability::{}",
            match *self {
                Capability::Team => "Team",
                Capability::Ovs => "Ovs",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for Capability {
    type GlibType = nm_sys::NMCapability;

    fn to_glib(&self) -> nm_sys::NMCapability {
        match *self {
            Capability::Team => nm_sys::NM_CAPABILITY_TEAM,
            Capability::Ovs => nm_sys::NM_CAPABILITY_OVS,
            Capability::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMCapability> for Capability {
    fn from_glib(value: nm_sys::NMCapability) -> Self {
        match value {
            1 => Capability::Team,
            2 => Capability::Ovs,
            value => Capability::__Unknown(value),
        }
    }
}

impl StaticType for Capability {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_capability_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Capability {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Capability {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Capability {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// Describes errors that may result from operations involving a `Client`.
///
/// D-Bus operations may also return errors from other domains, including
/// `ManagerError`, `SettingsError`, `AgentManagerError`, and `ConnectionError`.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ClientError {
    Failed,
    ManagerNotRunning,
    ObjectCreationFailed,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ClientError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ClientError::{}",
            match *self {
                ClientError::Failed => "Failed",
                ClientError::ManagerNotRunning => "ManagerNotRunning",
                ClientError::ObjectCreationFailed => "ObjectCreationFailed",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ClientError {
    type GlibType = nm_sys::NMClientError;

    fn to_glib(&self) -> nm_sys::NMClientError {
        match *self {
            ClientError::Failed => nm_sys::NM_CLIENT_ERROR_FAILED,
            ClientError::ManagerNotRunning => nm_sys::NM_CLIENT_ERROR_MANAGER_NOT_RUNNING,
            ClientError::ObjectCreationFailed => nm_sys::NM_CLIENT_ERROR_OBJECT_CREATION_FAILED,
            ClientError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMClientError> for ClientError {
    fn from_glib(value: nm_sys::NMClientError) -> Self {
        match value {
            0 => ClientError::Failed,
            1 => ClientError::ManagerNotRunning,
            2 => ClientError::ObjectCreationFailed,
            value => ClientError::__Unknown(value),
        }
    }
}

impl ErrorDomain for ClientError {
    fn domain() -> Quark {
        unsafe { from_glib(nm_sys::nm_client_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            0 => Some(ClientError::Failed),
            1 => Some(ClientError::ManagerNotRunning),
            2 => Some(ClientError::ObjectCreationFailed),
            _ => Some(ClientError::Failed),
        }
    }
}

impl StaticType for ClientError {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_client_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ClientError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ClientError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ClientError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// `ClientPermission` values indicate various permissions that NetworkManager
/// clients can obtain to perform certain tasks on behalf of the current user.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ClientPermission {
    None,
    EnableDisableNetwork,
    EnableDisableWifi,
    EnableDisableWwan,
    EnableDisableWimax,
    SleepWake,
    NetworkControl,
    WifiShareProtected,
    WifiShareOpen,
    SettingsModifySystem,
    SettingsModifyOwn,
    SettingsModifyHostname,
    SettingsModifyGlobalDns,
    Reload,
    CheckpointRollback,
    EnableDisableStatistics,
    EnableDisableConnectivityCheck,
    WifiScan,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ClientPermission {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ClientPermission::{}",
            match *self {
                ClientPermission::None => "None",
                ClientPermission::EnableDisableNetwork => "EnableDisableNetwork",
                ClientPermission::EnableDisableWifi => "EnableDisableWifi",
                ClientPermission::EnableDisableWwan => "EnableDisableWwan",
                ClientPermission::EnableDisableWimax => "EnableDisableWimax",
                ClientPermission::SleepWake => "SleepWake",
                ClientPermission::NetworkControl => "NetworkControl",
                ClientPermission::WifiShareProtected => "WifiShareProtected",
                ClientPermission::WifiShareOpen => "WifiShareOpen",
                ClientPermission::SettingsModifySystem => "SettingsModifySystem",
                ClientPermission::SettingsModifyOwn => "SettingsModifyOwn",
                ClientPermission::SettingsModifyHostname => "SettingsModifyHostname",
                ClientPermission::SettingsModifyGlobalDns => "SettingsModifyGlobalDns",
                ClientPermission::Reload => "Reload",
                ClientPermission::CheckpointRollback => "CheckpointRollback",
                ClientPermission::EnableDisableStatistics => "EnableDisableStatistics",
                ClientPermission::EnableDisableConnectivityCheck =>
                    "EnableDisableConnectivityCheck",
                ClientPermission::WifiScan => "WifiScan",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ClientPermission {
    type GlibType = nm_sys::NMClientPermission;

    fn to_glib(&self) -> nm_sys::NMClientPermission {
        match *self {
            ClientPermission::None => nm_sys::NM_CLIENT_PERMISSION_NONE,
            ClientPermission::EnableDisableNetwork => {
                nm_sys::NM_CLIENT_PERMISSION_ENABLE_DISABLE_NETWORK
            }
            ClientPermission::EnableDisableWifi => nm_sys::NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIFI,
            ClientPermission::EnableDisableWwan => nm_sys::NM_CLIENT_PERMISSION_ENABLE_DISABLE_WWAN,
            ClientPermission::EnableDisableWimax => {
                nm_sys::NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIMAX
            }
            ClientPermission::SleepWake => nm_sys::NM_CLIENT_PERMISSION_SLEEP_WAKE,
            ClientPermission::NetworkControl => nm_sys::NM_CLIENT_PERMISSION_NETWORK_CONTROL,
            ClientPermission::WifiShareProtected => {
                nm_sys::NM_CLIENT_PERMISSION_WIFI_SHARE_PROTECTED
            }
            ClientPermission::WifiShareOpen => nm_sys::NM_CLIENT_PERMISSION_WIFI_SHARE_OPEN,
            ClientPermission::SettingsModifySystem => {
                nm_sys::NM_CLIENT_PERMISSION_SETTINGS_MODIFY_SYSTEM
            }
            ClientPermission::SettingsModifyOwn => nm_sys::NM_CLIENT_PERMISSION_SETTINGS_MODIFY_OWN,
            ClientPermission::SettingsModifyHostname => {
                nm_sys::NM_CLIENT_PERMISSION_SETTINGS_MODIFY_HOSTNAME
            }
            ClientPermission::SettingsModifyGlobalDns => {
                nm_sys::NM_CLIENT_PERMISSION_SETTINGS_MODIFY_GLOBAL_DNS
            }
            ClientPermission::Reload => nm_sys::NM_CLIENT_PERMISSION_RELOAD,
            ClientPermission::CheckpointRollback => {
                nm_sys::NM_CLIENT_PERMISSION_CHECKPOINT_ROLLBACK
            }
            ClientPermission::EnableDisableStatistics => {
                nm_sys::NM_CLIENT_PERMISSION_ENABLE_DISABLE_STATISTICS
            }
            ClientPermission::EnableDisableConnectivityCheck => {
                nm_sys::NM_CLIENT_PERMISSION_ENABLE_DISABLE_CONNECTIVITY_CHECK
            }
            ClientPermission::WifiScan => nm_sys::NM_CLIENT_PERMISSION_WIFI_SCAN,
            ClientPermission::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMClientPermission> for ClientPermission {
    fn from_glib(value: nm_sys::NMClientPermission) -> Self {
        match value {
            0 => ClientPermission::None,
            1 => ClientPermission::EnableDisableNetwork,
            2 => ClientPermission::EnableDisableWifi,
            3 => ClientPermission::EnableDisableWwan,
            4 => ClientPermission::EnableDisableWimax,
            5 => ClientPermission::SleepWake,
            6 => ClientPermission::NetworkControl,
            7 => ClientPermission::WifiShareProtected,
            8 => ClientPermission::WifiShareOpen,
            9 => ClientPermission::SettingsModifySystem,
            10 => ClientPermission::SettingsModifyOwn,
            11 => ClientPermission::SettingsModifyHostname,
            12 => ClientPermission::SettingsModifyGlobalDns,
            13 => ClientPermission::Reload,
            14 => ClientPermission::CheckpointRollback,
            15 => ClientPermission::EnableDisableStatistics,
            16 => ClientPermission::EnableDisableConnectivityCheck,
            17 => ClientPermission::WifiScan,
            value => ClientPermission::__Unknown(value),
        }
    }
}

impl StaticType for ClientPermission {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_client_permission_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ClientPermission {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ClientPermission {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ClientPermission {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// `ClientPermissionResult` values indicate what authorizations and permissions
/// the user requires to obtain a given `ClientPermission`
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ClientPermissionResult {
    Unknown,
    Yes,
    Auth,
    No,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ClientPermissionResult {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ClientPermissionResult::{}",
            match *self {
                ClientPermissionResult::Unknown => "Unknown",
                ClientPermissionResult::Yes => "Yes",
                ClientPermissionResult::Auth => "Auth",
                ClientPermissionResult::No => "No",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ClientPermissionResult {
    type GlibType = nm_sys::NMClientPermissionResult;

    fn to_glib(&self) -> nm_sys::NMClientPermissionResult {
        match *self {
            ClientPermissionResult::Unknown => nm_sys::NM_CLIENT_PERMISSION_RESULT_UNKNOWN,
            ClientPermissionResult::Yes => nm_sys::NM_CLIENT_PERMISSION_RESULT_YES,
            ClientPermissionResult::Auth => nm_sys::NM_CLIENT_PERMISSION_RESULT_AUTH,
            ClientPermissionResult::No => nm_sys::NM_CLIENT_PERMISSION_RESULT_NO,
            ClientPermissionResult::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMClientPermissionResult> for ClientPermissionResult {
    fn from_glib(value: nm_sys::NMClientPermissionResult) -> Self {
        match value {
            0 => ClientPermissionResult::Unknown,
            1 => ClientPermissionResult::Yes,
            2 => ClientPermissionResult::Auth,
            3 => ClientPermissionResult::No,
            value => ClientPermissionResult::__Unknown(value),
        }
    }
}

impl StaticType for ClientPermissionResult {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_client_permission_result_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ClientPermissionResult {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ClientPermissionResult {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ClientPermissionResult {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// Describes errors that may result from operations involving a `Connection`
/// or its `NMSettings`.
///
/// These errors may be returned directly from `Connection` and `Setting`
/// methods, or may be returned from D-Bus operations (eg on `Client` or
/// `Device`), where they correspond to errors in the
/// "org.freedesktop.NetworkManager.Settings.Connection" namespace.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ConnectionError {
    Failed,
    SettingNotFound,
    PropertyNotFound,
    PropertyNotSecret,
    MissingSetting,
    InvalidSetting,
    MissingProperty,
    InvalidProperty,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ConnectionError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ConnectionError::{}",
            match *self {
                ConnectionError::Failed => "Failed",
                ConnectionError::SettingNotFound => "SettingNotFound",
                ConnectionError::PropertyNotFound => "PropertyNotFound",
                ConnectionError::PropertyNotSecret => "PropertyNotSecret",
                ConnectionError::MissingSetting => "MissingSetting",
                ConnectionError::InvalidSetting => "InvalidSetting",
                ConnectionError::MissingProperty => "MissingProperty",
                ConnectionError::InvalidProperty => "InvalidProperty",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ConnectionError {
    type GlibType = nm_sys::NMConnectionError;

    fn to_glib(&self) -> nm_sys::NMConnectionError {
        match *self {
            ConnectionError::Failed => nm_sys::NM_CONNECTION_ERROR_FAILED,
            ConnectionError::SettingNotFound => nm_sys::NM_CONNECTION_ERROR_SETTING_NOT_FOUND,
            ConnectionError::PropertyNotFound => nm_sys::NM_CONNECTION_ERROR_PROPERTY_NOT_FOUND,
            ConnectionError::PropertyNotSecret => nm_sys::NM_CONNECTION_ERROR_PROPERTY_NOT_SECRET,
            ConnectionError::MissingSetting => nm_sys::NM_CONNECTION_ERROR_MISSING_SETTING,
            ConnectionError::InvalidSetting => nm_sys::NM_CONNECTION_ERROR_INVALID_SETTING,
            ConnectionError::MissingProperty => nm_sys::NM_CONNECTION_ERROR_MISSING_PROPERTY,
            ConnectionError::InvalidProperty => nm_sys::NM_CONNECTION_ERROR_INVALID_PROPERTY,
            ConnectionError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMConnectionError> for ConnectionError {
    fn from_glib(value: nm_sys::NMConnectionError) -> Self {
        match value {
            0 => ConnectionError::Failed,
            1 => ConnectionError::SettingNotFound,
            2 => ConnectionError::PropertyNotFound,
            3 => ConnectionError::PropertyNotSecret,
            4 => ConnectionError::MissingSetting,
            5 => ConnectionError::InvalidSetting,
            6 => ConnectionError::MissingProperty,
            7 => ConnectionError::InvalidProperty,
            value => ConnectionError::__Unknown(value),
        }
    }
}

impl ErrorDomain for ConnectionError {
    fn domain() -> Quark {
        unsafe { from_glib(nm_sys::nm_connection_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            0 => Some(ConnectionError::Failed),
            1 => Some(ConnectionError::SettingNotFound),
            2 => Some(ConnectionError::PropertyNotFound),
            3 => Some(ConnectionError::PropertyNotSecret),
            4 => Some(ConnectionError::MissingSetting),
            5 => Some(ConnectionError::InvalidSetting),
            6 => Some(ConnectionError::MissingProperty),
            7 => Some(ConnectionError::InvalidProperty),
            _ => Some(ConnectionError::Failed),
        }
    }
}

impl StaticType for ConnectionError {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_connection_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ConnectionError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ConnectionError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ConnectionError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ConnectionMultiConnect {
    Default,
    Single,
    ManualMultiple,
    Multiple,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
impl fmt::Display for ConnectionMultiConnect {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ConnectionMultiConnect::{}",
            match *self {
                ConnectionMultiConnect::Default => "Default",
                ConnectionMultiConnect::Single => "Single",
                ConnectionMultiConnect::ManualMultiple => "ManualMultiple",
                ConnectionMultiConnect::Multiple => "Multiple",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for ConnectionMultiConnect {
    type GlibType = nm_sys::NMConnectionMultiConnect;

    fn to_glib(&self) -> nm_sys::NMConnectionMultiConnect {
        match *self {
            ConnectionMultiConnect::Default => nm_sys::NM_CONNECTION_MULTI_CONNECT_DEFAULT,
            ConnectionMultiConnect::Single => nm_sys::NM_CONNECTION_MULTI_CONNECT_SINGLE,
            ConnectionMultiConnect::ManualMultiple => {
                nm_sys::NM_CONNECTION_MULTI_CONNECT_MANUAL_MULTIPLE
            }
            ConnectionMultiConnect::Multiple => nm_sys::NM_CONNECTION_MULTI_CONNECT_MULTIPLE,
            ConnectionMultiConnect::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMConnectionMultiConnect> for ConnectionMultiConnect {
    fn from_glib(value: nm_sys::NMConnectionMultiConnect) -> Self {
        match value {
            0 => ConnectionMultiConnect::Default,
            1 => ConnectionMultiConnect::Single,
            2 => ConnectionMultiConnect::ManualMultiple,
            3 => ConnectionMultiConnect::Multiple,
            value => ConnectionMultiConnect::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
impl StaticType for ConnectionMultiConnect {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_connection_multi_connect_get_type()) }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
impl<'a> FromValueOptional<'a> for ConnectionMultiConnect {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
impl<'a> FromValue<'a> for ConnectionMultiConnect {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
impl SetValue for ConnectionMultiConnect {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ConnectivityState {
    Unknown,
    None,
    Portal,
    Limited,
    Full,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ConnectivityState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ConnectivityState::{}",
            match *self {
                ConnectivityState::Unknown => "Unknown",
                ConnectivityState::None => "None",
                ConnectivityState::Portal => "Portal",
                ConnectivityState::Limited => "Limited",
                ConnectivityState::Full => "Full",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ConnectivityState {
    type GlibType = nm_sys::NMConnectivityState;

    fn to_glib(&self) -> nm_sys::NMConnectivityState {
        match *self {
            ConnectivityState::Unknown => nm_sys::NM_CONNECTIVITY_UNKNOWN,
            ConnectivityState::None => nm_sys::NM_CONNECTIVITY_NONE,
            ConnectivityState::Portal => nm_sys::NM_CONNECTIVITY_PORTAL,
            ConnectivityState::Limited => nm_sys::NM_CONNECTIVITY_LIMITED,
            ConnectivityState::Full => nm_sys::NM_CONNECTIVITY_FULL,
            ConnectivityState::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMConnectivityState> for ConnectivityState {
    fn from_glib(value: nm_sys::NMConnectivityState) -> Self {
        match value {
            0 => ConnectivityState::Unknown,
            1 => ConnectivityState::None,
            2 => ConnectivityState::Portal,
            3 => ConnectivityState::Limited,
            4 => ConnectivityState::Full,
            value => ConnectivityState::__Unknown(value),
        }
    }
}

impl StaticType for ConnectivityState {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_connectivity_state_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ConnectivityState {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ConnectivityState {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ConnectivityState {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// Cryptography-related errors that can be returned from some nm-utils methods,
/// and some `Setting8021x` operations.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum CryptoError {
    Failed,
    InvalidData,
    InvalidPassword,
    UnknownCipher,
    DecryptionFailed,
    EncryptionFailed,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CryptoError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CryptoError::{}",
            match *self {
                CryptoError::Failed => "Failed",
                CryptoError::InvalidData => "InvalidData",
                CryptoError::InvalidPassword => "InvalidPassword",
                CryptoError::UnknownCipher => "UnknownCipher",
                CryptoError::DecryptionFailed => "DecryptionFailed",
                CryptoError::EncryptionFailed => "EncryptionFailed",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for CryptoError {
    type GlibType = nm_sys::NMCryptoError;

    fn to_glib(&self) -> nm_sys::NMCryptoError {
        match *self {
            CryptoError::Failed => nm_sys::NM_CRYPTO_ERROR_FAILED,
            CryptoError::InvalidData => nm_sys::NM_CRYPTO_ERROR_INVALID_DATA,
            CryptoError::InvalidPassword => nm_sys::NM_CRYPTO_ERROR_INVALID_PASSWORD,
            CryptoError::UnknownCipher => nm_sys::NM_CRYPTO_ERROR_UNKNOWN_CIPHER,
            CryptoError::DecryptionFailed => nm_sys::NM_CRYPTO_ERROR_DECRYPTION_FAILED,
            CryptoError::EncryptionFailed => nm_sys::NM_CRYPTO_ERROR_ENCRYPTION_FAILED,
            CryptoError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMCryptoError> for CryptoError {
    fn from_glib(value: nm_sys::NMCryptoError) -> Self {
        match value {
            0 => CryptoError::Failed,
            1 => CryptoError::InvalidData,
            2 => CryptoError::InvalidPassword,
            3 => CryptoError::UnknownCipher,
            4 => CryptoError::DecryptionFailed,
            5 => CryptoError::EncryptionFailed,
            value => CryptoError::__Unknown(value),
        }
    }
}

impl ErrorDomain for CryptoError {
    fn domain() -> Quark {
        unsafe { from_glib(nm_sys::nm_crypto_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            0 => Some(CryptoError::Failed),
            1 => Some(CryptoError::InvalidData),
            2 => Some(CryptoError::InvalidPassword),
            3 => Some(CryptoError::UnknownCipher),
            4 => Some(CryptoError::DecryptionFailed),
            5 => Some(CryptoError::EncryptionFailed),
            _ => Some(CryptoError::Failed),
        }
    }
}

impl StaticType for CryptoError {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_crypto_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CryptoError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CryptoError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CryptoError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// Device-related errors.
///
/// These errors may be returned directly from `Device` methods, or may be
/// returned from D-Bus operations (where they correspond to errors in the
/// "org.freedesktop.NetworkManager.Device" namespace).
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum DeviceError {
    Failed,
    CreationFailed,
    InvalidConnection,
    IncompatibleConnection,
    NotActive,
    NotSoftware,
    NotAllowed,
    SpecificObjectNotFound,
    VersionIdMismatch,
    MissingDependencies,
    InvalidArgument,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DeviceError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DeviceError::{}",
            match *self {
                DeviceError::Failed => "Failed",
                DeviceError::CreationFailed => "CreationFailed",
                DeviceError::InvalidConnection => "InvalidConnection",
                DeviceError::IncompatibleConnection => "IncompatibleConnection",
                DeviceError::NotActive => "NotActive",
                DeviceError::NotSoftware => "NotSoftware",
                DeviceError::NotAllowed => "NotAllowed",
                DeviceError::SpecificObjectNotFound => "SpecificObjectNotFound",
                DeviceError::VersionIdMismatch => "VersionIdMismatch",
                DeviceError::MissingDependencies => "MissingDependencies",
                DeviceError::InvalidArgument => "InvalidArgument",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for DeviceError {
    type GlibType = nm_sys::NMDeviceError;

    fn to_glib(&self) -> nm_sys::NMDeviceError {
        match *self {
            DeviceError::Failed => nm_sys::NM_DEVICE_ERROR_FAILED,
            DeviceError::CreationFailed => nm_sys::NM_DEVICE_ERROR_CREATION_FAILED,
            DeviceError::InvalidConnection => nm_sys::NM_DEVICE_ERROR_INVALID_CONNECTION,
            DeviceError::IncompatibleConnection => nm_sys::NM_DEVICE_ERROR_INCOMPATIBLE_CONNECTION,
            DeviceError::NotActive => nm_sys::NM_DEVICE_ERROR_NOT_ACTIVE,
            DeviceError::NotSoftware => nm_sys::NM_DEVICE_ERROR_NOT_SOFTWARE,
            DeviceError::NotAllowed => nm_sys::NM_DEVICE_ERROR_NOT_ALLOWED,
            DeviceError::SpecificObjectNotFound => {
                nm_sys::NM_DEVICE_ERROR_SPECIFIC_OBJECT_NOT_FOUND
            }
            DeviceError::VersionIdMismatch => nm_sys::NM_DEVICE_ERROR_VERSION_ID_MISMATCH,
            DeviceError::MissingDependencies => nm_sys::NM_DEVICE_ERROR_MISSING_DEPENDENCIES,
            DeviceError::InvalidArgument => nm_sys::NM_DEVICE_ERROR_INVALID_ARGUMENT,
            DeviceError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMDeviceError> for DeviceError {
    fn from_glib(value: nm_sys::NMDeviceError) -> Self {
        match value {
            0 => DeviceError::Failed,
            1 => DeviceError::CreationFailed,
            2 => DeviceError::InvalidConnection,
            3 => DeviceError::IncompatibleConnection,
            4 => DeviceError::NotActive,
            5 => DeviceError::NotSoftware,
            6 => DeviceError::NotAllowed,
            7 => DeviceError::SpecificObjectNotFound,
            8 => DeviceError::VersionIdMismatch,
            9 => DeviceError::MissingDependencies,
            10 => DeviceError::InvalidArgument,
            value => DeviceError::__Unknown(value),
        }
    }
}

impl ErrorDomain for DeviceError {
    fn domain() -> Quark {
        unsafe { from_glib(nm_sys::nm_device_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            0 => Some(DeviceError::Failed),
            1 => Some(DeviceError::CreationFailed),
            2 => Some(DeviceError::InvalidConnection),
            3 => Some(DeviceError::IncompatibleConnection),
            4 => Some(DeviceError::NotActive),
            5 => Some(DeviceError::NotSoftware),
            6 => Some(DeviceError::NotAllowed),
            7 => Some(DeviceError::SpecificObjectNotFound),
            8 => Some(DeviceError::VersionIdMismatch),
            9 => Some(DeviceError::MissingDependencies),
            10 => Some(DeviceError::InvalidArgument),
            _ => Some(DeviceError::Failed),
        }
    }
}

impl StaticType for DeviceError {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_device_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DeviceError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DeviceError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for DeviceError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum DeviceState {
    Unknown,
    Unmanaged,
    Unavailable,
    Disconnected,
    Prepare,
    Config,
    NeedAuth,
    IpConfig,
    IpCheck,
    Secondaries,
    Activated,
    Deactivating,
    Failed,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DeviceState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DeviceState::{}",
            match *self {
                DeviceState::Unknown => "Unknown",
                DeviceState::Unmanaged => "Unmanaged",
                DeviceState::Unavailable => "Unavailable",
                DeviceState::Disconnected => "Disconnected",
                DeviceState::Prepare => "Prepare",
                DeviceState::Config => "Config",
                DeviceState::NeedAuth => "NeedAuth",
                DeviceState::IpConfig => "IpConfig",
                DeviceState::IpCheck => "IpCheck",
                DeviceState::Secondaries => "Secondaries",
                DeviceState::Activated => "Activated",
                DeviceState::Deactivating => "Deactivating",
                DeviceState::Failed => "Failed",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for DeviceState {
    type GlibType = nm_sys::NMDeviceState;

    fn to_glib(&self) -> nm_sys::NMDeviceState {
        match *self {
            DeviceState::Unknown => nm_sys::NM_DEVICE_STATE_UNKNOWN,
            DeviceState::Unmanaged => nm_sys::NM_DEVICE_STATE_UNMANAGED,
            DeviceState::Unavailable => nm_sys::NM_DEVICE_STATE_UNAVAILABLE,
            DeviceState::Disconnected => nm_sys::NM_DEVICE_STATE_DISCONNECTED,
            DeviceState::Prepare => nm_sys::NM_DEVICE_STATE_PREPARE,
            DeviceState::Config => nm_sys::NM_DEVICE_STATE_CONFIG,
            DeviceState::NeedAuth => nm_sys::NM_DEVICE_STATE_NEED_AUTH,
            DeviceState::IpConfig => nm_sys::NM_DEVICE_STATE_IP_CONFIG,
            DeviceState::IpCheck => nm_sys::NM_DEVICE_STATE_IP_CHECK,
            DeviceState::Secondaries => nm_sys::NM_DEVICE_STATE_SECONDARIES,
            DeviceState::Activated => nm_sys::NM_DEVICE_STATE_ACTIVATED,
            DeviceState::Deactivating => nm_sys::NM_DEVICE_STATE_DEACTIVATING,
            DeviceState::Failed => nm_sys::NM_DEVICE_STATE_FAILED,
            DeviceState::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMDeviceState> for DeviceState {
    fn from_glib(value: nm_sys::NMDeviceState) -> Self {
        match value {
            0 => DeviceState::Unknown,
            10 => DeviceState::Unmanaged,
            20 => DeviceState::Unavailable,
            30 => DeviceState::Disconnected,
            40 => DeviceState::Prepare,
            50 => DeviceState::Config,
            60 => DeviceState::NeedAuth,
            70 => DeviceState::IpConfig,
            80 => DeviceState::IpCheck,
            90 => DeviceState::Secondaries,
            100 => DeviceState::Activated,
            110 => DeviceState::Deactivating,
            120 => DeviceState::Failed,
            value => DeviceState::__Unknown(value),
        }
    }
}

impl StaticType for DeviceState {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_device_state_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DeviceState {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DeviceState {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for DeviceState {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// Device state change reason codes
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum DeviceStateReason {
    None,
    Unknown,
    NowManaged,
    NowUnmanaged,
    ConfigFailed,
    IpConfigUnavailable,
    IpConfigExpired,
    NoSecrets,
    SupplicantDisconnect,
    SupplicantConfigFailed,
    SupplicantFailed,
    SupplicantTimeout,
    PppStartFailed,
    PppDisconnect,
    PppFailed,
    DhcpStartFailed,
    DhcpError,
    DhcpFailed,
    SharedStartFailed,
    SharedFailed,
    AutoipStartFailed,
    AutoipError,
    AutoipFailed,
    ModemBusy,
    ModemNoDialTone,
    ModemNoCarrier,
    ModemDialTimeout,
    ModemDialFailed,
    ModemInitFailed,
    GsmApnFailed,
    GsmRegistrationNotSearching,
    GsmRegistrationDenied,
    GsmRegistrationTimeout,
    GsmRegistrationFailed,
    GsmPinCheckFailed,
    FirmwareMissing,
    Removed,
    Sleeping,
    ConnectionRemoved,
    UserRequested,
    Carrier,
    ConnectionAssumed,
    SupplicantAvailable,
    ModemNotFound,
    BtFailed,
    GsmSimNotInserted,
    GsmSimPinRequired,
    GsmSimPukRequired,
    GsmSimWrong,
    InfinibandMode,
    DependencyFailed,
    Br2684Failed,
    ModemManagerUnavailable,
    SsidNotFound,
    SecondaryConnectionFailed,
    DcbFcoeFailed,
    TeamdControlFailed,
    ModemFailed,
    ModemAvailable,
    SimPinIncorrect,
    NewActivation,
    ParentChanged,
    ParentManagedChanged,
    OvsdbFailed,
    IpAddressDuplicate,
    IpMethodUnsupported,
    SriovConfigurationFailed,
    PeerNotFound,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DeviceStateReason {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DeviceStateReason::{}",
            match *self {
                DeviceStateReason::None => "None",
                DeviceStateReason::Unknown => "Unknown",
                DeviceStateReason::NowManaged => "NowManaged",
                DeviceStateReason::NowUnmanaged => "NowUnmanaged",
                DeviceStateReason::ConfigFailed => "ConfigFailed",
                DeviceStateReason::IpConfigUnavailable => "IpConfigUnavailable",
                DeviceStateReason::IpConfigExpired => "IpConfigExpired",
                DeviceStateReason::NoSecrets => "NoSecrets",
                DeviceStateReason::SupplicantDisconnect => "SupplicantDisconnect",
                DeviceStateReason::SupplicantConfigFailed => "SupplicantConfigFailed",
                DeviceStateReason::SupplicantFailed => "SupplicantFailed",
                DeviceStateReason::SupplicantTimeout => "SupplicantTimeout",
                DeviceStateReason::PppStartFailed => "PppStartFailed",
                DeviceStateReason::PppDisconnect => "PppDisconnect",
                DeviceStateReason::PppFailed => "PppFailed",
                DeviceStateReason::DhcpStartFailed => "DhcpStartFailed",
                DeviceStateReason::DhcpError => "DhcpError",
                DeviceStateReason::DhcpFailed => "DhcpFailed",
                DeviceStateReason::SharedStartFailed => "SharedStartFailed",
                DeviceStateReason::SharedFailed => "SharedFailed",
                DeviceStateReason::AutoipStartFailed => "AutoipStartFailed",
                DeviceStateReason::AutoipError => "AutoipError",
                DeviceStateReason::AutoipFailed => "AutoipFailed",
                DeviceStateReason::ModemBusy => "ModemBusy",
                DeviceStateReason::ModemNoDialTone => "ModemNoDialTone",
                DeviceStateReason::ModemNoCarrier => "ModemNoCarrier",
                DeviceStateReason::ModemDialTimeout => "ModemDialTimeout",
                DeviceStateReason::ModemDialFailed => "ModemDialFailed",
                DeviceStateReason::ModemInitFailed => "ModemInitFailed",
                DeviceStateReason::GsmApnFailed => "GsmApnFailed",
                DeviceStateReason::GsmRegistrationNotSearching => "GsmRegistrationNotSearching",
                DeviceStateReason::GsmRegistrationDenied => "GsmRegistrationDenied",
                DeviceStateReason::GsmRegistrationTimeout => "GsmRegistrationTimeout",
                DeviceStateReason::GsmRegistrationFailed => "GsmRegistrationFailed",
                DeviceStateReason::GsmPinCheckFailed => "GsmPinCheckFailed",
                DeviceStateReason::FirmwareMissing => "FirmwareMissing",
                DeviceStateReason::Removed => "Removed",
                DeviceStateReason::Sleeping => "Sleeping",
                DeviceStateReason::ConnectionRemoved => "ConnectionRemoved",
                DeviceStateReason::UserRequested => "UserRequested",
                DeviceStateReason::Carrier => "Carrier",
                DeviceStateReason::ConnectionAssumed => "ConnectionAssumed",
                DeviceStateReason::SupplicantAvailable => "SupplicantAvailable",
                DeviceStateReason::ModemNotFound => "ModemNotFound",
                DeviceStateReason::BtFailed => "BtFailed",
                DeviceStateReason::GsmSimNotInserted => "GsmSimNotInserted",
                DeviceStateReason::GsmSimPinRequired => "GsmSimPinRequired",
                DeviceStateReason::GsmSimPukRequired => "GsmSimPukRequired",
                DeviceStateReason::GsmSimWrong => "GsmSimWrong",
                DeviceStateReason::InfinibandMode => "InfinibandMode",
                DeviceStateReason::DependencyFailed => "DependencyFailed",
                DeviceStateReason::Br2684Failed => "Br2684Failed",
                DeviceStateReason::ModemManagerUnavailable => "ModemManagerUnavailable",
                DeviceStateReason::SsidNotFound => "SsidNotFound",
                DeviceStateReason::SecondaryConnectionFailed => "SecondaryConnectionFailed",
                DeviceStateReason::DcbFcoeFailed => "DcbFcoeFailed",
                DeviceStateReason::TeamdControlFailed => "TeamdControlFailed",
                DeviceStateReason::ModemFailed => "ModemFailed",
                DeviceStateReason::ModemAvailable => "ModemAvailable",
                DeviceStateReason::SimPinIncorrect => "SimPinIncorrect",
                DeviceStateReason::NewActivation => "NewActivation",
                DeviceStateReason::ParentChanged => "ParentChanged",
                DeviceStateReason::ParentManagedChanged => "ParentManagedChanged",
                DeviceStateReason::OvsdbFailed => "OvsdbFailed",
                DeviceStateReason::IpAddressDuplicate => "IpAddressDuplicate",
                DeviceStateReason::IpMethodUnsupported => "IpMethodUnsupported",
                DeviceStateReason::SriovConfigurationFailed => "SriovConfigurationFailed",
                DeviceStateReason::PeerNotFound => "PeerNotFound",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for DeviceStateReason {
    type GlibType = nm_sys::NMDeviceStateReason;

    fn to_glib(&self) -> nm_sys::NMDeviceStateReason {
        match *self {
            DeviceStateReason::None => nm_sys::NM_DEVICE_STATE_REASON_NONE,
            DeviceStateReason::Unknown => nm_sys::NM_DEVICE_STATE_REASON_UNKNOWN,
            DeviceStateReason::NowManaged => nm_sys::NM_DEVICE_STATE_REASON_NOW_MANAGED,
            DeviceStateReason::NowUnmanaged => nm_sys::NM_DEVICE_STATE_REASON_NOW_UNMANAGED,
            DeviceStateReason::ConfigFailed => nm_sys::NM_DEVICE_STATE_REASON_CONFIG_FAILED,
            DeviceStateReason::IpConfigUnavailable => {
                nm_sys::NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE
            }
            DeviceStateReason::IpConfigExpired => nm_sys::NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED,
            DeviceStateReason::NoSecrets => nm_sys::NM_DEVICE_STATE_REASON_NO_SECRETS,
            DeviceStateReason::SupplicantDisconnect => {
                nm_sys::NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT
            }
            DeviceStateReason::SupplicantConfigFailed => {
                nm_sys::NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED
            }
            DeviceStateReason::SupplicantFailed => nm_sys::NM_DEVICE_STATE_REASON_SUPPLICANT_FAILED,
            DeviceStateReason::SupplicantTimeout => {
                nm_sys::NM_DEVICE_STATE_REASON_SUPPLICANT_TIMEOUT
            }
            DeviceStateReason::PppStartFailed => nm_sys::NM_DEVICE_STATE_REASON_PPP_START_FAILED,
            DeviceStateReason::PppDisconnect => nm_sys::NM_DEVICE_STATE_REASON_PPP_DISCONNECT,
            DeviceStateReason::PppFailed => nm_sys::NM_DEVICE_STATE_REASON_PPP_FAILED,
            DeviceStateReason::DhcpStartFailed => nm_sys::NM_DEVICE_STATE_REASON_DHCP_START_FAILED,
            DeviceStateReason::DhcpError => nm_sys::NM_DEVICE_STATE_REASON_DHCP_ERROR,
            DeviceStateReason::DhcpFailed => nm_sys::NM_DEVICE_STATE_REASON_DHCP_FAILED,
            DeviceStateReason::SharedStartFailed => {
                nm_sys::NM_DEVICE_STATE_REASON_SHARED_START_FAILED
            }
            DeviceStateReason::SharedFailed => nm_sys::NM_DEVICE_STATE_REASON_SHARED_FAILED,
            DeviceStateReason::AutoipStartFailed => {
                nm_sys::NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED
            }
            DeviceStateReason::AutoipError => nm_sys::NM_DEVICE_STATE_REASON_AUTOIP_ERROR,
            DeviceStateReason::AutoipFailed => nm_sys::NM_DEVICE_STATE_REASON_AUTOIP_FAILED,
            DeviceStateReason::ModemBusy => nm_sys::NM_DEVICE_STATE_REASON_MODEM_BUSY,
            DeviceStateReason::ModemNoDialTone => nm_sys::NM_DEVICE_STATE_REASON_MODEM_NO_DIAL_TONE,
            DeviceStateReason::ModemNoCarrier => nm_sys::NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER,
            DeviceStateReason::ModemDialTimeout => {
                nm_sys::NM_DEVICE_STATE_REASON_MODEM_DIAL_TIMEOUT
            }
            DeviceStateReason::ModemDialFailed => nm_sys::NM_DEVICE_STATE_REASON_MODEM_DIAL_FAILED,
            DeviceStateReason::ModemInitFailed => nm_sys::NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED,
            DeviceStateReason::GsmApnFailed => nm_sys::NM_DEVICE_STATE_REASON_GSM_APN_FAILED,
            DeviceStateReason::GsmRegistrationNotSearching => {
                nm_sys::NM_DEVICE_STATE_REASON_GSM_REGISTRATION_NOT_SEARCHING
            }
            DeviceStateReason::GsmRegistrationDenied => {
                nm_sys::NM_DEVICE_STATE_REASON_GSM_REGISTRATION_DENIED
            }
            DeviceStateReason::GsmRegistrationTimeout => {
                nm_sys::NM_DEVICE_STATE_REASON_GSM_REGISTRATION_TIMEOUT
            }
            DeviceStateReason::GsmRegistrationFailed => {
                nm_sys::NM_DEVICE_STATE_REASON_GSM_REGISTRATION_FAILED
            }
            DeviceStateReason::GsmPinCheckFailed => {
                nm_sys::NM_DEVICE_STATE_REASON_GSM_PIN_CHECK_FAILED
            }
            DeviceStateReason::FirmwareMissing => nm_sys::NM_DEVICE_STATE_REASON_FIRMWARE_MISSING,
            DeviceStateReason::Removed => nm_sys::NM_DEVICE_STATE_REASON_REMOVED,
            DeviceStateReason::Sleeping => nm_sys::NM_DEVICE_STATE_REASON_SLEEPING,
            DeviceStateReason::ConnectionRemoved => {
                nm_sys::NM_DEVICE_STATE_REASON_CONNECTION_REMOVED
            }
            DeviceStateReason::UserRequested => nm_sys::NM_DEVICE_STATE_REASON_USER_REQUESTED,
            DeviceStateReason::Carrier => nm_sys::NM_DEVICE_STATE_REASON_CARRIER,
            DeviceStateReason::ConnectionAssumed => {
                nm_sys::NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED
            }
            DeviceStateReason::SupplicantAvailable => {
                nm_sys::NM_DEVICE_STATE_REASON_SUPPLICANT_AVAILABLE
            }
            DeviceStateReason::ModemNotFound => nm_sys::NM_DEVICE_STATE_REASON_MODEM_NOT_FOUND,
            DeviceStateReason::BtFailed => nm_sys::NM_DEVICE_STATE_REASON_BT_FAILED,
            DeviceStateReason::GsmSimNotInserted => {
                nm_sys::NM_DEVICE_STATE_REASON_GSM_SIM_NOT_INSERTED
            }
            DeviceStateReason::GsmSimPinRequired => {
                nm_sys::NM_DEVICE_STATE_REASON_GSM_SIM_PIN_REQUIRED
            }
            DeviceStateReason::GsmSimPukRequired => {
                nm_sys::NM_DEVICE_STATE_REASON_GSM_SIM_PUK_REQUIRED
            }
            DeviceStateReason::GsmSimWrong => nm_sys::NM_DEVICE_STATE_REASON_GSM_SIM_WRONG,
            DeviceStateReason::InfinibandMode => nm_sys::NM_DEVICE_STATE_REASON_INFINIBAND_MODE,
            DeviceStateReason::DependencyFailed => nm_sys::NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED,
            DeviceStateReason::Br2684Failed => nm_sys::NM_DEVICE_STATE_REASON_BR2684_FAILED,
            DeviceStateReason::ModemManagerUnavailable => {
                nm_sys::NM_DEVICE_STATE_REASON_MODEM_MANAGER_UNAVAILABLE
            }
            DeviceStateReason::SsidNotFound => nm_sys::NM_DEVICE_STATE_REASON_SSID_NOT_FOUND,
            DeviceStateReason::SecondaryConnectionFailed => {
                nm_sys::NM_DEVICE_STATE_REASON_SECONDARY_CONNECTION_FAILED
            }
            DeviceStateReason::DcbFcoeFailed => nm_sys::NM_DEVICE_STATE_REASON_DCB_FCOE_FAILED,
            DeviceStateReason::TeamdControlFailed => {
                nm_sys::NM_DEVICE_STATE_REASON_TEAMD_CONTROL_FAILED
            }
            DeviceStateReason::ModemFailed => nm_sys::NM_DEVICE_STATE_REASON_MODEM_FAILED,
            DeviceStateReason::ModemAvailable => nm_sys::NM_DEVICE_STATE_REASON_MODEM_AVAILABLE,
            DeviceStateReason::SimPinIncorrect => nm_sys::NM_DEVICE_STATE_REASON_SIM_PIN_INCORRECT,
            DeviceStateReason::NewActivation => nm_sys::NM_DEVICE_STATE_REASON_NEW_ACTIVATION,
            DeviceStateReason::ParentChanged => nm_sys::NM_DEVICE_STATE_REASON_PARENT_CHANGED,
            DeviceStateReason::ParentManagedChanged => {
                nm_sys::NM_DEVICE_STATE_REASON_PARENT_MANAGED_CHANGED
            }
            DeviceStateReason::OvsdbFailed => nm_sys::NM_DEVICE_STATE_REASON_OVSDB_FAILED,
            DeviceStateReason::IpAddressDuplicate => {
                nm_sys::NM_DEVICE_STATE_REASON_IP_ADDRESS_DUPLICATE
            }
            DeviceStateReason::IpMethodUnsupported => {
                nm_sys::NM_DEVICE_STATE_REASON_IP_METHOD_UNSUPPORTED
            }
            DeviceStateReason::SriovConfigurationFailed => {
                nm_sys::NM_DEVICE_STATE_REASON_SRIOV_CONFIGURATION_FAILED
            }
            DeviceStateReason::PeerNotFound => nm_sys::NM_DEVICE_STATE_REASON_PEER_NOT_FOUND,
            DeviceStateReason::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMDeviceStateReason> for DeviceStateReason {
    fn from_glib(value: nm_sys::NMDeviceStateReason) -> Self {
        match value {
            0 => DeviceStateReason::None,
            1 => DeviceStateReason::Unknown,
            2 => DeviceStateReason::NowManaged,
            3 => DeviceStateReason::NowUnmanaged,
            4 => DeviceStateReason::ConfigFailed,
            5 => DeviceStateReason::IpConfigUnavailable,
            6 => DeviceStateReason::IpConfigExpired,
            7 => DeviceStateReason::NoSecrets,
            8 => DeviceStateReason::SupplicantDisconnect,
            9 => DeviceStateReason::SupplicantConfigFailed,
            10 => DeviceStateReason::SupplicantFailed,
            11 => DeviceStateReason::SupplicantTimeout,
            12 => DeviceStateReason::PppStartFailed,
            13 => DeviceStateReason::PppDisconnect,
            14 => DeviceStateReason::PppFailed,
            15 => DeviceStateReason::DhcpStartFailed,
            16 => DeviceStateReason::DhcpError,
            17 => DeviceStateReason::DhcpFailed,
            18 => DeviceStateReason::SharedStartFailed,
            19 => DeviceStateReason::SharedFailed,
            20 => DeviceStateReason::AutoipStartFailed,
            21 => DeviceStateReason::AutoipError,
            22 => DeviceStateReason::AutoipFailed,
            23 => DeviceStateReason::ModemBusy,
            24 => DeviceStateReason::ModemNoDialTone,
            25 => DeviceStateReason::ModemNoCarrier,
            26 => DeviceStateReason::ModemDialTimeout,
            27 => DeviceStateReason::ModemDialFailed,
            28 => DeviceStateReason::ModemInitFailed,
            29 => DeviceStateReason::GsmApnFailed,
            30 => DeviceStateReason::GsmRegistrationNotSearching,
            31 => DeviceStateReason::GsmRegistrationDenied,
            32 => DeviceStateReason::GsmRegistrationTimeout,
            33 => DeviceStateReason::GsmRegistrationFailed,
            34 => DeviceStateReason::GsmPinCheckFailed,
            35 => DeviceStateReason::FirmwareMissing,
            36 => DeviceStateReason::Removed,
            37 => DeviceStateReason::Sleeping,
            38 => DeviceStateReason::ConnectionRemoved,
            39 => DeviceStateReason::UserRequested,
            40 => DeviceStateReason::Carrier,
            41 => DeviceStateReason::ConnectionAssumed,
            42 => DeviceStateReason::SupplicantAvailable,
            43 => DeviceStateReason::ModemNotFound,
            44 => DeviceStateReason::BtFailed,
            45 => DeviceStateReason::GsmSimNotInserted,
            46 => DeviceStateReason::GsmSimPinRequired,
            47 => DeviceStateReason::GsmSimPukRequired,
            48 => DeviceStateReason::GsmSimWrong,
            49 => DeviceStateReason::InfinibandMode,
            50 => DeviceStateReason::DependencyFailed,
            51 => DeviceStateReason::Br2684Failed,
            52 => DeviceStateReason::ModemManagerUnavailable,
            53 => DeviceStateReason::SsidNotFound,
            54 => DeviceStateReason::SecondaryConnectionFailed,
            55 => DeviceStateReason::DcbFcoeFailed,
            56 => DeviceStateReason::TeamdControlFailed,
            57 => DeviceStateReason::ModemFailed,
            58 => DeviceStateReason::ModemAvailable,
            59 => DeviceStateReason::SimPinIncorrect,
            60 => DeviceStateReason::NewActivation,
            61 => DeviceStateReason::ParentChanged,
            62 => DeviceStateReason::ParentManagedChanged,
            63 => DeviceStateReason::OvsdbFailed,
            64 => DeviceStateReason::IpAddressDuplicate,
            65 => DeviceStateReason::IpMethodUnsupported,
            66 => DeviceStateReason::SriovConfigurationFailed,
            67 => DeviceStateReason::PeerNotFound,
            value => DeviceStateReason::__Unknown(value),
        }
    }
}

impl StaticType for DeviceStateReason {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_device_state_reason_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DeviceStateReason {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DeviceStateReason {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for DeviceStateReason {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// `DeviceType` values indicate the type of hardware represented by a
/// device object.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum DeviceType {
    Unknown,
    Ethernet,
    Wifi,
    Unused1,
    Unused2,
    Bt,
    OlpcMesh,
    Wimax,
    Modem,
    Infiniband,
    Bond,
    Vlan,
    Adsl,
    Bridge,
    Generic,
    Team,
    Tun,
    IpTunnel,
    Macvlan,
    Vxlan,
    Veth,
    Macsec,
    Dummy,
    Ppp,
    OvsInterface,
    OvsPort,
    OvsBridge,
    Wpan,
    _6lowpan,
    Wireguard,
    WifiP2p,
    Vrf,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DeviceType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DeviceType::{}",
            match *self {
                DeviceType::Unknown => "Unknown",
                DeviceType::Ethernet => "Ethernet",
                DeviceType::Wifi => "Wifi",
                DeviceType::Unused1 => "Unused1",
                DeviceType::Unused2 => "Unused2",
                DeviceType::Bt => "Bt",
                DeviceType::OlpcMesh => "OlpcMesh",
                DeviceType::Wimax => "Wimax",
                DeviceType::Modem => "Modem",
                DeviceType::Infiniband => "Infiniband",
                DeviceType::Bond => "Bond",
                DeviceType::Vlan => "Vlan",
                DeviceType::Adsl => "Adsl",
                DeviceType::Bridge => "Bridge",
                DeviceType::Generic => "Generic",
                DeviceType::Team => "Team",
                DeviceType::Tun => "Tun",
                DeviceType::IpTunnel => "IpTunnel",
                DeviceType::Macvlan => "Macvlan",
                DeviceType::Vxlan => "Vxlan",
                DeviceType::Veth => "Veth",
                DeviceType::Macsec => "Macsec",
                DeviceType::Dummy => "Dummy",
                DeviceType::Ppp => "Ppp",
                DeviceType::OvsInterface => "OvsInterface",
                DeviceType::OvsPort => "OvsPort",
                DeviceType::OvsBridge => "OvsBridge",
                DeviceType::Wpan => "Wpan",
                DeviceType::_6lowpan => "_6lowpan",
                DeviceType::Wireguard => "Wireguard",
                DeviceType::WifiP2p => "WifiP2p",
                DeviceType::Vrf => "Vrf",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for DeviceType {
    type GlibType = nm_sys::NMDeviceType;

    fn to_glib(&self) -> nm_sys::NMDeviceType {
        match *self {
            DeviceType::Unknown => nm_sys::NM_DEVICE_TYPE_UNKNOWN,
            DeviceType::Ethernet => nm_sys::NM_DEVICE_TYPE_ETHERNET,
            DeviceType::Wifi => nm_sys::NM_DEVICE_TYPE_WIFI,
            DeviceType::Unused1 => nm_sys::NM_DEVICE_TYPE_UNUSED1,
            DeviceType::Unused2 => nm_sys::NM_DEVICE_TYPE_UNUSED2,
            DeviceType::Bt => nm_sys::NM_DEVICE_TYPE_BT,
            DeviceType::OlpcMesh => nm_sys::NM_DEVICE_TYPE_OLPC_MESH,
            DeviceType::Wimax => nm_sys::NM_DEVICE_TYPE_WIMAX,
            DeviceType::Modem => nm_sys::NM_DEVICE_TYPE_MODEM,
            DeviceType::Infiniband => nm_sys::NM_DEVICE_TYPE_INFINIBAND,
            DeviceType::Bond => nm_sys::NM_DEVICE_TYPE_BOND,
            DeviceType::Vlan => nm_sys::NM_DEVICE_TYPE_VLAN,
            DeviceType::Adsl => nm_sys::NM_DEVICE_TYPE_ADSL,
            DeviceType::Bridge => nm_sys::NM_DEVICE_TYPE_BRIDGE,
            DeviceType::Generic => nm_sys::NM_DEVICE_TYPE_GENERIC,
            DeviceType::Team => nm_sys::NM_DEVICE_TYPE_TEAM,
            DeviceType::Tun => nm_sys::NM_DEVICE_TYPE_TUN,
            DeviceType::IpTunnel => nm_sys::NM_DEVICE_TYPE_IP_TUNNEL,
            DeviceType::Macvlan => nm_sys::NM_DEVICE_TYPE_MACVLAN,
            DeviceType::Vxlan => nm_sys::NM_DEVICE_TYPE_VXLAN,
            DeviceType::Veth => nm_sys::NM_DEVICE_TYPE_VETH,
            DeviceType::Macsec => nm_sys::NM_DEVICE_TYPE_MACSEC,
            DeviceType::Dummy => nm_sys::NM_DEVICE_TYPE_DUMMY,
            DeviceType::Ppp => nm_sys::NM_DEVICE_TYPE_PPP,
            DeviceType::OvsInterface => nm_sys::NM_DEVICE_TYPE_OVS_INTERFACE,
            DeviceType::OvsPort => nm_sys::NM_DEVICE_TYPE_OVS_PORT,
            DeviceType::OvsBridge => nm_sys::NM_DEVICE_TYPE_OVS_BRIDGE,
            DeviceType::Wpan => nm_sys::NM_DEVICE_TYPE_WPAN,
            DeviceType::_6lowpan => nm_sys::NM_DEVICE_TYPE_6LOWPAN,
            DeviceType::Wireguard => nm_sys::NM_DEVICE_TYPE_WIREGUARD,
            DeviceType::WifiP2p => nm_sys::NM_DEVICE_TYPE_WIFI_P2P,
            DeviceType::Vrf => nm_sys::NM_DEVICE_TYPE_VRF,
            DeviceType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMDeviceType> for DeviceType {
    fn from_glib(value: nm_sys::NMDeviceType) -> Self {
        match value {
            0 => DeviceType::Unknown,
            1 => DeviceType::Ethernet,
            2 => DeviceType::Wifi,
            3 => DeviceType::Unused1,
            4 => DeviceType::Unused2,
            5 => DeviceType::Bt,
            6 => DeviceType::OlpcMesh,
            7 => DeviceType::Wimax,
            8 => DeviceType::Modem,
            9 => DeviceType::Infiniband,
            10 => DeviceType::Bond,
            11 => DeviceType::Vlan,
            12 => DeviceType::Adsl,
            13 => DeviceType::Bridge,
            14 => DeviceType::Generic,
            15 => DeviceType::Team,
            16 => DeviceType::Tun,
            17 => DeviceType::IpTunnel,
            18 => DeviceType::Macvlan,
            19 => DeviceType::Vxlan,
            20 => DeviceType::Veth,
            21 => DeviceType::Macsec,
            22 => DeviceType::Dummy,
            23 => DeviceType::Ppp,
            24 => DeviceType::OvsInterface,
            25 => DeviceType::OvsPort,
            26 => DeviceType::OvsBridge,
            27 => DeviceType::Wpan,
            28 => DeviceType::_6lowpan,
            29 => DeviceType::Wireguard,
            30 => DeviceType::WifiP2p,
            31 => DeviceType::Vrf,
            value => DeviceType::__Unknown(value),
        }
    }
}

impl StaticType for DeviceType {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_device_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DeviceType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DeviceType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for DeviceType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// The tunneling mode.
#[cfg(any(feature = "v1_2", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum IPTunnelMode {
    Unknown,
    Ipip,
    Gre,
    Sit,
    Isatap,
    Vti,
    Ip6ip6,
    Ipip6,
    Ip6gre,
    Vti6,
    Gretap,
    Ip6gretap,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
impl fmt::Display for IPTunnelMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "IPTunnelMode::{}",
            match *self {
                IPTunnelMode::Unknown => "Unknown",
                IPTunnelMode::Ipip => "Ipip",
                IPTunnelMode::Gre => "Gre",
                IPTunnelMode::Sit => "Sit",
                IPTunnelMode::Isatap => "Isatap",
                IPTunnelMode::Vti => "Vti",
                IPTunnelMode::Ip6ip6 => "Ip6ip6",
                IPTunnelMode::Ipip6 => "Ipip6",
                IPTunnelMode::Ip6gre => "Ip6gre",
                IPTunnelMode::Vti6 => "Vti6",
                IPTunnelMode::Gretap => "Gretap",
                IPTunnelMode::Ip6gretap => "Ip6gretap",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for IPTunnelMode {
    type GlibType = nm_sys::NMIPTunnelMode;

    fn to_glib(&self) -> nm_sys::NMIPTunnelMode {
        match *self {
            IPTunnelMode::Unknown => nm_sys::NM_IP_TUNNEL_MODE_UNKNOWN,
            IPTunnelMode::Ipip => nm_sys::NM_IP_TUNNEL_MODE_IPIP,
            IPTunnelMode::Gre => nm_sys::NM_IP_TUNNEL_MODE_GRE,
            IPTunnelMode::Sit => nm_sys::NM_IP_TUNNEL_MODE_SIT,
            IPTunnelMode::Isatap => nm_sys::NM_IP_TUNNEL_MODE_ISATAP,
            IPTunnelMode::Vti => nm_sys::NM_IP_TUNNEL_MODE_VTI,
            IPTunnelMode::Ip6ip6 => nm_sys::NM_IP_TUNNEL_MODE_IP6IP6,
            IPTunnelMode::Ipip6 => nm_sys::NM_IP_TUNNEL_MODE_IPIP6,
            IPTunnelMode::Ip6gre => nm_sys::NM_IP_TUNNEL_MODE_IP6GRE,
            IPTunnelMode::Vti6 => nm_sys::NM_IP_TUNNEL_MODE_VTI6,
            IPTunnelMode::Gretap => nm_sys::NM_IP_TUNNEL_MODE_GRETAP,
            IPTunnelMode::Ip6gretap => nm_sys::NM_IP_TUNNEL_MODE_IP6GRETAP,
            IPTunnelMode::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMIPTunnelMode> for IPTunnelMode {
    fn from_glib(value: nm_sys::NMIPTunnelMode) -> Self {
        match value {
            0 => IPTunnelMode::Unknown,
            1 => IPTunnelMode::Ipip,
            2 => IPTunnelMode::Gre,
            3 => IPTunnelMode::Sit,
            4 => IPTunnelMode::Isatap,
            5 => IPTunnelMode::Vti,
            6 => IPTunnelMode::Ip6ip6,
            7 => IPTunnelMode::Ipip6,
            8 => IPTunnelMode::Ip6gre,
            9 => IPTunnelMode::Vti6,
            10 => IPTunnelMode::Gretap,
            11 => IPTunnelMode::Ip6gretap,
            value => IPTunnelMode::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
impl StaticType for IPTunnelMode {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_ip_tunnel_mode_get_type()) }
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
impl<'a> FromValueOptional<'a> for IPTunnelMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
impl<'a> FromValue<'a> for IPTunnelMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
impl SetValue for IPTunnelMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// Errors related to the main "network management" interface of NetworkManager.
/// These may be returned from `Client` methods that invoke D-Bus operations on
/// the "org.freedesktop.NetworkManager" interface, and correspond to D-Bus
/// errors in that namespace.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ManagerError {
    Failed,
    PermissionDenied,
    UnknownConnection,
    UnknownDevice,
    ConnectionNotAvailable,
    ConnectionNotActive,
    ConnectionAlreadyActive,
    DependencyFailed,
    AlreadyAsleepOrAwake,
    AlreadyEnabledOrDisabled,
    UnknownLogLevel,
    UnknownLogDomain,
    InvalidArguments,
    MissingPlugin,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ManagerError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ManagerError::{}",
            match *self {
                ManagerError::Failed => "Failed",
                ManagerError::PermissionDenied => "PermissionDenied",
                ManagerError::UnknownConnection => "UnknownConnection",
                ManagerError::UnknownDevice => "UnknownDevice",
                ManagerError::ConnectionNotAvailable => "ConnectionNotAvailable",
                ManagerError::ConnectionNotActive => "ConnectionNotActive",
                ManagerError::ConnectionAlreadyActive => "ConnectionAlreadyActive",
                ManagerError::DependencyFailed => "DependencyFailed",
                ManagerError::AlreadyAsleepOrAwake => "AlreadyAsleepOrAwake",
                ManagerError::AlreadyEnabledOrDisabled => "AlreadyEnabledOrDisabled",
                ManagerError::UnknownLogLevel => "UnknownLogLevel",
                ManagerError::UnknownLogDomain => "UnknownLogDomain",
                ManagerError::InvalidArguments => "InvalidArguments",
                ManagerError::MissingPlugin => "MissingPlugin",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ManagerError {
    type GlibType = nm_sys::NMManagerError;

    fn to_glib(&self) -> nm_sys::NMManagerError {
        match *self {
            ManagerError::Failed => nm_sys::NM_MANAGER_ERROR_FAILED,
            ManagerError::PermissionDenied => nm_sys::NM_MANAGER_ERROR_PERMISSION_DENIED,
            ManagerError::UnknownConnection => nm_sys::NM_MANAGER_ERROR_UNKNOWN_CONNECTION,
            ManagerError::UnknownDevice => nm_sys::NM_MANAGER_ERROR_UNKNOWN_DEVICE,
            ManagerError::ConnectionNotAvailable => {
                nm_sys::NM_MANAGER_ERROR_CONNECTION_NOT_AVAILABLE
            }
            ManagerError::ConnectionNotActive => nm_sys::NM_MANAGER_ERROR_CONNECTION_NOT_ACTIVE,
            ManagerError::ConnectionAlreadyActive => {
                nm_sys::NM_MANAGER_ERROR_CONNECTION_ALREADY_ACTIVE
            }
            ManagerError::DependencyFailed => nm_sys::NM_MANAGER_ERROR_DEPENDENCY_FAILED,
            ManagerError::AlreadyAsleepOrAwake => nm_sys::NM_MANAGER_ERROR_ALREADY_ASLEEP_OR_AWAKE,
            ManagerError::AlreadyEnabledOrDisabled => {
                nm_sys::NM_MANAGER_ERROR_ALREADY_ENABLED_OR_DISABLED
            }
            ManagerError::UnknownLogLevel => nm_sys::NM_MANAGER_ERROR_UNKNOWN_LOG_LEVEL,
            ManagerError::UnknownLogDomain => nm_sys::NM_MANAGER_ERROR_UNKNOWN_LOG_DOMAIN,
            ManagerError::InvalidArguments => nm_sys::NM_MANAGER_ERROR_INVALID_ARGUMENTS,
            ManagerError::MissingPlugin => nm_sys::NM_MANAGER_ERROR_MISSING_PLUGIN,
            ManagerError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMManagerError> for ManagerError {
    fn from_glib(value: nm_sys::NMManagerError) -> Self {
        match value {
            0 => ManagerError::Failed,
            1 => ManagerError::PermissionDenied,
            2 => ManagerError::UnknownConnection,
            3 => ManagerError::UnknownDevice,
            4 => ManagerError::ConnectionNotAvailable,
            5 => ManagerError::ConnectionNotActive,
            6 => ManagerError::ConnectionAlreadyActive,
            7 => ManagerError::DependencyFailed,
            8 => ManagerError::AlreadyAsleepOrAwake,
            9 => ManagerError::AlreadyEnabledOrDisabled,
            10 => ManagerError::UnknownLogLevel,
            11 => ManagerError::UnknownLogDomain,
            12 => ManagerError::InvalidArguments,
            13 => ManagerError::MissingPlugin,
            value => ManagerError::__Unknown(value),
        }
    }
}

impl ErrorDomain for ManagerError {
    fn domain() -> Quark {
        unsafe { from_glib(nm_sys::nm_manager_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            0 => Some(ManagerError::Failed),
            1 => Some(ManagerError::PermissionDenied),
            2 => Some(ManagerError::UnknownConnection),
            3 => Some(ManagerError::UnknownDevice),
            4 => Some(ManagerError::ConnectionNotAvailable),
            5 => Some(ManagerError::ConnectionNotActive),
            6 => Some(ManagerError::ConnectionAlreadyActive),
            7 => Some(ManagerError::DependencyFailed),
            8 => Some(ManagerError::AlreadyAsleepOrAwake),
            9 => Some(ManagerError::AlreadyEnabledOrDisabled),
            10 => Some(ManagerError::UnknownLogLevel),
            11 => Some(ManagerError::UnknownLogDomain),
            12 => Some(ManagerError::InvalidArguments),
            13 => Some(ManagerError::MissingPlugin),
            _ => Some(ManagerError::Failed),
        }
    }
}

impl StaticType for ManagerError {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_manager_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ManagerError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ManagerError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ManagerError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// The NMMetered enum has two different purposes: one is to configure
/// "connection.metered" setting of a connection profile in `SettingConnection`, and
/// the other is to express the actual metered state of the `Device` at a given moment.
///
/// For the connection profile only `Metered::Unknown`, `Metered::No`
/// and `Metered::Yes` are allowed.
///
/// The device's metered state at runtime is determined by the profile
/// which is currently active. If the profile explicitly specifies `Metered::No`
/// or `Metered::Yes`, then the device's metered state is as such.
/// If the connection profile leaves it undecided at `Metered::Unknown` (the default),
/// then NetworkManager tries to guess the metered state, for example based on the
/// device type or on DHCP options (like Android devices exposing a "ANDROID_METERED"
/// DHCP vendor option). This then leads to either `Metered::GuessNo` or `Metered::GuessYes`.
///
/// Most applications probably should treat the runtime state `Metered::GuessYes`
/// like `Metered::Yes`, and all other states as not metered.
///
/// Note that the per-device metered states are then combined to a global metered
/// state. This is basically the metered state of the device with the best default
/// route. However, that generalization of a global metered state may not be correct
/// if the default routes for IPv4 and IPv6 are on different devices, or if policy
/// routing is configured. In general, the global metered state tries to express whether
/// the traffic is likely metered, but since that depends on the traffic itself,
/// there is not one answer in all cases. Hence, an application may want to consider
/// the per-device's metered states.
#[cfg(any(feature = "v1_2", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum Metered {
    Unknown,
    Yes,
    No,
    GuessYes,
    GuessNo,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
impl fmt::Display for Metered {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Metered::{}",
            match *self {
                Metered::Unknown => "Unknown",
                Metered::Yes => "Yes",
                Metered::No => "No",
                Metered::GuessYes => "GuessYes",
                Metered::GuessNo => "GuessNo",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for Metered {
    type GlibType = nm_sys::NMMetered;

    fn to_glib(&self) -> nm_sys::NMMetered {
        match *self {
            Metered::Unknown => nm_sys::NM_METERED_UNKNOWN,
            Metered::Yes => nm_sys::NM_METERED_YES,
            Metered::No => nm_sys::NM_METERED_NO,
            Metered::GuessYes => nm_sys::NM_METERED_GUESS_YES,
            Metered::GuessNo => nm_sys::NM_METERED_GUESS_NO,
            Metered::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMMetered> for Metered {
    fn from_glib(value: nm_sys::NMMetered) -> Self {
        match value {
            0 => Metered::Unknown,
            1 => Metered::Yes,
            2 => Metered::No,
            3 => Metered::GuessYes,
            4 => Metered::GuessNo,
            value => Metered::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
impl StaticType for Metered {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_metered_get_type()) }
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
impl<'a> FromValueOptional<'a> for Metered {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
impl<'a> FromValue<'a> for Metered {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
impl SetValue for Metered {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// The result of a checkpoint Rollback() operation for a specific device.
#[cfg(any(feature = "v1_4", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum RollbackResult {
    Ok,
    ErrNoDevice,
    ErrDeviceUnmanaged,
    ErrFailed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_4", feature = "dox"))]
impl fmt::Display for RollbackResult {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "RollbackResult::{}",
            match *self {
                RollbackResult::Ok => "Ok",
                RollbackResult::ErrNoDevice => "ErrNoDevice",
                RollbackResult::ErrDeviceUnmanaged => "ErrDeviceUnmanaged",
                RollbackResult::ErrFailed => "ErrFailed",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_4", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for RollbackResult {
    type GlibType = nm_sys::NMRollbackResult;

    fn to_glib(&self) -> nm_sys::NMRollbackResult {
        match *self {
            RollbackResult::Ok => nm_sys::NM_ROLLBACK_RESULT_OK,
            RollbackResult::ErrNoDevice => nm_sys::NM_ROLLBACK_RESULT_ERR_NO_DEVICE,
            RollbackResult::ErrDeviceUnmanaged => nm_sys::NM_ROLLBACK_RESULT_ERR_DEVICE_UNMANAGED,
            RollbackResult::ErrFailed => nm_sys::NM_ROLLBACK_RESULT_ERR_FAILED,
            RollbackResult::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_4", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMRollbackResult> for RollbackResult {
    fn from_glib(value: nm_sys::NMRollbackResult) -> Self {
        match value {
            0 => RollbackResult::Ok,
            1 => RollbackResult::ErrNoDevice,
            2 => RollbackResult::ErrDeviceUnmanaged,
            3 => RollbackResult::ErrFailed,
            value => RollbackResult::__Unknown(value),
        }
    }
}

/// `SecretAgentError` values are passed by secret agents back to NetworkManager
/// when they encounter problems retrieving secrets on behalf of NM. They
/// correspond to errors in the "org.freedesktop.NetworkManager.SecretManager"
/// namespace.
///
/// Client APIs such as `nm_client_activate_connection` will not see these error
/// codes; instead, the secret agent manager will translate them to the
/// corresponding `AgentManagerError` codes.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SecretAgentError {
    Failed,
    PermissionDenied,
    InvalidConnection,
    UserCanceled,
    AgentCanceled,
    NoSecrets,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SecretAgentError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SecretAgentError::{}",
            match *self {
                SecretAgentError::Failed => "Failed",
                SecretAgentError::PermissionDenied => "PermissionDenied",
                SecretAgentError::InvalidConnection => "InvalidConnection",
                SecretAgentError::UserCanceled => "UserCanceled",
                SecretAgentError::AgentCanceled => "AgentCanceled",
                SecretAgentError::NoSecrets => "NoSecrets",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SecretAgentError {
    type GlibType = nm_sys::NMSecretAgentError;

    fn to_glib(&self) -> nm_sys::NMSecretAgentError {
        match *self {
            SecretAgentError::Failed => nm_sys::NM_SECRET_AGENT_ERROR_FAILED,
            SecretAgentError::PermissionDenied => nm_sys::NM_SECRET_AGENT_ERROR_PERMISSION_DENIED,
            SecretAgentError::InvalidConnection => nm_sys::NM_SECRET_AGENT_ERROR_INVALID_CONNECTION,
            SecretAgentError::UserCanceled => nm_sys::NM_SECRET_AGENT_ERROR_USER_CANCELED,
            SecretAgentError::AgentCanceled => nm_sys::NM_SECRET_AGENT_ERROR_AGENT_CANCELED,
            SecretAgentError::NoSecrets => nm_sys::NM_SECRET_AGENT_ERROR_NO_SECRETS,
            SecretAgentError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMSecretAgentError> for SecretAgentError {
    fn from_glib(value: nm_sys::NMSecretAgentError) -> Self {
        match value {
            0 => SecretAgentError::Failed,
            1 => SecretAgentError::PermissionDenied,
            2 => SecretAgentError::InvalidConnection,
            3 => SecretAgentError::UserCanceled,
            4 => SecretAgentError::AgentCanceled,
            5 => SecretAgentError::NoSecrets,
            value => SecretAgentError::__Unknown(value),
        }
    }
}

impl ErrorDomain for SecretAgentError {
    fn domain() -> Quark {
        unsafe { from_glib(nm_sys::nm_secret_agent_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            0 => Some(SecretAgentError::Failed),
            1 => Some(SecretAgentError::PermissionDenied),
            2 => Some(SecretAgentError::InvalidConnection),
            3 => Some(SecretAgentError::UserCanceled),
            4 => Some(SecretAgentError::AgentCanceled),
            5 => Some(SecretAgentError::NoSecrets),
            _ => Some(SecretAgentError::Failed),
        }
    }
}

impl StaticType for SecretAgentError {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_secret_agent_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SecretAgentError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SecretAgentError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SecretAgentError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// `Setting8021xCKFormat` values indicate the general type of a certificate
/// or private key
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum Setting8021xCKFormat {
    Unknown,
    X509,
    RawKey,
    Pkcs12,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Setting8021xCKFormat {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Setting8021xCKFormat::{}",
            match *self {
                Setting8021xCKFormat::Unknown => "Unknown",
                Setting8021xCKFormat::X509 => "X509",
                Setting8021xCKFormat::RawKey => "RawKey",
                Setting8021xCKFormat::Pkcs12 => "Pkcs12",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for Setting8021xCKFormat {
    type GlibType = nm_sys::NMSetting8021xCKFormat;

    fn to_glib(&self) -> nm_sys::NMSetting8021xCKFormat {
        match *self {
            Setting8021xCKFormat::Unknown => nm_sys::NM_SETTING_802_1X_CK_FORMAT_UNKNOWN,
            Setting8021xCKFormat::X509 => nm_sys::NM_SETTING_802_1X_CK_FORMAT_X509,
            Setting8021xCKFormat::RawKey => nm_sys::NM_SETTING_802_1X_CK_FORMAT_RAW_KEY,
            Setting8021xCKFormat::Pkcs12 => nm_sys::NM_SETTING_802_1X_CK_FORMAT_PKCS12,
            Setting8021xCKFormat::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMSetting8021xCKFormat> for Setting8021xCKFormat {
    fn from_glib(value: nm_sys::NMSetting8021xCKFormat) -> Self {
        match value {
            0 => Setting8021xCKFormat::Unknown,
            1 => Setting8021xCKFormat::X509,
            2 => Setting8021xCKFormat::RawKey,
            3 => Setting8021xCKFormat::Pkcs12,
            value => Setting8021xCKFormat::__Unknown(value),
        }
    }
}

impl StaticType for Setting8021xCKFormat {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_802_1x_ck_format_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Setting8021xCKFormat {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Setting8021xCKFormat {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Setting8021xCKFormat {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// `Setting8021xCKScheme` values indicate how a certificate or private key is
/// stored in the setting properties, either as a blob of the item's data, or as
/// a path to a certificate or private key file on the filesystem
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum Setting8021xCKScheme {
    Unknown,
    Blob,
    Path,
    Pkcs11,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Setting8021xCKScheme {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Setting8021xCKScheme::{}",
            match *self {
                Setting8021xCKScheme::Unknown => "Unknown",
                Setting8021xCKScheme::Blob => "Blob",
                Setting8021xCKScheme::Path => "Path",
                Setting8021xCKScheme::Pkcs11 => "Pkcs11",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for Setting8021xCKScheme {
    type GlibType = nm_sys::NMSetting8021xCKScheme;

    fn to_glib(&self) -> nm_sys::NMSetting8021xCKScheme {
        match *self {
            Setting8021xCKScheme::Unknown => nm_sys::NM_SETTING_802_1X_CK_SCHEME_UNKNOWN,
            Setting8021xCKScheme::Blob => nm_sys::NM_SETTING_802_1X_CK_SCHEME_BLOB,
            Setting8021xCKScheme::Path => nm_sys::NM_SETTING_802_1X_CK_SCHEME_PATH,
            Setting8021xCKScheme::Pkcs11 => nm_sys::NM_SETTING_802_1X_CK_SCHEME_PKCS11,
            Setting8021xCKScheme::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMSetting8021xCKScheme> for Setting8021xCKScheme {
    fn from_glib(value: nm_sys::NMSetting8021xCKScheme) -> Self {
        match value {
            0 => Setting8021xCKScheme::Unknown,
            1 => Setting8021xCKScheme::Blob,
            2 => Setting8021xCKScheme::Path,
            3 => Setting8021xCKScheme::Pkcs11,
            value => Setting8021xCKScheme::__Unknown(value),
        }
    }
}

impl StaticType for Setting8021xCKScheme {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_802_1x_ck_scheme_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Setting8021xCKScheme {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Setting8021xCKScheme {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Setting8021xCKScheme {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// These flags modify the comparison behavior when comparing two settings or
/// two connections.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SettingCompareFlags {
    Exact,
    Fuzzy,
    IgnoreId,
    IgnoreSecrets,
    IgnoreAgentOwnedSecrets,
    IgnoreNotSavedSecrets,
    DiffResultWithDefault,
    DiffResultNoDefault,
    IgnoreTimestamp,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SettingCompareFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingCompareFlags::{}",
            match *self {
                SettingCompareFlags::Exact => "Exact",
                SettingCompareFlags::Fuzzy => "Fuzzy",
                SettingCompareFlags::IgnoreId => "IgnoreId",
                SettingCompareFlags::IgnoreSecrets => "IgnoreSecrets",
                SettingCompareFlags::IgnoreAgentOwnedSecrets => "IgnoreAgentOwnedSecrets",
                SettingCompareFlags::IgnoreNotSavedSecrets => "IgnoreNotSavedSecrets",
                SettingCompareFlags::DiffResultWithDefault => "DiffResultWithDefault",
                SettingCompareFlags::DiffResultNoDefault => "DiffResultNoDefault",
                SettingCompareFlags::IgnoreTimestamp => "IgnoreTimestamp",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SettingCompareFlags {
    type GlibType = nm_sys::NMSettingCompareFlags;

    fn to_glib(&self) -> nm_sys::NMSettingCompareFlags {
        match *self {
            SettingCompareFlags::Exact => nm_sys::NM_SETTING_COMPARE_FLAG_EXACT,
            SettingCompareFlags::Fuzzy => nm_sys::NM_SETTING_COMPARE_FLAG_FUZZY,
            SettingCompareFlags::IgnoreId => nm_sys::NM_SETTING_COMPARE_FLAG_IGNORE_ID,
            SettingCompareFlags::IgnoreSecrets => nm_sys::NM_SETTING_COMPARE_FLAG_IGNORE_SECRETS,
            SettingCompareFlags::IgnoreAgentOwnedSecrets => {
                nm_sys::NM_SETTING_COMPARE_FLAG_IGNORE_AGENT_OWNED_SECRETS
            }
            SettingCompareFlags::IgnoreNotSavedSecrets => {
                nm_sys::NM_SETTING_COMPARE_FLAG_IGNORE_NOT_SAVED_SECRETS
            }
            SettingCompareFlags::DiffResultWithDefault => {
                nm_sys::NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT
            }
            SettingCompareFlags::DiffResultNoDefault => {
                nm_sys::NM_SETTING_COMPARE_FLAG_DIFF_RESULT_NO_DEFAULT
            }
            SettingCompareFlags::IgnoreTimestamp => {
                nm_sys::NM_SETTING_COMPARE_FLAG_IGNORE_TIMESTAMP
            }
            SettingCompareFlags::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingCompareFlags> for SettingCompareFlags {
    fn from_glib(value: nm_sys::NMSettingCompareFlags) -> Self {
        match value {
            0 => SettingCompareFlags::Exact,
            1 => SettingCompareFlags::Fuzzy,
            2 => SettingCompareFlags::IgnoreId,
            4 => SettingCompareFlags::IgnoreSecrets,
            8 => SettingCompareFlags::IgnoreAgentOwnedSecrets,
            16 => SettingCompareFlags::IgnoreNotSavedSecrets,
            32 => SettingCompareFlags::DiffResultWithDefault,
            64 => SettingCompareFlags::DiffResultNoDefault,
            128 => SettingCompareFlags::IgnoreTimestamp,
            value => SettingCompareFlags::__Unknown(value),
        }
    }
}

impl StaticType for SettingCompareFlags {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_compare_flags_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SettingCompareFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SettingCompareFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SettingCompareFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// `SettingConnectionAutoconnectSlaves` values indicate whether slave connections
/// should be activated when master is activated.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SettingConnectionAutoconnectSlaves {
    Default,
    No,
    Yes,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SettingConnectionAutoconnectSlaves {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingConnectionAutoconnectSlaves::{}",
            match *self {
                SettingConnectionAutoconnectSlaves::Default => "Default",
                SettingConnectionAutoconnectSlaves::No => "No",
                SettingConnectionAutoconnectSlaves::Yes => "Yes",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SettingConnectionAutoconnectSlaves {
    type GlibType = nm_sys::NMSettingConnectionAutoconnectSlaves;

    fn to_glib(&self) -> nm_sys::NMSettingConnectionAutoconnectSlaves {
        match *self {
            SettingConnectionAutoconnectSlaves::Default => {
                nm_sys::NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_DEFAULT
            }
            SettingConnectionAutoconnectSlaves::No => {
                nm_sys::NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_NO
            }
            SettingConnectionAutoconnectSlaves::Yes => {
                nm_sys::NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_YES
            }
            SettingConnectionAutoconnectSlaves::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingConnectionAutoconnectSlaves> for SettingConnectionAutoconnectSlaves {
    fn from_glib(value: nm_sys::NMSettingConnectionAutoconnectSlaves) -> Self {
        match value {
            -1 => SettingConnectionAutoconnectSlaves::Default,
            0 => SettingConnectionAutoconnectSlaves::No,
            1 => SettingConnectionAutoconnectSlaves::Yes,
            value => SettingConnectionAutoconnectSlaves::__Unknown(value),
        }
    }
}

impl StaticType for SettingConnectionAutoconnectSlaves {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_connection_autoconnect_slaves_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SettingConnectionAutoconnectSlaves {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SettingConnectionAutoconnectSlaves {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SettingConnectionAutoconnectSlaves {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// `SettingConnectionLldp` values indicate whether LLDP should be enabled.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SettingConnectionLldp {
    Default,
    Disable,
    EnableRx,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SettingConnectionLldp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingConnectionLldp::{}",
            match *self {
                SettingConnectionLldp::Default => "Default",
                SettingConnectionLldp::Disable => "Disable",
                SettingConnectionLldp::EnableRx => "EnableRx",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SettingConnectionLldp {
    type GlibType = nm_sys::NMSettingConnectionLldp;

    fn to_glib(&self) -> nm_sys::NMSettingConnectionLldp {
        match *self {
            SettingConnectionLldp::Default => nm_sys::NM_SETTING_CONNECTION_LLDP_DEFAULT,
            SettingConnectionLldp::Disable => nm_sys::NM_SETTING_CONNECTION_LLDP_DISABLE,
            SettingConnectionLldp::EnableRx => nm_sys::NM_SETTING_CONNECTION_LLDP_ENABLE_RX,
            SettingConnectionLldp::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingConnectionLldp> for SettingConnectionLldp {
    fn from_glib(value: nm_sys::NMSettingConnectionLldp) -> Self {
        match value {
            -1 => SettingConnectionLldp::Default,
            0 => SettingConnectionLldp::Disable,
            1 => SettingConnectionLldp::EnableRx,
            value => SettingConnectionLldp::__Unknown(value),
        }
    }
}

impl StaticType for SettingConnectionLldp {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_connection_lldp_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SettingConnectionLldp {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SettingConnectionLldp {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SettingConnectionLldp {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// `SettingConnectionLlmnr` values indicate whether LLMNR should be enabled.
#[cfg(any(feature = "v1_14", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SettingConnectionLlmnr {
    Default,
    No,
    Resolve,
    Yes,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
impl fmt::Display for SettingConnectionLlmnr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingConnectionLlmnr::{}",
            match *self {
                SettingConnectionLlmnr::Default => "Default",
                SettingConnectionLlmnr::No => "No",
                SettingConnectionLlmnr::Resolve => "Resolve",
                SettingConnectionLlmnr::Yes => "Yes",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for SettingConnectionLlmnr {
    type GlibType = nm_sys::NMSettingConnectionLlmnr;

    fn to_glib(&self) -> nm_sys::NMSettingConnectionLlmnr {
        match *self {
            SettingConnectionLlmnr::Default => nm_sys::NM_SETTING_CONNECTION_LLMNR_DEFAULT,
            SettingConnectionLlmnr::No => nm_sys::NM_SETTING_CONNECTION_LLMNR_NO,
            SettingConnectionLlmnr::Resolve => nm_sys::NM_SETTING_CONNECTION_LLMNR_RESOLVE,
            SettingConnectionLlmnr::Yes => nm_sys::NM_SETTING_CONNECTION_LLMNR_YES,
            SettingConnectionLlmnr::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingConnectionLlmnr> for SettingConnectionLlmnr {
    fn from_glib(value: nm_sys::NMSettingConnectionLlmnr) -> Self {
        match value {
            -1 => SettingConnectionLlmnr::Default,
            0 => SettingConnectionLlmnr::No,
            1 => SettingConnectionLlmnr::Resolve,
            2 => SettingConnectionLlmnr::Yes,
            value => SettingConnectionLlmnr::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
impl StaticType for SettingConnectionLlmnr {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_connection_llmnr_get_type()) }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
impl<'a> FromValueOptional<'a> for SettingConnectionLlmnr {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
impl<'a> FromValue<'a> for SettingConnectionLlmnr {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
impl SetValue for SettingConnectionLlmnr {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// `SettingConnectionMdns` values indicate whether mDNS should be enabled.
#[cfg(any(feature = "v1_12", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SettingConnectionMdns {
    Default,
    No,
    Resolve,
    Yes,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl fmt::Display for SettingConnectionMdns {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingConnectionMdns::{}",
            match *self {
                SettingConnectionMdns::Default => "Default",
                SettingConnectionMdns::No => "No",
                SettingConnectionMdns::Resolve => "Resolve",
                SettingConnectionMdns::Yes => "Yes",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for SettingConnectionMdns {
    type GlibType = nm_sys::NMSettingConnectionMdns;

    fn to_glib(&self) -> nm_sys::NMSettingConnectionMdns {
        match *self {
            SettingConnectionMdns::Default => nm_sys::NM_SETTING_CONNECTION_MDNS_DEFAULT,
            SettingConnectionMdns::No => nm_sys::NM_SETTING_CONNECTION_MDNS_NO,
            SettingConnectionMdns::Resolve => nm_sys::NM_SETTING_CONNECTION_MDNS_RESOLVE,
            SettingConnectionMdns::Yes => nm_sys::NM_SETTING_CONNECTION_MDNS_YES,
            SettingConnectionMdns::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingConnectionMdns> for SettingConnectionMdns {
    fn from_glib(value: nm_sys::NMSettingConnectionMdns) -> Self {
        match value {
            -1 => SettingConnectionMdns::Default,
            0 => SettingConnectionMdns::No,
            1 => SettingConnectionMdns::Resolve,
            2 => SettingConnectionMdns::Yes,
            value => SettingConnectionMdns::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl StaticType for SettingConnectionMdns {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_connection_mdns_get_type()) }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl<'a> FromValueOptional<'a> for SettingConnectionMdns {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl<'a> FromValue<'a> for SettingConnectionMdns {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl SetValue for SettingConnectionMdns {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// These values indicate the result of a setting difference operation.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SettingDiffResult {
    Unknown,
    InA,
    InB,
    InADefault,
    InBDefault,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SettingDiffResult {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingDiffResult::{}",
            match *self {
                SettingDiffResult::Unknown => "Unknown",
                SettingDiffResult::InA => "InA",
                SettingDiffResult::InB => "InB",
                SettingDiffResult::InADefault => "InADefault",
                SettingDiffResult::InBDefault => "InBDefault",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SettingDiffResult {
    type GlibType = nm_sys::NMSettingDiffResult;

    fn to_glib(&self) -> nm_sys::NMSettingDiffResult {
        match *self {
            SettingDiffResult::Unknown => nm_sys::NM_SETTING_DIFF_RESULT_UNKNOWN,
            SettingDiffResult::InA => nm_sys::NM_SETTING_DIFF_RESULT_IN_A,
            SettingDiffResult::InB => nm_sys::NM_SETTING_DIFF_RESULT_IN_B,
            SettingDiffResult::InADefault => nm_sys::NM_SETTING_DIFF_RESULT_IN_A_DEFAULT,
            SettingDiffResult::InBDefault => nm_sys::NM_SETTING_DIFF_RESULT_IN_B_DEFAULT,
            SettingDiffResult::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingDiffResult> for SettingDiffResult {
    fn from_glib(value: nm_sys::NMSettingDiffResult) -> Self {
        match value {
            0 => SettingDiffResult::Unknown,
            1 => SettingDiffResult::InA,
            2 => SettingDiffResult::InB,
            4 => SettingDiffResult::InADefault,
            8 => SettingDiffResult::InBDefault,
            value => SettingDiffResult::__Unknown(value),
        }
    }
}

impl StaticType for SettingDiffResult {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_diff_result_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SettingDiffResult {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SettingDiffResult {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SettingDiffResult {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// `SettingIP6ConfigAddrGenMode` controls how the Interface Identifier for
/// RFC4862 Stateless Address Autoconfiguration is created.
#[cfg(any(feature = "v1_2", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SettingIP6ConfigAddrGenMode {
    Eui64,
    StablePrivacy,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
impl fmt::Display for SettingIP6ConfigAddrGenMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingIP6ConfigAddrGenMode::{}",
            match *self {
                SettingIP6ConfigAddrGenMode::Eui64 => "Eui64",
                SettingIP6ConfigAddrGenMode::StablePrivacy => "StablePrivacy",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for SettingIP6ConfigAddrGenMode {
    type GlibType = nm_sys::NMSettingIP6ConfigAddrGenMode;

    fn to_glib(&self) -> nm_sys::NMSettingIP6ConfigAddrGenMode {
        match *self {
            SettingIP6ConfigAddrGenMode::Eui64 => nm_sys::NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64,
            SettingIP6ConfigAddrGenMode::StablePrivacy => {
                nm_sys::NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY
            }
            SettingIP6ConfigAddrGenMode::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingIP6ConfigAddrGenMode> for SettingIP6ConfigAddrGenMode {
    fn from_glib(value: nm_sys::NMSettingIP6ConfigAddrGenMode) -> Self {
        match value {
            0 => SettingIP6ConfigAddrGenMode::Eui64,
            1 => SettingIP6ConfigAddrGenMode::StablePrivacy,
            value => SettingIP6ConfigAddrGenMode::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
impl StaticType for SettingIP6ConfigAddrGenMode {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_ip6_config_addr_gen_mode_get_type()) }
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
impl<'a> FromValueOptional<'a> for SettingIP6ConfigAddrGenMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
impl<'a> FromValue<'a> for SettingIP6ConfigAddrGenMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
impl SetValue for SettingIP6ConfigAddrGenMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// `SettingIP6ConfigPrivacy` values indicate if and how IPv6 Privacy
/// Extensions are used (RFC4941).
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SettingIP6ConfigPrivacy {
    Unknown,
    Disabled,
    PreferPublicAddr,
    PreferTempAddr,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SettingIP6ConfigPrivacy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingIP6ConfigPrivacy::{}",
            match *self {
                SettingIP6ConfigPrivacy::Unknown => "Unknown",
                SettingIP6ConfigPrivacy::Disabled => "Disabled",
                SettingIP6ConfigPrivacy::PreferPublicAddr => "PreferPublicAddr",
                SettingIP6ConfigPrivacy::PreferTempAddr => "PreferTempAddr",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SettingIP6ConfigPrivacy {
    type GlibType = nm_sys::NMSettingIP6ConfigPrivacy;

    fn to_glib(&self) -> nm_sys::NMSettingIP6ConfigPrivacy {
        match *self {
            SettingIP6ConfigPrivacy::Unknown => nm_sys::NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN,
            SettingIP6ConfigPrivacy::Disabled => nm_sys::NM_SETTING_IP6_CONFIG_PRIVACY_DISABLED,
            SettingIP6ConfigPrivacy::PreferPublicAddr => {
                nm_sys::NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR
            }
            SettingIP6ConfigPrivacy::PreferTempAddr => {
                nm_sys::NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR
            }
            SettingIP6ConfigPrivacy::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingIP6ConfigPrivacy> for SettingIP6ConfigPrivacy {
    fn from_glib(value: nm_sys::NMSettingIP6ConfigPrivacy) -> Self {
        match value {
            -1 => SettingIP6ConfigPrivacy::Unknown,
            0 => SettingIP6ConfigPrivacy::Disabled,
            1 => SettingIP6ConfigPrivacy::PreferPublicAddr,
            2 => SettingIP6ConfigPrivacy::PreferTempAddr,
            value => SettingIP6ConfigPrivacy::__Unknown(value),
        }
    }
}

impl StaticType for SettingIP6ConfigPrivacy {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_ip6_config_privacy_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SettingIP6ConfigPrivacy {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SettingIP6ConfigPrivacy {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SettingIP6ConfigPrivacy {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// Controls if and how the MAC address of a device is randomzied.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SettingMacRandomization {
    Default,
    Never,
    Always,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SettingMacRandomization {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingMacRandomization::{}",
            match *self {
                SettingMacRandomization::Default => "Default",
                SettingMacRandomization::Never => "Never",
                SettingMacRandomization::Always => "Always",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SettingMacRandomization {
    type GlibType = nm_sys::NMSettingMacRandomization;

    fn to_glib(&self) -> nm_sys::NMSettingMacRandomization {
        match *self {
            SettingMacRandomization::Default => nm_sys::NM_SETTING_MAC_RANDOMIZATION_DEFAULT,
            SettingMacRandomization::Never => nm_sys::NM_SETTING_MAC_RANDOMIZATION_NEVER,
            SettingMacRandomization::Always => nm_sys::NM_SETTING_MAC_RANDOMIZATION_ALWAYS,
            SettingMacRandomization::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingMacRandomization> for SettingMacRandomization {
    fn from_glib(value: nm_sys::NMSettingMacRandomization) -> Self {
        match value {
            0 => SettingMacRandomization::Default,
            1 => SettingMacRandomization::Never,
            2 => SettingMacRandomization::Always,
            value => SettingMacRandomization::__Unknown(value),
        }
    }
}

impl StaticType for SettingMacRandomization {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_mac_randomization_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SettingMacRandomization {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SettingMacRandomization {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SettingMacRandomization {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// `SettingMacsecMode` controls how the CAK (Connectivity Association Key) used
/// in MKA (MACsec Key Agreement) is obtained.
#[cfg(any(feature = "v1_6", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SettingMacsecMode {
    Psk,
    Eap,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl fmt::Display for SettingMacsecMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingMacsecMode::{}",
            match *self {
                SettingMacsecMode::Psk => "Psk",
                SettingMacsecMode::Eap => "Eap",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for SettingMacsecMode {
    type GlibType = nm_sys::NMSettingMacsecMode;

    fn to_glib(&self) -> nm_sys::NMSettingMacsecMode {
        match *self {
            SettingMacsecMode::Psk => nm_sys::NM_SETTING_MACSEC_MODE_PSK,
            SettingMacsecMode::Eap => nm_sys::NM_SETTING_MACSEC_MODE_EAP,
            SettingMacsecMode::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingMacsecMode> for SettingMacsecMode {
    fn from_glib(value: nm_sys::NMSettingMacsecMode) -> Self {
        match value {
            0 => SettingMacsecMode::Psk,
            1 => SettingMacsecMode::Eap,
            value => SettingMacsecMode::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl StaticType for SettingMacsecMode {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_macsec_mode_get_type()) }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl<'a> FromValueOptional<'a> for SettingMacsecMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl<'a> FromValue<'a> for SettingMacsecMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl SetValue for SettingMacsecMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// `SettingMacsecValidation` specifies a validation mode for incoming frames.
#[cfg(any(feature = "v1_6", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SettingMacsecValidation {
    Disable,
    Check,
    Strict,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl fmt::Display for SettingMacsecValidation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingMacsecValidation::{}",
            match *self {
                SettingMacsecValidation::Disable => "Disable",
                SettingMacsecValidation::Check => "Check",
                SettingMacsecValidation::Strict => "Strict",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for SettingMacsecValidation {
    type GlibType = nm_sys::NMSettingMacsecValidation;

    fn to_glib(&self) -> nm_sys::NMSettingMacsecValidation {
        match *self {
            SettingMacsecValidation::Disable => nm_sys::NM_SETTING_MACSEC_VALIDATION_DISABLE,
            SettingMacsecValidation::Check => nm_sys::NM_SETTING_MACSEC_VALIDATION_CHECK,
            SettingMacsecValidation::Strict => nm_sys::NM_SETTING_MACSEC_VALIDATION_STRICT,
            SettingMacsecValidation::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingMacsecValidation> for SettingMacsecValidation {
    fn from_glib(value: nm_sys::NMSettingMacsecValidation) -> Self {
        match value {
            0 => SettingMacsecValidation::Disable,
            1 => SettingMacsecValidation::Check,
            2 => SettingMacsecValidation::Strict,
            value => SettingMacsecValidation::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl StaticType for SettingMacsecValidation {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_macsec_validation_get_type()) }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl<'a> FromValueOptional<'a> for SettingMacsecValidation {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl<'a> FromValue<'a> for SettingMacsecValidation {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl SetValue for SettingMacsecValidation {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SettingMacvlanMode {
    Unknown,
    Vepa,
    Bridge,
    Private,
    Passthru,
    Source,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SettingMacvlanMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingMacvlanMode::{}",
            match *self {
                SettingMacvlanMode::Unknown => "Unknown",
                SettingMacvlanMode::Vepa => "Vepa",
                SettingMacvlanMode::Bridge => "Bridge",
                SettingMacvlanMode::Private => "Private",
                SettingMacvlanMode::Passthru => "Passthru",
                SettingMacvlanMode::Source => "Source",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SettingMacvlanMode {
    type GlibType = nm_sys::NMSettingMacvlanMode;

    fn to_glib(&self) -> nm_sys::NMSettingMacvlanMode {
        match *self {
            SettingMacvlanMode::Unknown => nm_sys::NM_SETTING_MACVLAN_MODE_UNKNOWN,
            SettingMacvlanMode::Vepa => nm_sys::NM_SETTING_MACVLAN_MODE_VEPA,
            SettingMacvlanMode::Bridge => nm_sys::NM_SETTING_MACVLAN_MODE_BRIDGE,
            SettingMacvlanMode::Private => nm_sys::NM_SETTING_MACVLAN_MODE_PRIVATE,
            SettingMacvlanMode::Passthru => nm_sys::NM_SETTING_MACVLAN_MODE_PASSTHRU,
            SettingMacvlanMode::Source => nm_sys::NM_SETTING_MACVLAN_MODE_SOURCE,
            SettingMacvlanMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingMacvlanMode> for SettingMacvlanMode {
    fn from_glib(value: nm_sys::NMSettingMacvlanMode) -> Self {
        match value {
            0 => SettingMacvlanMode::Unknown,
            1 => SettingMacvlanMode::Vepa,
            2 => SettingMacvlanMode::Bridge,
            3 => SettingMacvlanMode::Private,
            4 => SettingMacvlanMode::Passthru,
            5 => SettingMacvlanMode::Source,
            value => SettingMacvlanMode::__Unknown(value),
        }
    }
}

impl StaticType for SettingMacvlanMode {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_macvlan_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SettingMacvlanMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SettingMacvlanMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SettingMacvlanMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// The Proxy method.
#[cfg(any(feature = "v1_6", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SettingProxyMethod {
    None,
    Auto,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl fmt::Display for SettingProxyMethod {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingProxyMethod::{}",
            match *self {
                SettingProxyMethod::None => "None",
                SettingProxyMethod::Auto => "Auto",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for SettingProxyMethod {
    type GlibType = nm_sys::NMSettingProxyMethod;

    fn to_glib(&self) -> nm_sys::NMSettingProxyMethod {
        match *self {
            SettingProxyMethod::None => nm_sys::NM_SETTING_PROXY_METHOD_NONE,
            SettingProxyMethod::Auto => nm_sys::NM_SETTING_PROXY_METHOD_AUTO,
            SettingProxyMethod::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingProxyMethod> for SettingProxyMethod {
    fn from_glib(value: nm_sys::NMSettingProxyMethod) -> Self {
        match value {
            0 => SettingProxyMethod::None,
            1 => SettingProxyMethod::Auto,
            value => SettingProxyMethod::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl StaticType for SettingProxyMethod {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_proxy_method_get_type()) }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl<'a> FromValueOptional<'a> for SettingProxyMethod {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl<'a> FromValue<'a> for SettingProxyMethod {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl SetValue for SettingProxyMethod {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// The parity setting of a serial port.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SettingSerialParity {
    None,
    Even,
    Odd,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SettingSerialParity {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingSerialParity::{}",
            match *self {
                SettingSerialParity::None => "None",
                SettingSerialParity::Even => "Even",
                SettingSerialParity::Odd => "Odd",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SettingSerialParity {
    type GlibType = nm_sys::NMSettingSerialParity;

    fn to_glib(&self) -> nm_sys::NMSettingSerialParity {
        match *self {
            SettingSerialParity::None => nm_sys::NM_SETTING_SERIAL_PARITY_NONE,
            SettingSerialParity::Even => nm_sys::NM_SETTING_SERIAL_PARITY_EVEN,
            SettingSerialParity::Odd => nm_sys::NM_SETTING_SERIAL_PARITY_ODD,
            SettingSerialParity::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingSerialParity> for SettingSerialParity {
    fn from_glib(value: nm_sys::NMSettingSerialParity) -> Self {
        match value {
            0 => SettingSerialParity::None,
            1 => SettingSerialParity::Even,
            2 => SettingSerialParity::Odd,
            value => SettingSerialParity::__Unknown(value),
        }
    }
}

impl StaticType for SettingSerialParity {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_serial_parity_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SettingSerialParity {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SettingSerialParity {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SettingSerialParity {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// `SettingTunMode` values indicate the device type (TUN/TAP)
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SettingTunMode {
    Unknown,
    Tun,
    Tap,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SettingTunMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingTunMode::{}",
            match *self {
                SettingTunMode::Unknown => "Unknown",
                SettingTunMode::Tun => "Tun",
                SettingTunMode::Tap => "Tap",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SettingTunMode {
    type GlibType = nm_sys::NMSettingTunMode;

    fn to_glib(&self) -> nm_sys::NMSettingTunMode {
        match *self {
            SettingTunMode::Unknown => nm_sys::NM_SETTING_TUN_MODE_UNKNOWN,
            SettingTunMode::Tun => nm_sys::NM_SETTING_TUN_MODE_TUN,
            SettingTunMode::Tap => nm_sys::NM_SETTING_TUN_MODE_TAP,
            SettingTunMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingTunMode> for SettingTunMode {
    fn from_glib(value: nm_sys::NMSettingTunMode) -> Self {
        match value {
            0 => SettingTunMode::Unknown,
            1 => SettingTunMode::Tun,
            2 => SettingTunMode::Tap,
            value => SettingTunMode::__Unknown(value),
        }
    }
}

impl StaticType for SettingTunMode {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_tun_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SettingTunMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SettingTunMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SettingTunMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// These flags indicate whether wireless powersave must be enabled.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SettingWirelessPowersave {
    Default,
    Ignore,
    Disable,
    Enable,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SettingWirelessPowersave {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingWirelessPowersave::{}",
            match *self {
                SettingWirelessPowersave::Default => "Default",
                SettingWirelessPowersave::Ignore => "Ignore",
                SettingWirelessPowersave::Disable => "Disable",
                SettingWirelessPowersave::Enable => "Enable",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SettingWirelessPowersave {
    type GlibType = nm_sys::NMSettingWirelessPowersave;

    fn to_glib(&self) -> nm_sys::NMSettingWirelessPowersave {
        match *self {
            SettingWirelessPowersave::Default => nm_sys::NM_SETTING_WIRELESS_POWERSAVE_DEFAULT,
            SettingWirelessPowersave::Ignore => nm_sys::NM_SETTING_WIRELESS_POWERSAVE_IGNORE,
            SettingWirelessPowersave::Disable => nm_sys::NM_SETTING_WIRELESS_POWERSAVE_DISABLE,
            SettingWirelessPowersave::Enable => nm_sys::NM_SETTING_WIRELESS_POWERSAVE_ENABLE,
            SettingWirelessPowersave::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingWirelessPowersave> for SettingWirelessPowersave {
    fn from_glib(value: nm_sys::NMSettingWirelessPowersave) -> Self {
        match value {
            0 => SettingWirelessPowersave::Default,
            1 => SettingWirelessPowersave::Ignore,
            2 => SettingWirelessPowersave::Disable,
            3 => SettingWirelessPowersave::Enable,
            value => SettingWirelessPowersave::__Unknown(value),
        }
    }
}

impl StaticType for SettingWirelessPowersave {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_wireless_powersave_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SettingWirelessPowersave {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SettingWirelessPowersave {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SettingWirelessPowersave {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// These flags indicate whether FILS must be enabled.
#[cfg(any(feature = "v1_12", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SettingWirelessSecurityFils {
    Default,
    Disable,
    Optional,
    Required,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl fmt::Display for SettingWirelessSecurityFils {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingWirelessSecurityFils::{}",
            match *self {
                SettingWirelessSecurityFils::Default => "Default",
                SettingWirelessSecurityFils::Disable => "Disable",
                SettingWirelessSecurityFils::Optional => "Optional",
                SettingWirelessSecurityFils::Required => "Required",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for SettingWirelessSecurityFils {
    type GlibType = nm_sys::NMSettingWirelessSecurityFils;

    fn to_glib(&self) -> nm_sys::NMSettingWirelessSecurityFils {
        match *self {
            SettingWirelessSecurityFils::Default => {
                nm_sys::NM_SETTING_WIRELESS_SECURITY_FILS_DEFAULT
            }
            SettingWirelessSecurityFils::Disable => {
                nm_sys::NM_SETTING_WIRELESS_SECURITY_FILS_DISABLE
            }
            SettingWirelessSecurityFils::Optional => {
                nm_sys::NM_SETTING_WIRELESS_SECURITY_FILS_OPTIONAL
            }
            SettingWirelessSecurityFils::Required => {
                nm_sys::NM_SETTING_WIRELESS_SECURITY_FILS_REQUIRED
            }
            SettingWirelessSecurityFils::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingWirelessSecurityFils> for SettingWirelessSecurityFils {
    fn from_glib(value: nm_sys::NMSettingWirelessSecurityFils) -> Self {
        match value {
            0 => SettingWirelessSecurityFils::Default,
            1 => SettingWirelessSecurityFils::Disable,
            2 => SettingWirelessSecurityFils::Optional,
            3 => SettingWirelessSecurityFils::Required,
            value => SettingWirelessSecurityFils::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl StaticType for SettingWirelessSecurityFils {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_wireless_security_fils_get_type()) }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl<'a> FromValueOptional<'a> for SettingWirelessSecurityFils {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl<'a> FromValue<'a> for SettingWirelessSecurityFils {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl SetValue for SettingWirelessSecurityFils {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// These flags indicate whether PMF must be enabled.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SettingWirelessSecurityPmf {
    Default,
    Disable,
    Optional,
    Required,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SettingWirelessSecurityPmf {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingWirelessSecurityPmf::{}",
            match *self {
                SettingWirelessSecurityPmf::Default => "Default",
                SettingWirelessSecurityPmf::Disable => "Disable",
                SettingWirelessSecurityPmf::Optional => "Optional",
                SettingWirelessSecurityPmf::Required => "Required",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SettingWirelessSecurityPmf {
    type GlibType = nm_sys::NMSettingWirelessSecurityPmf;

    fn to_glib(&self) -> nm_sys::NMSettingWirelessSecurityPmf {
        match *self {
            SettingWirelessSecurityPmf::Default => nm_sys::NM_SETTING_WIRELESS_SECURITY_PMF_DEFAULT,
            SettingWirelessSecurityPmf::Disable => nm_sys::NM_SETTING_WIRELESS_SECURITY_PMF_DISABLE,
            SettingWirelessSecurityPmf::Optional => {
                nm_sys::NM_SETTING_WIRELESS_SECURITY_PMF_OPTIONAL
            }
            SettingWirelessSecurityPmf::Required => {
                nm_sys::NM_SETTING_WIRELESS_SECURITY_PMF_REQUIRED
            }
            SettingWirelessSecurityPmf::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingWirelessSecurityPmf> for SettingWirelessSecurityPmf {
    fn from_glib(value: nm_sys::NMSettingWirelessSecurityPmf) -> Self {
        match value {
            0 => SettingWirelessSecurityPmf::Default,
            1 => SettingWirelessSecurityPmf::Disable,
            2 => SettingWirelessSecurityPmf::Optional,
            3 => SettingWirelessSecurityPmf::Required,
            value => SettingWirelessSecurityPmf::__Unknown(value),
        }
    }
}

impl StaticType for SettingWirelessSecurityPmf {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_wireless_security_pmf_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SettingWirelessSecurityPmf {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SettingWirelessSecurityPmf {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SettingWirelessSecurityPmf {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// Errors related to the settings/persistent configuration interface of
/// NetworkManager.
///
/// These may be returned from `Client` methods that invoke D-Bus operations on
/// the "org.freedesktop.NetworkManager.Settings" interface, and correspond to
/// D-Bus errors in that namespace.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SettingsError {
    Failed,
    PermissionDenied,
    NotSupported,
    InvalidConnection,
    ReadOnlyConnection,
    UuidExists,
    InvalidHostname,
    InvalidArguments,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SettingsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SettingsError::{}",
            match *self {
                SettingsError::Failed => "Failed",
                SettingsError::PermissionDenied => "PermissionDenied",
                SettingsError::NotSupported => "NotSupported",
                SettingsError::InvalidConnection => "InvalidConnection",
                SettingsError::ReadOnlyConnection => "ReadOnlyConnection",
                SettingsError::UuidExists => "UuidExists",
                SettingsError::InvalidHostname => "InvalidHostname",
                SettingsError::InvalidArguments => "InvalidArguments",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SettingsError {
    type GlibType = nm_sys::NMSettingsError;

    fn to_glib(&self) -> nm_sys::NMSettingsError {
        match *self {
            SettingsError::Failed => nm_sys::NM_SETTINGS_ERROR_FAILED,
            SettingsError::PermissionDenied => nm_sys::NM_SETTINGS_ERROR_PERMISSION_DENIED,
            SettingsError::NotSupported => nm_sys::NM_SETTINGS_ERROR_NOT_SUPPORTED,
            SettingsError::InvalidConnection => nm_sys::NM_SETTINGS_ERROR_INVALID_CONNECTION,
            SettingsError::ReadOnlyConnection => nm_sys::NM_SETTINGS_ERROR_READ_ONLY_CONNECTION,
            SettingsError::UuidExists => nm_sys::NM_SETTINGS_ERROR_UUID_EXISTS,
            SettingsError::InvalidHostname => nm_sys::NM_SETTINGS_ERROR_INVALID_HOSTNAME,
            SettingsError::InvalidArguments => nm_sys::NM_SETTINGS_ERROR_INVALID_ARGUMENTS,
            SettingsError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingsError> for SettingsError {
    fn from_glib(value: nm_sys::NMSettingsError) -> Self {
        match value {
            0 => SettingsError::Failed,
            1 => SettingsError::PermissionDenied,
            2 => SettingsError::NotSupported,
            3 => SettingsError::InvalidConnection,
            4 => SettingsError::ReadOnlyConnection,
            5 => SettingsError::UuidExists,
            6 => SettingsError::InvalidHostname,
            7 => SettingsError::InvalidArguments,
            value => SettingsError::__Unknown(value),
        }
    }
}

impl ErrorDomain for SettingsError {
    fn domain() -> Quark {
        unsafe { from_glib(nm_sys::nm_settings_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            0 => Some(SettingsError::Failed),
            1 => Some(SettingsError::PermissionDenied),
            2 => Some(SettingsError::NotSupported),
            3 => Some(SettingsError::InvalidConnection),
            4 => Some(SettingsError::ReadOnlyConnection),
            5 => Some(SettingsError::UuidExists),
            6 => Some(SettingsError::InvalidHostname),
            7 => Some(SettingsError::InvalidArguments),
            _ => Some(SettingsError::Failed),
        }
    }
}

impl StaticType for SettingsError {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_settings_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SettingsError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SettingsError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SettingsError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// `SriovVFVlanProtocol` indicates the VLAN protocol to use.
#[cfg(any(feature = "v1_14", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SriovVFVlanProtocol {
    _1q,
    _1ad,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
impl fmt::Display for SriovVFVlanProtocol {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SriovVFVlanProtocol::{}",
            match *self {
                SriovVFVlanProtocol::_1q => "_1q",
                SriovVFVlanProtocol::_1ad => "_1ad",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for SriovVFVlanProtocol {
    type GlibType = nm_sys::NMSriovVFVlanProtocol;

    fn to_glib(&self) -> nm_sys::NMSriovVFVlanProtocol {
        match *self {
            SriovVFVlanProtocol::_1q => nm_sys::NM_SRIOV_VF_VLAN_PROTOCOL_802_1Q,
            SriovVFVlanProtocol::_1ad => nm_sys::NM_SRIOV_VF_VLAN_PROTOCOL_802_1AD,
            SriovVFVlanProtocol::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMSriovVFVlanProtocol> for SriovVFVlanProtocol {
    fn from_glib(value: nm_sys::NMSriovVFVlanProtocol) -> Self {
        match value {
            0 => SriovVFVlanProtocol::_1q,
            1 => SriovVFVlanProtocol::_1ad,
            value => SriovVFVlanProtocol::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
impl StaticType for SriovVFVlanProtocol {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_sriov_vf_vlan_protocol_get_type()) }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
impl<'a> FromValueOptional<'a> for SriovVFVlanProtocol {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
impl<'a> FromValue<'a> for SriovVFVlanProtocol {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
impl SetValue for SriovVFVlanProtocol {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// `State` values indicate the current overall networking state.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum State {
    Unknown,
    Asleep,
    Disconnected,
    Disconnecting,
    Connecting,
    ConnectedLocal,
    ConnectedSite,
    ConnectedGlobal,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for State {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "State::{}",
            match *self {
                State::Unknown => "Unknown",
                State::Asleep => "Asleep",
                State::Disconnected => "Disconnected",
                State::Disconnecting => "Disconnecting",
                State::Connecting => "Connecting",
                State::ConnectedLocal => "ConnectedLocal",
                State::ConnectedSite => "ConnectedSite",
                State::ConnectedGlobal => "ConnectedGlobal",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for State {
    type GlibType = nm_sys::NMState;

    fn to_glib(&self) -> nm_sys::NMState {
        match *self {
            State::Unknown => nm_sys::NM_STATE_UNKNOWN,
            State::Asleep => nm_sys::NM_STATE_ASLEEP,
            State::Disconnected => nm_sys::NM_STATE_DISCONNECTED,
            State::Disconnecting => nm_sys::NM_STATE_DISCONNECTING,
            State::Connecting => nm_sys::NM_STATE_CONNECTING,
            State::ConnectedLocal => nm_sys::NM_STATE_CONNECTED_LOCAL,
            State::ConnectedSite => nm_sys::NM_STATE_CONNECTED_SITE,
            State::ConnectedGlobal => nm_sys::NM_STATE_CONNECTED_GLOBAL,
            State::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMState> for State {
    fn from_glib(value: nm_sys::NMState) -> Self {
        match value {
            0 => State::Unknown,
            10 => State::Asleep,
            20 => State::Disconnected,
            30 => State::Disconnecting,
            40 => State::Connecting,
            50 => State::ConnectedLocal,
            60 => State::ConnectedSite,
            70 => State::ConnectedGlobal,
            value => State::__Unknown(value),
        }
    }
}

impl StaticType for State {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_state_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for State {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for State {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for State {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// An boolean value that can be overridden by a default.
#[cfg(any(feature = "v1_14", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum Ternary {
    Default,
    False,
    True,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
impl fmt::Display for Ternary {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Ternary::{}",
            match *self {
                Ternary::Default => "Default",
                Ternary::False => "False",
                Ternary::True => "True",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for Ternary {
    type GlibType = nm_sys::NMTernary;

    fn to_glib(&self) -> nm_sys::NMTernary {
        match *self {
            Ternary::Default => nm_sys::NM_TERNARY_DEFAULT,
            Ternary::False => nm_sys::NM_TERNARY_FALSE,
            Ternary::True => nm_sys::NM_TERNARY_TRUE,
            Ternary::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMTernary> for Ternary {
    fn from_glib(value: nm_sys::NMTernary) -> Self {
        match value {
            -1 => Ternary::Default,
            0 => Ternary::False,
            1 => Ternary::True,
            value => Ternary::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
impl StaticType for Ternary {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_ternary_get_type()) }
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
impl<'a> FromValueOptional<'a> for Ternary {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
impl<'a> FromValue<'a> for Ternary {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_14", feature = "dox"))]
impl SetValue for Ternary {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// Describes generic security mechanisms that 802.11 access points may offer.
/// Used with `nm_utils_security_valid` for checking whether a given access
/// point is compatible with a network device.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum UtilsSecurityType {
    Invalid,
    None,
    StaticWep,
    Leap,
    DynamicWep,
    WpaPsk,
    WpaEnterprise,
    Wpa2Psk,
    Wpa2Enterprise,
    Sae,
    Owe,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for UtilsSecurityType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "UtilsSecurityType::{}",
            match *self {
                UtilsSecurityType::Invalid => "Invalid",
                UtilsSecurityType::None => "None",
                UtilsSecurityType::StaticWep => "StaticWep",
                UtilsSecurityType::Leap => "Leap",
                UtilsSecurityType::DynamicWep => "DynamicWep",
                UtilsSecurityType::WpaPsk => "WpaPsk",
                UtilsSecurityType::WpaEnterprise => "WpaEnterprise",
                UtilsSecurityType::Wpa2Psk => "Wpa2Psk",
                UtilsSecurityType::Wpa2Enterprise => "Wpa2Enterprise",
                UtilsSecurityType::Sae => "Sae",
                UtilsSecurityType::Owe => "Owe",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for UtilsSecurityType {
    type GlibType = nm_sys::NMUtilsSecurityType;

    fn to_glib(&self) -> nm_sys::NMUtilsSecurityType {
        match *self {
            UtilsSecurityType::Invalid => nm_sys::NMU_SEC_INVALID,
            UtilsSecurityType::None => nm_sys::NMU_SEC_NONE,
            UtilsSecurityType::StaticWep => nm_sys::NMU_SEC_STATIC_WEP,
            UtilsSecurityType::Leap => nm_sys::NMU_SEC_LEAP,
            UtilsSecurityType::DynamicWep => nm_sys::NMU_SEC_DYNAMIC_WEP,
            UtilsSecurityType::WpaPsk => nm_sys::NMU_SEC_WPA_PSK,
            UtilsSecurityType::WpaEnterprise => nm_sys::NMU_SEC_WPA_ENTERPRISE,
            UtilsSecurityType::Wpa2Psk => nm_sys::NMU_SEC_WPA2_PSK,
            UtilsSecurityType::Wpa2Enterprise => nm_sys::NMU_SEC_WPA2_ENTERPRISE,
            UtilsSecurityType::Sae => nm_sys::NMU_SEC_SAE,
            UtilsSecurityType::Owe => nm_sys::NMU_SEC_OWE,
            UtilsSecurityType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMUtilsSecurityType> for UtilsSecurityType {
    fn from_glib(value: nm_sys::NMUtilsSecurityType) -> Self {
        match value {
            0 => UtilsSecurityType::Invalid,
            1 => UtilsSecurityType::None,
            2 => UtilsSecurityType::StaticWep,
            3 => UtilsSecurityType::Leap,
            4 => UtilsSecurityType::DynamicWep,
            5 => UtilsSecurityType::WpaPsk,
            6 => UtilsSecurityType::WpaEnterprise,
            7 => UtilsSecurityType::Wpa2Psk,
            8 => UtilsSecurityType::Wpa2Enterprise,
            9 => UtilsSecurityType::Sae,
            10 => UtilsSecurityType::Owe,
            value => UtilsSecurityType::__Unknown(value),
        }
    }
}

impl StaticType for UtilsSecurityType {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_utils_security_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for UtilsSecurityType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for UtilsSecurityType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for UtilsSecurityType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// A selector for traffic priority maps; these map Linux SKB priorities
/// to 802.1p priorities used in VLANs.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum VlanPriorityMap {
    IngressMap,
    EgressMap,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for VlanPriorityMap {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "VlanPriorityMap::{}",
            match *self {
                VlanPriorityMap::IngressMap => "IngressMap",
                VlanPriorityMap::EgressMap => "EgressMap",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for VlanPriorityMap {
    type GlibType = nm_sys::NMVlanPriorityMap;

    fn to_glib(&self) -> nm_sys::NMVlanPriorityMap {
        match *self {
            VlanPriorityMap::IngressMap => nm_sys::NM_VLAN_INGRESS_MAP,
            VlanPriorityMap::EgressMap => nm_sys::NM_VLAN_EGRESS_MAP,
            VlanPriorityMap::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMVlanPriorityMap> for VlanPriorityMap {
    fn from_glib(value: nm_sys::NMVlanPriorityMap) -> Self {
        match value {
            0 => VlanPriorityMap::IngressMap,
            1 => VlanPriorityMap::EgressMap,
            value => VlanPriorityMap::__Unknown(value),
        }
    }
}

impl StaticType for VlanPriorityMap {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_vlan_priority_map_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for VlanPriorityMap {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for VlanPriorityMap {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for VlanPriorityMap {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// VPN connection states
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum VpnConnectionState {
    Unknown,
    Prepare,
    NeedAuth,
    Connect,
    IpConfigGet,
    Activated,
    Failed,
    Disconnected,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for VpnConnectionState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "VpnConnectionState::{}",
            match *self {
                VpnConnectionState::Unknown => "Unknown",
                VpnConnectionState::Prepare => "Prepare",
                VpnConnectionState::NeedAuth => "NeedAuth",
                VpnConnectionState::Connect => "Connect",
                VpnConnectionState::IpConfigGet => "IpConfigGet",
                VpnConnectionState::Activated => "Activated",
                VpnConnectionState::Failed => "Failed",
                VpnConnectionState::Disconnected => "Disconnected",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for VpnConnectionState {
    type GlibType = nm_sys::NMVpnConnectionState;

    fn to_glib(&self) -> nm_sys::NMVpnConnectionState {
        match *self {
            VpnConnectionState::Unknown => nm_sys::NM_VPN_CONNECTION_STATE_UNKNOWN,
            VpnConnectionState::Prepare => nm_sys::NM_VPN_CONNECTION_STATE_PREPARE,
            VpnConnectionState::NeedAuth => nm_sys::NM_VPN_CONNECTION_STATE_NEED_AUTH,
            VpnConnectionState::Connect => nm_sys::NM_VPN_CONNECTION_STATE_CONNECT,
            VpnConnectionState::IpConfigGet => nm_sys::NM_VPN_CONNECTION_STATE_IP_CONFIG_GET,
            VpnConnectionState::Activated => nm_sys::NM_VPN_CONNECTION_STATE_ACTIVATED,
            VpnConnectionState::Failed => nm_sys::NM_VPN_CONNECTION_STATE_FAILED,
            VpnConnectionState::Disconnected => nm_sys::NM_VPN_CONNECTION_STATE_DISCONNECTED,
            VpnConnectionState::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMVpnConnectionState> for VpnConnectionState {
    fn from_glib(value: nm_sys::NMVpnConnectionState) -> Self {
        match value {
            0 => VpnConnectionState::Unknown,
            1 => VpnConnectionState::Prepare,
            2 => VpnConnectionState::NeedAuth,
            3 => VpnConnectionState::Connect,
            4 => VpnConnectionState::IpConfigGet,
            5 => VpnConnectionState::Activated,
            6 => VpnConnectionState::Failed,
            7 => VpnConnectionState::Disconnected,
            value => VpnConnectionState::__Unknown(value),
        }
    }
}

impl StaticType for VpnConnectionState {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_vpn_connection_state_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for VpnConnectionState {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for VpnConnectionState {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for VpnConnectionState {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// VPN connection state reasons
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum VpnConnectionStateReason {
    Unknown,
    None,
    UserDisconnected,
    DeviceDisconnected,
    ServiceStopped,
    IpConfigInvalid,
    ConnectTimeout,
    ServiceStartTimeout,
    ServiceStartFailed,
    NoSecrets,
    LoginFailed,
    ConnectionRemoved,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for VpnConnectionStateReason {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "VpnConnectionStateReason::{}",
            match *self {
                VpnConnectionStateReason::Unknown => "Unknown",
                VpnConnectionStateReason::None => "None",
                VpnConnectionStateReason::UserDisconnected => "UserDisconnected",
                VpnConnectionStateReason::DeviceDisconnected => "DeviceDisconnected",
                VpnConnectionStateReason::ServiceStopped => "ServiceStopped",
                VpnConnectionStateReason::IpConfigInvalid => "IpConfigInvalid",
                VpnConnectionStateReason::ConnectTimeout => "ConnectTimeout",
                VpnConnectionStateReason::ServiceStartTimeout => "ServiceStartTimeout",
                VpnConnectionStateReason::ServiceStartFailed => "ServiceStartFailed",
                VpnConnectionStateReason::NoSecrets => "NoSecrets",
                VpnConnectionStateReason::LoginFailed => "LoginFailed",
                VpnConnectionStateReason::ConnectionRemoved => "ConnectionRemoved",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for VpnConnectionStateReason {
    type GlibType = nm_sys::NMVpnConnectionStateReason;

    fn to_glib(&self) -> nm_sys::NMVpnConnectionStateReason {
        match *self {
            VpnConnectionStateReason::Unknown => nm_sys::NM_VPN_CONNECTION_STATE_REASON_UNKNOWN,
            VpnConnectionStateReason::None => nm_sys::NM_VPN_CONNECTION_STATE_REASON_NONE,
            VpnConnectionStateReason::UserDisconnected => {
                nm_sys::NM_VPN_CONNECTION_STATE_REASON_USER_DISCONNECTED
            }
            VpnConnectionStateReason::DeviceDisconnected => {
                nm_sys::NM_VPN_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED
            }
            VpnConnectionStateReason::ServiceStopped => {
                nm_sys::NM_VPN_CONNECTION_STATE_REASON_SERVICE_STOPPED
            }
            VpnConnectionStateReason::IpConfigInvalid => {
                nm_sys::NM_VPN_CONNECTION_STATE_REASON_IP_CONFIG_INVALID
            }
            VpnConnectionStateReason::ConnectTimeout => {
                nm_sys::NM_VPN_CONNECTION_STATE_REASON_CONNECT_TIMEOUT
            }
            VpnConnectionStateReason::ServiceStartTimeout => {
                nm_sys::NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT
            }
            VpnConnectionStateReason::ServiceStartFailed => {
                nm_sys::NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_FAILED
            }
            VpnConnectionStateReason::NoSecrets => {
                nm_sys::NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS
            }
            VpnConnectionStateReason::LoginFailed => {
                nm_sys::NM_VPN_CONNECTION_STATE_REASON_LOGIN_FAILED
            }
            VpnConnectionStateReason::ConnectionRemoved => {
                nm_sys::NM_VPN_CONNECTION_STATE_REASON_CONNECTION_REMOVED
            }
            VpnConnectionStateReason::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMVpnConnectionStateReason> for VpnConnectionStateReason {
    fn from_glib(value: nm_sys::NMVpnConnectionStateReason) -> Self {
        match value {
            0 => VpnConnectionStateReason::Unknown,
            1 => VpnConnectionStateReason::None,
            2 => VpnConnectionStateReason::UserDisconnected,
            3 => VpnConnectionStateReason::DeviceDisconnected,
            4 => VpnConnectionStateReason::ServiceStopped,
            5 => VpnConnectionStateReason::IpConfigInvalid,
            6 => VpnConnectionStateReason::ConnectTimeout,
            7 => VpnConnectionStateReason::ServiceStartTimeout,
            8 => VpnConnectionStateReason::ServiceStartFailed,
            9 => VpnConnectionStateReason::NoSecrets,
            10 => VpnConnectionStateReason::LoginFailed,
            11 => VpnConnectionStateReason::ConnectionRemoved,
            value => VpnConnectionStateReason::__Unknown(value),
        }
    }
}

impl StaticType for VpnConnectionStateReason {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_vpn_connection_state_reason_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for VpnConnectionStateReason {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for VpnConnectionStateReason {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for VpnConnectionStateReason {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// Returned by the VPN service plugin to indicate errors. These codes correspond
/// to errors in the "org.freedesktop.NetworkManager.VPN.Error" namespace.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum VpnPluginError {
    Failed,
    StartingInProgress,
    AlreadyStarted,
    StoppingInProgress,
    AlreadyStopped,
    WrongState,
    BadArguments,
    LaunchFailed,
    InvalidConnection,
    InteractiveNotSupported,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for VpnPluginError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "VpnPluginError::{}",
            match *self {
                VpnPluginError::Failed => "Failed",
                VpnPluginError::StartingInProgress => "StartingInProgress",
                VpnPluginError::AlreadyStarted => "AlreadyStarted",
                VpnPluginError::StoppingInProgress => "StoppingInProgress",
                VpnPluginError::AlreadyStopped => "AlreadyStopped",
                VpnPluginError::WrongState => "WrongState",
                VpnPluginError::BadArguments => "BadArguments",
                VpnPluginError::LaunchFailed => "LaunchFailed",
                VpnPluginError::InvalidConnection => "InvalidConnection",
                VpnPluginError::InteractiveNotSupported => "InteractiveNotSupported",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for VpnPluginError {
    type GlibType = nm_sys::NMVpnPluginError;

    fn to_glib(&self) -> nm_sys::NMVpnPluginError {
        match *self {
            VpnPluginError::Failed => nm_sys::NM_VPN_PLUGIN_ERROR_FAILED,
            VpnPluginError::StartingInProgress => nm_sys::NM_VPN_PLUGIN_ERROR_STARTING_IN_PROGRESS,
            VpnPluginError::AlreadyStarted => nm_sys::NM_VPN_PLUGIN_ERROR_ALREADY_STARTED,
            VpnPluginError::StoppingInProgress => nm_sys::NM_VPN_PLUGIN_ERROR_STOPPING_IN_PROGRESS,
            VpnPluginError::AlreadyStopped => nm_sys::NM_VPN_PLUGIN_ERROR_ALREADY_STOPPED,
            VpnPluginError::WrongState => nm_sys::NM_VPN_PLUGIN_ERROR_WRONG_STATE,
            VpnPluginError::BadArguments => nm_sys::NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,
            VpnPluginError::LaunchFailed => nm_sys::NM_VPN_PLUGIN_ERROR_LAUNCH_FAILED,
            VpnPluginError::InvalidConnection => nm_sys::NM_VPN_PLUGIN_ERROR_INVALID_CONNECTION,
            VpnPluginError::InteractiveNotSupported => {
                nm_sys::NM_VPN_PLUGIN_ERROR_INTERACTIVE_NOT_SUPPORTED
            }
            VpnPluginError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMVpnPluginError> for VpnPluginError {
    fn from_glib(value: nm_sys::NMVpnPluginError) -> Self {
        match value {
            0 => VpnPluginError::Failed,
            1 => VpnPluginError::StartingInProgress,
            2 => VpnPluginError::AlreadyStarted,
            3 => VpnPluginError::StoppingInProgress,
            4 => VpnPluginError::AlreadyStopped,
            5 => VpnPluginError::WrongState,
            6 => VpnPluginError::BadArguments,
            7 => VpnPluginError::LaunchFailed,
            8 => VpnPluginError::InvalidConnection,
            9 => VpnPluginError::InteractiveNotSupported,
            value => VpnPluginError::__Unknown(value),
        }
    }
}

impl ErrorDomain for VpnPluginError {
    fn domain() -> Quark {
        unsafe { from_glib(nm_sys::nm_vpn_plugin_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            0 => Some(VpnPluginError::Failed),
            1 => Some(VpnPluginError::StartingInProgress),
            2 => Some(VpnPluginError::AlreadyStarted),
            3 => Some(VpnPluginError::StoppingInProgress),
            4 => Some(VpnPluginError::AlreadyStopped),
            5 => Some(VpnPluginError::WrongState),
            6 => Some(VpnPluginError::BadArguments),
            7 => Some(VpnPluginError::LaunchFailed),
            8 => Some(VpnPluginError::InvalidConnection),
            9 => Some(VpnPluginError::InteractiveNotSupported),
            _ => Some(VpnPluginError::Failed),
        }
    }
}

impl StaticType for VpnPluginError {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_vpn_plugin_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for VpnPluginError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for VpnPluginError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for VpnPluginError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// VPN plugin failure reasons
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum VpnPluginFailure {
    LoginFailed,
    ConnectFailed,
    BadIpConfig,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for VpnPluginFailure {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "VpnPluginFailure::{}",
            match *self {
                VpnPluginFailure::LoginFailed => "LoginFailed",
                VpnPluginFailure::ConnectFailed => "ConnectFailed",
                VpnPluginFailure::BadIpConfig => "BadIpConfig",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for VpnPluginFailure {
    type GlibType = nm_sys::NMVpnPluginFailure;

    fn to_glib(&self) -> nm_sys::NMVpnPluginFailure {
        match *self {
            VpnPluginFailure::LoginFailed => nm_sys::NM_VPN_PLUGIN_FAILURE_LOGIN_FAILED,
            VpnPluginFailure::ConnectFailed => nm_sys::NM_VPN_PLUGIN_FAILURE_CONNECT_FAILED,
            VpnPluginFailure::BadIpConfig => nm_sys::NM_VPN_PLUGIN_FAILURE_BAD_IP_CONFIG,
            VpnPluginFailure::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMVpnPluginFailure> for VpnPluginFailure {
    fn from_glib(value: nm_sys::NMVpnPluginFailure) -> Self {
        match value {
            0 => VpnPluginFailure::LoginFailed,
            1 => VpnPluginFailure::ConnectFailed,
            2 => VpnPluginFailure::BadIpConfig,
            value => VpnPluginFailure::__Unknown(value),
        }
    }
}

impl StaticType for VpnPluginFailure {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_vpn_plugin_failure_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for VpnPluginFailure {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for VpnPluginFailure {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for VpnPluginFailure {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// VPN daemon states
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum VpnServiceState {
    Unknown,
    Init,
    Shutdown,
    Starting,
    Started,
    Stopping,
    Stopped,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for VpnServiceState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "VpnServiceState::{}",
            match *self {
                VpnServiceState::Unknown => "Unknown",
                VpnServiceState::Init => "Init",
                VpnServiceState::Shutdown => "Shutdown",
                VpnServiceState::Starting => "Starting",
                VpnServiceState::Started => "Started",
                VpnServiceState::Stopping => "Stopping",
                VpnServiceState::Stopped => "Stopped",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for VpnServiceState {
    type GlibType = nm_sys::NMVpnServiceState;

    fn to_glib(&self) -> nm_sys::NMVpnServiceState {
        match *self {
            VpnServiceState::Unknown => nm_sys::NM_VPN_SERVICE_STATE_UNKNOWN,
            VpnServiceState::Init => nm_sys::NM_VPN_SERVICE_STATE_INIT,
            VpnServiceState::Shutdown => nm_sys::NM_VPN_SERVICE_STATE_SHUTDOWN,
            VpnServiceState::Starting => nm_sys::NM_VPN_SERVICE_STATE_STARTING,
            VpnServiceState::Started => nm_sys::NM_VPN_SERVICE_STATE_STARTED,
            VpnServiceState::Stopping => nm_sys::NM_VPN_SERVICE_STATE_STOPPING,
            VpnServiceState::Stopped => nm_sys::NM_VPN_SERVICE_STATE_STOPPED,
            VpnServiceState::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMVpnServiceState> for VpnServiceState {
    fn from_glib(value: nm_sys::NMVpnServiceState) -> Self {
        match value {
            0 => VpnServiceState::Unknown,
            1 => VpnServiceState::Init,
            2 => VpnServiceState::Shutdown,
            3 => VpnServiceState::Starting,
            4 => VpnServiceState::Started,
            5 => VpnServiceState::Stopping,
            6 => VpnServiceState::Stopped,
            value => VpnServiceState::__Unknown(value),
        }
    }
}

impl StaticType for VpnServiceState {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_vpn_service_state_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for VpnServiceState {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for VpnServiceState {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for VpnServiceState {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// The `WepKeyType` values specify how any WEP keys present in the setting
/// are interpreted. There are no standards governing how to hash the various WEP
/// key/passphrase formats into the actual WEP key. Unfortunately some WEP keys
/// can be interpreted in multiple ways, requiring the setting to specify how to
/// interpret the any WEP keys. For example, the key "732f2d712e4a394a375d366931"
/// is both a valid Hexadecimal WEP key and a WEP passphrase. Further, many
/// ASCII keys are also valid WEP passphrases, but since passphrases and ASCII
/// keys are hashed differently to determine the actual WEP key the type must be
/// specified.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum WepKeyType {
    Unknown,
    Key,
    Passphrase,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for WepKeyType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "WepKeyType::{}",
            match *self {
                WepKeyType::Unknown => "Unknown",
                WepKeyType::Key => "Key",
                WepKeyType::Passphrase => "Passphrase",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for WepKeyType {
    type GlibType = nm_sys::NMWepKeyType;

    fn to_glib(&self) -> nm_sys::NMWepKeyType {
        match *self {
            WepKeyType::Unknown => nm_sys::NM_WEP_KEY_TYPE_UNKNOWN,
            WepKeyType::Key => nm_sys::NM_WEP_KEY_TYPE_KEY,
            WepKeyType::Passphrase => nm_sys::NM_WEP_KEY_TYPE_PASSPHRASE,
            WepKeyType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMWepKeyType> for WepKeyType {
    fn from_glib(value: nm_sys::NMWepKeyType) -> Self {
        match value {
            0 => WepKeyType::Unknown,
            1 => WepKeyType::Key,
            2 => WepKeyType::Passphrase,
            value => WepKeyType::__Unknown(value),
        }
    }
}

impl StaticType for WepKeyType {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_wep_key_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for WepKeyType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for WepKeyType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for WepKeyType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// WiMAX network type.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum WimaxNspNetworkType {
    Unknown,
    Home,
    Partner,
    RoamingPartner,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for WimaxNspNetworkType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "WimaxNspNetworkType::{}",
            match *self {
                WimaxNspNetworkType::Unknown => "Unknown",
                WimaxNspNetworkType::Home => "Home",
                WimaxNspNetworkType::Partner => "Partner",
                WimaxNspNetworkType::RoamingPartner => "RoamingPartner",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for WimaxNspNetworkType {
    type GlibType = nm_sys::NMWimaxNspNetworkType;

    fn to_glib(&self) -> nm_sys::NMWimaxNspNetworkType {
        match *self {
            WimaxNspNetworkType::Unknown => nm_sys::NM_WIMAX_NSP_NETWORK_TYPE_UNKNOWN,
            WimaxNspNetworkType::Home => nm_sys::NM_WIMAX_NSP_NETWORK_TYPE_HOME,
            WimaxNspNetworkType::Partner => nm_sys::NM_WIMAX_NSP_NETWORK_TYPE_PARTNER,
            WimaxNspNetworkType::RoamingPartner => {
                nm_sys::NM_WIMAX_NSP_NETWORK_TYPE_ROAMING_PARTNER
            }
            WimaxNspNetworkType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMWimaxNspNetworkType> for WimaxNspNetworkType {
    fn from_glib(value: nm_sys::NMWimaxNspNetworkType) -> Self {
        match value {
            0 => WimaxNspNetworkType::Unknown,
            1 => WimaxNspNetworkType::Home,
            2 => WimaxNspNetworkType::Partner,
            3 => WimaxNspNetworkType::RoamingPartner,
            value => WimaxNspNetworkType::__Unknown(value),
        }
    }
}

impl StaticType for WimaxNspNetworkType {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_wimax_nsp_network_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for WimaxNspNetworkType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for WimaxNspNetworkType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for WimaxNspNetworkType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

/// Indicates the 802.11 mode an access point or device is currently in.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum _80211Mode {
    Unknown,
    Adhoc,
    Infra,
    Ap,
    Mesh,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for _80211Mode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "_80211Mode::{}",
            match *self {
                _80211Mode::Unknown => "Unknown",
                _80211Mode::Adhoc => "Adhoc",
                _80211Mode::Infra => "Infra",
                _80211Mode::Ap => "Ap",
                _80211Mode::Mesh => "Mesh",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for _80211Mode {
    type GlibType = nm_sys::NM80211Mode;

    fn to_glib(&self) -> nm_sys::NM80211Mode {
        match *self {
            _80211Mode::Unknown => nm_sys::NM_802_11_MODE_UNKNOWN,
            _80211Mode::Adhoc => nm_sys::NM_802_11_MODE_ADHOC,
            _80211Mode::Infra => nm_sys::NM_802_11_MODE_INFRA,
            _80211Mode::Ap => nm_sys::NM_802_11_MODE_AP,
            _80211Mode::Mesh => nm_sys::NM_802_11_MODE_MESH,
            _80211Mode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NM80211Mode> for _80211Mode {
    fn from_glib(value: nm_sys::NM80211Mode) -> Self {
        match value {
            0 => _80211Mode::Unknown,
            1 => _80211Mode::Adhoc,
            2 => _80211Mode::Infra,
            3 => _80211Mode::Ap,
            4 => _80211Mode::Mesh,
            value => _80211Mode::__Unknown(value),
        }
    }
}

impl StaticType for _80211Mode {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_802_11_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for _80211Mode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for _80211Mode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for _80211Mode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}
