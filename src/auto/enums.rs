// This file was generated by gir (https://github.com/gtk-rs/gir @ 464833e)
// from gir-files (https://github.com/gtk-rs/gir-files @ ???)
// DO NOT EDIT

use ffi;
use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::value::Value;
use glib::Quark;
use glib::StaticType;
use glib::Type;
use gobject_ffi;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum _80211Mode {
    Unknown,
    Adhoc,
    Infra,
    Ap,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for _80211Mode {
    type GlibType = ffi::NM80211Mode;

    fn to_glib(&self) -> ffi::NM80211Mode {
        match *self {
            _80211Mode::Unknown => ffi::NM_802_11_MODE_UNKNOWN,
            _80211Mode::Adhoc => ffi::NM_802_11_MODE_ADHOC,
            _80211Mode::Infra => ffi::NM_802_11_MODE_INFRA,
            _80211Mode::Ap => ffi::NM_802_11_MODE_AP,
            _80211Mode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NM80211Mode> for _80211Mode {
    fn from_glib(value: ffi::NM80211Mode) -> Self {
        match value {
            0 => _80211Mode::Unknown,
            1 => _80211Mode::Adhoc,
            2 => _80211Mode::Infra,
            3 => _80211Mode::Ap,
            value => _80211Mode::__Unknown(value),
        }
    }
}

impl StaticType for _80211Mode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_802_11_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for _80211Mode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for _80211Mode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for _80211Mode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum ActiveConnectionState {
    Unknown,
    Activating,
    Activated,
    Deactivating,
    Deactivated,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for ActiveConnectionState {
    type GlibType = ffi::NMActiveConnectionState;

    fn to_glib(&self) -> ffi::NMActiveConnectionState {
        match *self {
            ActiveConnectionState::Unknown => ffi::NM_ACTIVE_CONNECTION_STATE_UNKNOWN,
            ActiveConnectionState::Activating => ffi::NM_ACTIVE_CONNECTION_STATE_ACTIVATING,
            ActiveConnectionState::Activated => ffi::NM_ACTIVE_CONNECTION_STATE_ACTIVATED,
            ActiveConnectionState::Deactivating => ffi::NM_ACTIVE_CONNECTION_STATE_DEACTIVATING,
            ActiveConnectionState::Deactivated => ffi::NM_ACTIVE_CONNECTION_STATE_DEACTIVATED,
            ActiveConnectionState::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMActiveConnectionState> for ActiveConnectionState {
    fn from_glib(value: ffi::NMActiveConnectionState) -> Self {
        match value {
            0 => ActiveConnectionState::Unknown,
            1 => ActiveConnectionState::Activating,
            2 => ActiveConnectionState::Activated,
            3 => ActiveConnectionState::Deactivating,
            4 => ActiveConnectionState::Deactivated,
            value => ActiveConnectionState::__Unknown(value),
        }
    }
}

impl StaticType for ActiveConnectionState {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_active_connection_state_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ActiveConnectionState {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ActiveConnectionState {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ActiveConnectionState {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum ActiveConnectionStateReason {
    Unknown,
    None,
    UserDisconnected,
    DeviceDisconnected,
    ServiceStopped,
    IpConfigInvalid,
    ConnectTimeout,
    ServiceStartTimeout,
    ServiceStartFailed,
    NoSecrets,
    LoginFailed,
    ConnectionRemoved,
    DependencyFailed,
    DeviceRealizeFailed,
    DeviceRemoved,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for ActiveConnectionStateReason {
    type GlibType = ffi::NMActiveConnectionStateReason;

    fn to_glib(&self) -> ffi::NMActiveConnectionStateReason {
        match *self {
            ActiveConnectionStateReason::Unknown => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_UNKNOWN,
            ActiveConnectionStateReason::None => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_NONE,
            ActiveConnectionStateReason::UserDisconnected => {
                ffi::NM_ACTIVE_CONNECTION_STATE_REASON_USER_DISCONNECTED
            }
            ActiveConnectionStateReason::DeviceDisconnected => {
                ffi::NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED
            }
            ActiveConnectionStateReason::ServiceStopped => {
                ffi::NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_STOPPED
            }
            ActiveConnectionStateReason::IpConfigInvalid => {
                ffi::NM_ACTIVE_CONNECTION_STATE_REASON_IP_CONFIG_INVALID
            }
            ActiveConnectionStateReason::ConnectTimeout => {
                ffi::NM_ACTIVE_CONNECTION_STATE_REASON_CONNECT_TIMEOUT
            }
            ActiveConnectionStateReason::ServiceStartTimeout => {
                ffi::NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT
            }
            ActiveConnectionStateReason::ServiceStartFailed => {
                ffi::NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_FAILED
            }
            ActiveConnectionStateReason::NoSecrets => {
                ffi::NM_ACTIVE_CONNECTION_STATE_REASON_NO_SECRETS
            }
            ActiveConnectionStateReason::LoginFailed => {
                ffi::NM_ACTIVE_CONNECTION_STATE_REASON_LOGIN_FAILED
            }
            ActiveConnectionStateReason::ConnectionRemoved => {
                ffi::NM_ACTIVE_CONNECTION_STATE_REASON_CONNECTION_REMOVED
            }
            ActiveConnectionStateReason::DependencyFailed => {
                ffi::NM_ACTIVE_CONNECTION_STATE_REASON_DEPENDENCY_FAILED
            }
            ActiveConnectionStateReason::DeviceRealizeFailed => {
                ffi::NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REALIZE_FAILED
            }
            ActiveConnectionStateReason::DeviceRemoved => {
                ffi::NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REMOVED
            }
            ActiveConnectionStateReason::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<ffi::NMActiveConnectionStateReason> for ActiveConnectionStateReason {
    fn from_glib(value: ffi::NMActiveConnectionStateReason) -> Self {
        match value {
            0 => ActiveConnectionStateReason::Unknown,
            1 => ActiveConnectionStateReason::None,
            2 => ActiveConnectionStateReason::UserDisconnected,
            3 => ActiveConnectionStateReason::DeviceDisconnected,
            4 => ActiveConnectionStateReason::ServiceStopped,
            5 => ActiveConnectionStateReason::IpConfigInvalid,
            6 => ActiveConnectionStateReason::ConnectTimeout,
            7 => ActiveConnectionStateReason::ServiceStartTimeout,
            8 => ActiveConnectionStateReason::ServiceStartFailed,
            9 => ActiveConnectionStateReason::NoSecrets,
            10 => ActiveConnectionStateReason::LoginFailed,
            11 => ActiveConnectionStateReason::ConnectionRemoved,
            12 => ActiveConnectionStateReason::DependencyFailed,
            13 => ActiveConnectionStateReason::DeviceRealizeFailed,
            14 => ActiveConnectionStateReason::DeviceRemoved,
            value => ActiveConnectionStateReason::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
impl StaticType for ActiveConnectionStateReason {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_active_connection_state_reason_get_type()) }
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
impl<'a> FromValueOptional<'a> for ActiveConnectionStateReason {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
impl<'a> FromValue<'a> for ActiveConnectionStateReason {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
impl SetValue for ActiveConnectionStateReason {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum ClientPermission {
    None,
    EnableDisableNetwork,
    EnableDisableWifi,
    EnableDisableWwan,
    EnableDisableWimax,
    SleepWake,
    NetworkControl,
    WifiShareProtected,
    WifiShareOpen,
    SettingsModifySystem,
    SettingsModifyOwn,
    SettingsModifyHostname,
    SettingsModifyGlobalDns,
    Reload,
    CheckpointRollback,
    EnableDisableStatistics,
    EnableDisableConnectivityCheck,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for ClientPermission {
    type GlibType = ffi::NMClientPermission;

    fn to_glib(&self) -> ffi::NMClientPermission {
        match *self {
            ClientPermission::None => ffi::NM_CLIENT_PERMISSION_NONE,
            ClientPermission::EnableDisableNetwork => {
                ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_NETWORK
            }
            ClientPermission::EnableDisableWifi => ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIFI,
            ClientPermission::EnableDisableWwan => ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_WWAN,
            ClientPermission::EnableDisableWimax => ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIMAX,
            ClientPermission::SleepWake => ffi::NM_CLIENT_PERMISSION_SLEEP_WAKE,
            ClientPermission::NetworkControl => ffi::NM_CLIENT_PERMISSION_NETWORK_CONTROL,
            ClientPermission::WifiShareProtected => ffi::NM_CLIENT_PERMISSION_WIFI_SHARE_PROTECTED,
            ClientPermission::WifiShareOpen => ffi::NM_CLIENT_PERMISSION_WIFI_SHARE_OPEN,
            ClientPermission::SettingsModifySystem => {
                ffi::NM_CLIENT_PERMISSION_SETTINGS_MODIFY_SYSTEM
            }
            ClientPermission::SettingsModifyOwn => ffi::NM_CLIENT_PERMISSION_SETTINGS_MODIFY_OWN,
            ClientPermission::SettingsModifyHostname => {
                ffi::NM_CLIENT_PERMISSION_SETTINGS_MODIFY_HOSTNAME
            }
            ClientPermission::SettingsModifyGlobalDns => {
                ffi::NM_CLIENT_PERMISSION_SETTINGS_MODIFY_GLOBAL_DNS
            }
            ClientPermission::Reload => ffi::NM_CLIENT_PERMISSION_RELOAD,
            ClientPermission::CheckpointRollback => ffi::NM_CLIENT_PERMISSION_CHECKPOINT_ROLLBACK,
            ClientPermission::EnableDisableStatistics => {
                ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_STATISTICS
            }
            ClientPermission::EnableDisableConnectivityCheck => {
                ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_CONNECTIVITY_CHECK
            }
            ClientPermission::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMClientPermission> for ClientPermission {
    fn from_glib(value: ffi::NMClientPermission) -> Self {
        match value {
            0 => ClientPermission::None,
            1 => ClientPermission::EnableDisableNetwork,
            2 => ClientPermission::EnableDisableWifi,
            3 => ClientPermission::EnableDisableWwan,
            4 => ClientPermission::EnableDisableWimax,
            5 => ClientPermission::SleepWake,
            6 => ClientPermission::NetworkControl,
            7 => ClientPermission::WifiShareProtected,
            8 => ClientPermission::WifiShareOpen,
            9 => ClientPermission::SettingsModifySystem,
            10 => ClientPermission::SettingsModifyOwn,
            11 => ClientPermission::SettingsModifyHostname,
            12 => ClientPermission::SettingsModifyGlobalDns,
            13 => ClientPermission::Reload,
            14 => ClientPermission::CheckpointRollback,
            15 => ClientPermission::EnableDisableStatistics,
            16 => ClientPermission::EnableDisableConnectivityCheck,
            value => ClientPermission::__Unknown(value),
        }
    }
}

impl StaticType for ClientPermission {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_client_permission_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ClientPermission {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ClientPermission {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ClientPermission {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum ClientPermissionResult {
    Unknown,
    Yes,
    Auth,
    No,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for ClientPermissionResult {
    type GlibType = ffi::NMClientPermissionResult;

    fn to_glib(&self) -> ffi::NMClientPermissionResult {
        match *self {
            ClientPermissionResult::Unknown => ffi::NM_CLIENT_PERMISSION_RESULT_UNKNOWN,
            ClientPermissionResult::Yes => ffi::NM_CLIENT_PERMISSION_RESULT_YES,
            ClientPermissionResult::Auth => ffi::NM_CLIENT_PERMISSION_RESULT_AUTH,
            ClientPermissionResult::No => ffi::NM_CLIENT_PERMISSION_RESULT_NO,
            ClientPermissionResult::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMClientPermissionResult> for ClientPermissionResult {
    fn from_glib(value: ffi::NMClientPermissionResult) -> Self {
        match value {
            0 => ClientPermissionResult::Unknown,
            1 => ClientPermissionResult::Yes,
            2 => ClientPermissionResult::Auth,
            3 => ClientPermissionResult::No,
            value => ClientPermissionResult::__Unknown(value),
        }
    }
}

impl StaticType for ClientPermissionResult {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_client_permission_result_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ClientPermissionResult {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ClientPermissionResult {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ClientPermissionResult {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum ConnectivityState {
    Unknown,
    None,
    Portal,
    Limited,
    Full,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for ConnectivityState {
    type GlibType = ffi::NMConnectivityState;

    fn to_glib(&self) -> ffi::NMConnectivityState {
        match *self {
            ConnectivityState::Unknown => ffi::NM_CONNECTIVITY_UNKNOWN,
            ConnectivityState::None => ffi::NM_CONNECTIVITY_NONE,
            ConnectivityState::Portal => ffi::NM_CONNECTIVITY_PORTAL,
            ConnectivityState::Limited => ffi::NM_CONNECTIVITY_LIMITED,
            ConnectivityState::Full => ffi::NM_CONNECTIVITY_FULL,
            ConnectivityState::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMConnectivityState> for ConnectivityState {
    fn from_glib(value: ffi::NMConnectivityState) -> Self {
        match value {
            0 => ConnectivityState::Unknown,
            1 => ConnectivityState::None,
            2 => ConnectivityState::Portal,
            3 => ConnectivityState::Limited,
            4 => ConnectivityState::Full,
            value => ConnectivityState::__Unknown(value),
        }
    }
}

impl StaticType for ConnectivityState {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_connectivity_state_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ConnectivityState {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ConnectivityState {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ConnectivityState {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum DeviceState {
    Unknown,
    Unmanaged,
    Unavailable,
    Disconnected,
    Prepare,
    Config,
    NeedAuth,
    IpConfig,
    IpCheck,
    Secondaries,
    Activated,
    Deactivating,
    Failed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for DeviceState {
    type GlibType = ffi::NMDeviceState;

    fn to_glib(&self) -> ffi::NMDeviceState {
        match *self {
            DeviceState::Unknown => ffi::NM_DEVICE_STATE_UNKNOWN,
            DeviceState::Unmanaged => ffi::NM_DEVICE_STATE_UNMANAGED,
            DeviceState::Unavailable => ffi::NM_DEVICE_STATE_UNAVAILABLE,
            DeviceState::Disconnected => ffi::NM_DEVICE_STATE_DISCONNECTED,
            DeviceState::Prepare => ffi::NM_DEVICE_STATE_PREPARE,
            DeviceState::Config => ffi::NM_DEVICE_STATE_CONFIG,
            DeviceState::NeedAuth => ffi::NM_DEVICE_STATE_NEED_AUTH,
            DeviceState::IpConfig => ffi::NM_DEVICE_STATE_IP_CONFIG,
            DeviceState::IpCheck => ffi::NM_DEVICE_STATE_IP_CHECK,
            DeviceState::Secondaries => ffi::NM_DEVICE_STATE_SECONDARIES,
            DeviceState::Activated => ffi::NM_DEVICE_STATE_ACTIVATED,
            DeviceState::Deactivating => ffi::NM_DEVICE_STATE_DEACTIVATING,
            DeviceState::Failed => ffi::NM_DEVICE_STATE_FAILED,
            DeviceState::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMDeviceState> for DeviceState {
    fn from_glib(value: ffi::NMDeviceState) -> Self {
        match value {
            0 => DeviceState::Unknown,
            10 => DeviceState::Unmanaged,
            20 => DeviceState::Unavailable,
            30 => DeviceState::Disconnected,
            40 => DeviceState::Prepare,
            50 => DeviceState::Config,
            60 => DeviceState::NeedAuth,
            70 => DeviceState::IpConfig,
            80 => DeviceState::IpCheck,
            90 => DeviceState::Secondaries,
            100 => DeviceState::Activated,
            110 => DeviceState::Deactivating,
            120 => DeviceState::Failed,
            value => DeviceState::__Unknown(value),
        }
    }
}

impl StaticType for DeviceState {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_device_state_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DeviceState {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DeviceState {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for DeviceState {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum DeviceStateReason {
    None,
    Unknown,
    NowManaged,
    NowUnmanaged,
    ConfigFailed,
    IpConfigUnavailable,
    IpConfigExpired,
    NoSecrets,
    SupplicantDisconnect,
    SupplicantConfigFailed,
    SupplicantFailed,
    SupplicantTimeout,
    PppStartFailed,
    PppDisconnect,
    PppFailed,
    DhcpStartFailed,
    DhcpError,
    DhcpFailed,
    SharedStartFailed,
    SharedFailed,
    AutoipStartFailed,
    AutoipError,
    AutoipFailed,
    ModemBusy,
    ModemNoDialTone,
    ModemNoCarrier,
    ModemDialTimeout,
    ModemDialFailed,
    ModemInitFailed,
    GsmApnFailed,
    GsmRegistrationNotSearching,
    GsmRegistrationDenied,
    GsmRegistrationTimeout,
    GsmRegistrationFailed,
    GsmPinCheckFailed,
    FirmwareMissing,
    Removed,
    Sleeping,
    ConnectionRemoved,
    UserRequested,
    Carrier,
    ConnectionAssumed,
    SupplicantAvailable,
    ModemNotFound,
    BtFailed,
    GsmSimNotInserted,
    GsmSimPinRequired,
    GsmSimPukRequired,
    GsmSimWrong,
    InfinibandMode,
    DependencyFailed,
    Br2684Failed,
    ModemManagerUnavailable,
    SsidNotFound,
    SecondaryConnectionFailed,
    DcbFcoeFailed,
    TeamdControlFailed,
    ModemFailed,
    ModemAvailable,
    SimPinIncorrect,
    NewActivation,
    ParentChanged,
    ParentManagedChanged,
    OvsdbFailed,
    IpAddressDuplicate,
    IpMethodUnsupported,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for DeviceStateReason {
    type GlibType = ffi::NMDeviceStateReason;

    fn to_glib(&self) -> ffi::NMDeviceStateReason {
        match *self {
            DeviceStateReason::None => ffi::NM_DEVICE_STATE_REASON_NONE,
            DeviceStateReason::Unknown => ffi::NM_DEVICE_STATE_REASON_UNKNOWN,
            DeviceStateReason::NowManaged => ffi::NM_DEVICE_STATE_REASON_NOW_MANAGED,
            DeviceStateReason::NowUnmanaged => ffi::NM_DEVICE_STATE_REASON_NOW_UNMANAGED,
            DeviceStateReason::ConfigFailed => ffi::NM_DEVICE_STATE_REASON_CONFIG_FAILED,
            DeviceStateReason::IpConfigUnavailable => {
                ffi::NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE
            }
            DeviceStateReason::IpConfigExpired => ffi::NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED,
            DeviceStateReason::NoSecrets => ffi::NM_DEVICE_STATE_REASON_NO_SECRETS,
            DeviceStateReason::SupplicantDisconnect => {
                ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT
            }
            DeviceStateReason::SupplicantConfigFailed => {
                ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED
            }
            DeviceStateReason::SupplicantFailed => ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_FAILED,
            DeviceStateReason::SupplicantTimeout => ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_TIMEOUT,
            DeviceStateReason::PppStartFailed => ffi::NM_DEVICE_STATE_REASON_PPP_START_FAILED,
            DeviceStateReason::PppDisconnect => ffi::NM_DEVICE_STATE_REASON_PPP_DISCONNECT,
            DeviceStateReason::PppFailed => ffi::NM_DEVICE_STATE_REASON_PPP_FAILED,
            DeviceStateReason::DhcpStartFailed => ffi::NM_DEVICE_STATE_REASON_DHCP_START_FAILED,
            DeviceStateReason::DhcpError => ffi::NM_DEVICE_STATE_REASON_DHCP_ERROR,
            DeviceStateReason::DhcpFailed => ffi::NM_DEVICE_STATE_REASON_DHCP_FAILED,
            DeviceStateReason::SharedStartFailed => ffi::NM_DEVICE_STATE_REASON_SHARED_START_FAILED,
            DeviceStateReason::SharedFailed => ffi::NM_DEVICE_STATE_REASON_SHARED_FAILED,
            DeviceStateReason::AutoipStartFailed => ffi::NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED,
            DeviceStateReason::AutoipError => ffi::NM_DEVICE_STATE_REASON_AUTOIP_ERROR,
            DeviceStateReason::AutoipFailed => ffi::NM_DEVICE_STATE_REASON_AUTOIP_FAILED,
            DeviceStateReason::ModemBusy => ffi::NM_DEVICE_STATE_REASON_MODEM_BUSY,
            DeviceStateReason::ModemNoDialTone => ffi::NM_DEVICE_STATE_REASON_MODEM_NO_DIAL_TONE,
            DeviceStateReason::ModemNoCarrier => ffi::NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER,
            DeviceStateReason::ModemDialTimeout => ffi::NM_DEVICE_STATE_REASON_MODEM_DIAL_TIMEOUT,
            DeviceStateReason::ModemDialFailed => ffi::NM_DEVICE_STATE_REASON_MODEM_DIAL_FAILED,
            DeviceStateReason::ModemInitFailed => ffi::NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED,
            DeviceStateReason::GsmApnFailed => ffi::NM_DEVICE_STATE_REASON_GSM_APN_FAILED,
            DeviceStateReason::GsmRegistrationNotSearching => {
                ffi::NM_DEVICE_STATE_REASON_GSM_REGISTRATION_NOT_SEARCHING
            }
            DeviceStateReason::GsmRegistrationDenied => {
                ffi::NM_DEVICE_STATE_REASON_GSM_REGISTRATION_DENIED
            }
            DeviceStateReason::GsmRegistrationTimeout => {
                ffi::NM_DEVICE_STATE_REASON_GSM_REGISTRATION_TIMEOUT
            }
            DeviceStateReason::GsmRegistrationFailed => {
                ffi::NM_DEVICE_STATE_REASON_GSM_REGISTRATION_FAILED
            }
            DeviceStateReason::GsmPinCheckFailed => {
                ffi::NM_DEVICE_STATE_REASON_GSM_PIN_CHECK_FAILED
            }
            DeviceStateReason::FirmwareMissing => ffi::NM_DEVICE_STATE_REASON_FIRMWARE_MISSING,
            DeviceStateReason::Removed => ffi::NM_DEVICE_STATE_REASON_REMOVED,
            DeviceStateReason::Sleeping => ffi::NM_DEVICE_STATE_REASON_SLEEPING,
            DeviceStateReason::ConnectionRemoved => ffi::NM_DEVICE_STATE_REASON_CONNECTION_REMOVED,
            DeviceStateReason::UserRequested => ffi::NM_DEVICE_STATE_REASON_USER_REQUESTED,
            DeviceStateReason::Carrier => ffi::NM_DEVICE_STATE_REASON_CARRIER,
            DeviceStateReason::ConnectionAssumed => ffi::NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED,
            DeviceStateReason::SupplicantAvailable => {
                ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_AVAILABLE
            }
            DeviceStateReason::ModemNotFound => ffi::NM_DEVICE_STATE_REASON_MODEM_NOT_FOUND,
            DeviceStateReason::BtFailed => ffi::NM_DEVICE_STATE_REASON_BT_FAILED,
            DeviceStateReason::GsmSimNotInserted => {
                ffi::NM_DEVICE_STATE_REASON_GSM_SIM_NOT_INSERTED
            }
            DeviceStateReason::GsmSimPinRequired => {
                ffi::NM_DEVICE_STATE_REASON_GSM_SIM_PIN_REQUIRED
            }
            DeviceStateReason::GsmSimPukRequired => {
                ffi::NM_DEVICE_STATE_REASON_GSM_SIM_PUK_REQUIRED
            }
            DeviceStateReason::GsmSimWrong => ffi::NM_DEVICE_STATE_REASON_GSM_SIM_WRONG,
            DeviceStateReason::InfinibandMode => ffi::NM_DEVICE_STATE_REASON_INFINIBAND_MODE,
            DeviceStateReason::DependencyFailed => ffi::NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED,
            DeviceStateReason::Br2684Failed => ffi::NM_DEVICE_STATE_REASON_BR2684_FAILED,
            DeviceStateReason::ModemManagerUnavailable => {
                ffi::NM_DEVICE_STATE_REASON_MODEM_MANAGER_UNAVAILABLE
            }
            DeviceStateReason::SsidNotFound => ffi::NM_DEVICE_STATE_REASON_SSID_NOT_FOUND,
            DeviceStateReason::SecondaryConnectionFailed => {
                ffi::NM_DEVICE_STATE_REASON_SECONDARY_CONNECTION_FAILED
            }
            DeviceStateReason::DcbFcoeFailed => ffi::NM_DEVICE_STATE_REASON_DCB_FCOE_FAILED,
            DeviceStateReason::TeamdControlFailed => {
                ffi::NM_DEVICE_STATE_REASON_TEAMD_CONTROL_FAILED
            }
            DeviceStateReason::ModemFailed => ffi::NM_DEVICE_STATE_REASON_MODEM_FAILED,
            DeviceStateReason::ModemAvailable => ffi::NM_DEVICE_STATE_REASON_MODEM_AVAILABLE,
            DeviceStateReason::SimPinIncorrect => ffi::NM_DEVICE_STATE_REASON_SIM_PIN_INCORRECT,
            DeviceStateReason::NewActivation => ffi::NM_DEVICE_STATE_REASON_NEW_ACTIVATION,
            DeviceStateReason::ParentChanged => ffi::NM_DEVICE_STATE_REASON_PARENT_CHANGED,
            DeviceStateReason::ParentManagedChanged => {
                ffi::NM_DEVICE_STATE_REASON_PARENT_MANAGED_CHANGED
            }
            DeviceStateReason::OvsdbFailed => ffi::NM_DEVICE_STATE_REASON_OVSDB_FAILED,
            DeviceStateReason::IpAddressDuplicate => {
                ffi::NM_DEVICE_STATE_REASON_IP_ADDRESS_DUPLICATE
            }
            DeviceStateReason::IpMethodUnsupported => {
                ffi::NM_DEVICE_STATE_REASON_IP_METHOD_UNSUPPORTED
            }
            DeviceStateReason::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMDeviceStateReason> for DeviceStateReason {
    fn from_glib(value: ffi::NMDeviceStateReason) -> Self {
        match value {
            0 => DeviceStateReason::None,
            1 => DeviceStateReason::Unknown,
            2 => DeviceStateReason::NowManaged,
            3 => DeviceStateReason::NowUnmanaged,
            4 => DeviceStateReason::ConfigFailed,
            5 => DeviceStateReason::IpConfigUnavailable,
            6 => DeviceStateReason::IpConfigExpired,
            7 => DeviceStateReason::NoSecrets,
            8 => DeviceStateReason::SupplicantDisconnect,
            9 => DeviceStateReason::SupplicantConfigFailed,
            10 => DeviceStateReason::SupplicantFailed,
            11 => DeviceStateReason::SupplicantTimeout,
            12 => DeviceStateReason::PppStartFailed,
            13 => DeviceStateReason::PppDisconnect,
            14 => DeviceStateReason::PppFailed,
            15 => DeviceStateReason::DhcpStartFailed,
            16 => DeviceStateReason::DhcpError,
            17 => DeviceStateReason::DhcpFailed,
            18 => DeviceStateReason::SharedStartFailed,
            19 => DeviceStateReason::SharedFailed,
            20 => DeviceStateReason::AutoipStartFailed,
            21 => DeviceStateReason::AutoipError,
            22 => DeviceStateReason::AutoipFailed,
            23 => DeviceStateReason::ModemBusy,
            24 => DeviceStateReason::ModemNoDialTone,
            25 => DeviceStateReason::ModemNoCarrier,
            26 => DeviceStateReason::ModemDialTimeout,
            27 => DeviceStateReason::ModemDialFailed,
            28 => DeviceStateReason::ModemInitFailed,
            29 => DeviceStateReason::GsmApnFailed,
            30 => DeviceStateReason::GsmRegistrationNotSearching,
            31 => DeviceStateReason::GsmRegistrationDenied,
            32 => DeviceStateReason::GsmRegistrationTimeout,
            33 => DeviceStateReason::GsmRegistrationFailed,
            34 => DeviceStateReason::GsmPinCheckFailed,
            35 => DeviceStateReason::FirmwareMissing,
            36 => DeviceStateReason::Removed,
            37 => DeviceStateReason::Sleeping,
            38 => DeviceStateReason::ConnectionRemoved,
            39 => DeviceStateReason::UserRequested,
            40 => DeviceStateReason::Carrier,
            41 => DeviceStateReason::ConnectionAssumed,
            42 => DeviceStateReason::SupplicantAvailable,
            43 => DeviceStateReason::ModemNotFound,
            44 => DeviceStateReason::BtFailed,
            45 => DeviceStateReason::GsmSimNotInserted,
            46 => DeviceStateReason::GsmSimPinRequired,
            47 => DeviceStateReason::GsmSimPukRequired,
            48 => DeviceStateReason::GsmSimWrong,
            49 => DeviceStateReason::InfinibandMode,
            50 => DeviceStateReason::DependencyFailed,
            51 => DeviceStateReason::Br2684Failed,
            52 => DeviceStateReason::ModemManagerUnavailable,
            53 => DeviceStateReason::SsidNotFound,
            54 => DeviceStateReason::SecondaryConnectionFailed,
            55 => DeviceStateReason::DcbFcoeFailed,
            56 => DeviceStateReason::TeamdControlFailed,
            57 => DeviceStateReason::ModemFailed,
            58 => DeviceStateReason::ModemAvailable,
            59 => DeviceStateReason::SimPinIncorrect,
            60 => DeviceStateReason::NewActivation,
            61 => DeviceStateReason::ParentChanged,
            62 => DeviceStateReason::ParentManagedChanged,
            63 => DeviceStateReason::OvsdbFailed,
            64 => DeviceStateReason::IpAddressDuplicate,
            65 => DeviceStateReason::IpMethodUnsupported,
            value => DeviceStateReason::__Unknown(value),
        }
    }
}

impl StaticType for DeviceStateReason {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_device_state_reason_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DeviceStateReason {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DeviceStateReason {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for DeviceStateReason {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum DeviceType {
    Unknown,
    Ethernet,
    Wifi,
    Unused1,
    Unused2,
    Bt,
    OlpcMesh,
    Wimax,
    Modem,
    Infiniband,
    Bond,
    Vlan,
    Adsl,
    Bridge,
    Generic,
    Team,
    Tun,
    IpTunnel,
    Macvlan,
    Vxlan,
    Veth,
    Macsec,
    Dummy,
    Ppp,
    OvsInterface,
    OvsPort,
    OvsBridge,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for DeviceType {
    type GlibType = ffi::NMDeviceType;

    fn to_glib(&self) -> ffi::NMDeviceType {
        match *self {
            DeviceType::Unknown => ffi::NM_DEVICE_TYPE_UNKNOWN,
            DeviceType::Ethernet => ffi::NM_DEVICE_TYPE_ETHERNET,
            DeviceType::Wifi => ffi::NM_DEVICE_TYPE_WIFI,
            DeviceType::Unused1 => ffi::NM_DEVICE_TYPE_UNUSED1,
            DeviceType::Unused2 => ffi::NM_DEVICE_TYPE_UNUSED2,
            DeviceType::Bt => ffi::NM_DEVICE_TYPE_BT,
            DeviceType::OlpcMesh => ffi::NM_DEVICE_TYPE_OLPC_MESH,
            DeviceType::Wimax => ffi::NM_DEVICE_TYPE_WIMAX,
            DeviceType::Modem => ffi::NM_DEVICE_TYPE_MODEM,
            DeviceType::Infiniband => ffi::NM_DEVICE_TYPE_INFINIBAND,
            DeviceType::Bond => ffi::NM_DEVICE_TYPE_BOND,
            DeviceType::Vlan => ffi::NM_DEVICE_TYPE_VLAN,
            DeviceType::Adsl => ffi::NM_DEVICE_TYPE_ADSL,
            DeviceType::Bridge => ffi::NM_DEVICE_TYPE_BRIDGE,
            DeviceType::Generic => ffi::NM_DEVICE_TYPE_GENERIC,
            DeviceType::Team => ffi::NM_DEVICE_TYPE_TEAM,
            DeviceType::Tun => ffi::NM_DEVICE_TYPE_TUN,
            DeviceType::IpTunnel => ffi::NM_DEVICE_TYPE_IP_TUNNEL,
            DeviceType::Macvlan => ffi::NM_DEVICE_TYPE_MACVLAN,
            DeviceType::Vxlan => ffi::NM_DEVICE_TYPE_VXLAN,
            DeviceType::Veth => ffi::NM_DEVICE_TYPE_VETH,
            DeviceType::Macsec => ffi::NM_DEVICE_TYPE_MACSEC,
            DeviceType::Dummy => ffi::NM_DEVICE_TYPE_DUMMY,
            DeviceType::Ppp => ffi::NM_DEVICE_TYPE_PPP,
            DeviceType::OvsInterface => ffi::NM_DEVICE_TYPE_OVS_INTERFACE,
            DeviceType::OvsPort => ffi::NM_DEVICE_TYPE_OVS_PORT,
            DeviceType::OvsBridge => ffi::NM_DEVICE_TYPE_OVS_BRIDGE,
            DeviceType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMDeviceType> for DeviceType {
    fn from_glib(value: ffi::NMDeviceType) -> Self {
        match value {
            0 => DeviceType::Unknown,
            1 => DeviceType::Ethernet,
            2 => DeviceType::Wifi,
            3 => DeviceType::Unused1,
            4 => DeviceType::Unused2,
            5 => DeviceType::Bt,
            6 => DeviceType::OlpcMesh,
            7 => DeviceType::Wimax,
            8 => DeviceType::Modem,
            9 => DeviceType::Infiniband,
            10 => DeviceType::Bond,
            11 => DeviceType::Vlan,
            12 => DeviceType::Adsl,
            13 => DeviceType::Bridge,
            14 => DeviceType::Generic,
            15 => DeviceType::Team,
            16 => DeviceType::Tun,
            17 => DeviceType::IpTunnel,
            18 => DeviceType::Macvlan,
            19 => DeviceType::Vxlan,
            20 => DeviceType::Veth,
            21 => DeviceType::Macsec,
            22 => DeviceType::Dummy,
            23 => DeviceType::Ppp,
            24 => DeviceType::OvsInterface,
            25 => DeviceType::OvsPort,
            26 => DeviceType::OvsBridge,
            value => DeviceType::__Unknown(value),
        }
    }
}

impl StaticType for DeviceType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_device_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DeviceType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DeviceType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for DeviceType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum IPTunnelMode {
    Unknown,
    Ipip,
    Gre,
    Sit,
    Isatap,
    Vti,
    Ip6ip6,
    Ipip6,
    Ip6gre,
    Vti6,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for IPTunnelMode {
    type GlibType = ffi::NMIPTunnelMode;

    fn to_glib(&self) -> ffi::NMIPTunnelMode {
        match *self {
            IPTunnelMode::Unknown => ffi::NM_IP_TUNNEL_MODE_UNKNOWN,
            IPTunnelMode::Ipip => ffi::NM_IP_TUNNEL_MODE_IPIP,
            IPTunnelMode::Gre => ffi::NM_IP_TUNNEL_MODE_GRE,
            IPTunnelMode::Sit => ffi::NM_IP_TUNNEL_MODE_SIT,
            IPTunnelMode::Isatap => ffi::NM_IP_TUNNEL_MODE_ISATAP,
            IPTunnelMode::Vti => ffi::NM_IP_TUNNEL_MODE_VTI,
            IPTunnelMode::Ip6ip6 => ffi::NM_IP_TUNNEL_MODE_IP6IP6,
            IPTunnelMode::Ipip6 => ffi::NM_IP_TUNNEL_MODE_IPIP6,
            IPTunnelMode::Ip6gre => ffi::NM_IP_TUNNEL_MODE_IP6GRE,
            IPTunnelMode::Vti6 => ffi::NM_IP_TUNNEL_MODE_VTI6,
            IPTunnelMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMIPTunnelMode> for IPTunnelMode {
    fn from_glib(value: ffi::NMIPTunnelMode) -> Self {
        match value {
            0 => IPTunnelMode::Unknown,
            1 => IPTunnelMode::Ipip,
            2 => IPTunnelMode::Gre,
            3 => IPTunnelMode::Sit,
            4 => IPTunnelMode::Isatap,
            5 => IPTunnelMode::Vti,
            6 => IPTunnelMode::Ip6ip6,
            7 => IPTunnelMode::Ipip6,
            8 => IPTunnelMode::Ip6gre,
            9 => IPTunnelMode::Vti6,
            value => IPTunnelMode::__Unknown(value),
        }
    }
}

impl StaticType for IPTunnelMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_ip_tunnel_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for IPTunnelMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for IPTunnelMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for IPTunnelMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum Metered {
    Unknown,
    Yes,
    No,
    GuessYes,
    GuessNo,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for Metered {
    type GlibType = ffi::NMMetered;

    fn to_glib(&self) -> ffi::NMMetered {
        match *self {
            Metered::Unknown => ffi::NM_METERED_UNKNOWN,
            Metered::Yes => ffi::NM_METERED_YES,
            Metered::No => ffi::NM_METERED_NO,
            Metered::GuessYes => ffi::NM_METERED_GUESS_YES,
            Metered::GuessNo => ffi::NM_METERED_GUESS_NO,
            Metered::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMMetered> for Metered {
    fn from_glib(value: ffi::NMMetered) -> Self {
        match value {
            0 => Metered::Unknown,
            1 => Metered::Yes,
            2 => Metered::No,
            3 => Metered::GuessYes,
            4 => Metered::GuessNo,
            value => Metered::__Unknown(value),
        }
    }
}

impl StaticType for Metered {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_metered_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Metered {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Metered {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Metered {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum Setting8021xCKScheme {
    Unknown,
    Blob,
    Path,
    Pkcs11,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for Setting8021xCKScheme {
    type GlibType = ffi::NMSetting8021xCKScheme;

    fn to_glib(&self) -> ffi::NMSetting8021xCKScheme {
        match *self {
            Setting8021xCKScheme::Unknown => ffi::NM_SETTING_802_1X_CK_SCHEME_UNKNOWN,
            Setting8021xCKScheme::Blob => ffi::NM_SETTING_802_1X_CK_SCHEME_BLOB,
            Setting8021xCKScheme::Path => ffi::NM_SETTING_802_1X_CK_SCHEME_PATH,
            Setting8021xCKScheme::Pkcs11 => ffi::NM_SETTING_802_1X_CK_SCHEME_PKCS11,
            Setting8021xCKScheme::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSetting8021xCKScheme> for Setting8021xCKScheme {
    fn from_glib(value: ffi::NMSetting8021xCKScheme) -> Self {
        match value {
            0 => Setting8021xCKScheme::Unknown,
            1 => Setting8021xCKScheme::Blob,
            2 => Setting8021xCKScheme::Path,
            3 => Setting8021xCKScheme::Pkcs11,
            value => Setting8021xCKScheme::__Unknown(value),
        }
    }
}

impl StaticType for Setting8021xCKScheme {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_802_1x_ck_scheme_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Setting8021xCKScheme {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Setting8021xCKScheme {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Setting8021xCKScheme {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum SettingCompareFlags {
    Exact,
    Fuzzy,
    IgnoreId,
    IgnoreSecrets,
    IgnoreAgentOwnedSecrets,
    IgnoreNotSavedSecrets,
    DiffResultWithDefault,
    DiffResultNoDefault,
    IgnoreTimestamp,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for SettingCompareFlags {
    type GlibType = ffi::NMSettingCompareFlags;

    fn to_glib(&self) -> ffi::NMSettingCompareFlags {
        match *self {
            SettingCompareFlags::Exact => ffi::NM_SETTING_COMPARE_FLAG_EXACT,
            SettingCompareFlags::Fuzzy => ffi::NM_SETTING_COMPARE_FLAG_FUZZY,
            SettingCompareFlags::IgnoreId => ffi::NM_SETTING_COMPARE_FLAG_IGNORE_ID,
            SettingCompareFlags::IgnoreSecrets => ffi::NM_SETTING_COMPARE_FLAG_IGNORE_SECRETS,
            SettingCompareFlags::IgnoreAgentOwnedSecrets => {
                ffi::NM_SETTING_COMPARE_FLAG_IGNORE_AGENT_OWNED_SECRETS
            }
            SettingCompareFlags::IgnoreNotSavedSecrets => {
                ffi::NM_SETTING_COMPARE_FLAG_IGNORE_NOT_SAVED_SECRETS
            }
            SettingCompareFlags::DiffResultWithDefault => {
                ffi::NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT
            }
            SettingCompareFlags::DiffResultNoDefault => {
                ffi::NM_SETTING_COMPARE_FLAG_DIFF_RESULT_NO_DEFAULT
            }
            SettingCompareFlags::IgnoreTimestamp => ffi::NM_SETTING_COMPARE_FLAG_IGNORE_TIMESTAMP,
            SettingCompareFlags::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingCompareFlags> for SettingCompareFlags {
    fn from_glib(value: ffi::NMSettingCompareFlags) -> Self {
        match value {
            0 => SettingCompareFlags::Exact,
            1 => SettingCompareFlags::Fuzzy,
            2 => SettingCompareFlags::IgnoreId,
            4 => SettingCompareFlags::IgnoreSecrets,
            8 => SettingCompareFlags::IgnoreAgentOwnedSecrets,
            16 => SettingCompareFlags::IgnoreNotSavedSecrets,
            32 => SettingCompareFlags::DiffResultWithDefault,
            64 => SettingCompareFlags::DiffResultNoDefault,
            128 => SettingCompareFlags::IgnoreTimestamp,
            value => SettingCompareFlags::__Unknown(value),
        }
    }
}

impl StaticType for SettingCompareFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_compare_flags_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SettingCompareFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SettingCompareFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SettingCompareFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum SettingConnectionAutoconnectSlaves {
    Default,
    No,
    Yes,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for SettingConnectionAutoconnectSlaves {
    type GlibType = ffi::NMSettingConnectionAutoconnectSlaves;

    fn to_glib(&self) -> ffi::NMSettingConnectionAutoconnectSlaves {
        match *self {
            SettingConnectionAutoconnectSlaves::Default => {
                ffi::NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_DEFAULT
            }
            SettingConnectionAutoconnectSlaves::No => {
                ffi::NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_NO
            }
            SettingConnectionAutoconnectSlaves::Yes => {
                ffi::NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_YES
            }
            SettingConnectionAutoconnectSlaves::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingConnectionAutoconnectSlaves> for SettingConnectionAutoconnectSlaves {
    fn from_glib(value: ffi::NMSettingConnectionAutoconnectSlaves) -> Self {
        match value {
            -1 => SettingConnectionAutoconnectSlaves::Default,
            0 => SettingConnectionAutoconnectSlaves::No,
            1 => SettingConnectionAutoconnectSlaves::Yes,
            value => SettingConnectionAutoconnectSlaves::__Unknown(value),
        }
    }
}

impl StaticType for SettingConnectionAutoconnectSlaves {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_connection_autoconnect_slaves_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SettingConnectionAutoconnectSlaves {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SettingConnectionAutoconnectSlaves {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SettingConnectionAutoconnectSlaves {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum SettingConnectionLldp {
    Default,
    Disable,
    EnableRx,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for SettingConnectionLldp {
    type GlibType = ffi::NMSettingConnectionLldp;

    fn to_glib(&self) -> ffi::NMSettingConnectionLldp {
        match *self {
            SettingConnectionLldp::Default => ffi::NM_SETTING_CONNECTION_LLDP_DEFAULT,
            SettingConnectionLldp::Disable => ffi::NM_SETTING_CONNECTION_LLDP_DISABLE,
            SettingConnectionLldp::EnableRx => ffi::NM_SETTING_CONNECTION_LLDP_ENABLE_RX,
            SettingConnectionLldp::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingConnectionLldp> for SettingConnectionLldp {
    fn from_glib(value: ffi::NMSettingConnectionLldp) -> Self {
        match value {
            -1 => SettingConnectionLldp::Default,
            0 => SettingConnectionLldp::Disable,
            1 => SettingConnectionLldp::EnableRx,
            value => SettingConnectionLldp::__Unknown(value),
        }
    }
}

impl StaticType for SettingConnectionLldp {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_connection_lldp_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SettingConnectionLldp {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SettingConnectionLldp {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SettingConnectionLldp {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum SettingConnectionMdns {
    Default,
    No,
    Resolve,
    Yes,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for SettingConnectionMdns {
    type GlibType = ffi::NMSettingConnectionMdns;

    fn to_glib(&self) -> ffi::NMSettingConnectionMdns {
        match *self {
            SettingConnectionMdns::Default => ffi::NM_SETTING_CONNECTION_MDNS_DEFAULT,
            SettingConnectionMdns::No => ffi::NM_SETTING_CONNECTION_MDNS_NO,
            SettingConnectionMdns::Resolve => ffi::NM_SETTING_CONNECTION_MDNS_RESOLVE,
            SettingConnectionMdns::Yes => ffi::NM_SETTING_CONNECTION_MDNS_YES,
            SettingConnectionMdns::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingConnectionMdns> for SettingConnectionMdns {
    fn from_glib(value: ffi::NMSettingConnectionMdns) -> Self {
        match value {
            -1 => SettingConnectionMdns::Default,
            0 => SettingConnectionMdns::No,
            1 => SettingConnectionMdns::Resolve,
            2 => SettingConnectionMdns::Yes,
            value => SettingConnectionMdns::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl StaticType for SettingConnectionMdns {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_connection_mdns_get_type()) }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl<'a> FromValueOptional<'a> for SettingConnectionMdns {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl<'a> FromValue<'a> for SettingConnectionMdns {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl SetValue for SettingConnectionMdns {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum SettingIP6ConfigAddrGenMode {
    Eui64,
    StablePrivacy,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for SettingIP6ConfigAddrGenMode {
    type GlibType = ffi::NMSettingIP6ConfigAddrGenMode;

    fn to_glib(&self) -> ffi::NMSettingIP6ConfigAddrGenMode {
        match *self {
            SettingIP6ConfigAddrGenMode::Eui64 => ffi::NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64,
            SettingIP6ConfigAddrGenMode::StablePrivacy => {
                ffi::NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY
            }
            SettingIP6ConfigAddrGenMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingIP6ConfigAddrGenMode> for SettingIP6ConfigAddrGenMode {
    fn from_glib(value: ffi::NMSettingIP6ConfigAddrGenMode) -> Self {
        match value {
            0 => SettingIP6ConfigAddrGenMode::Eui64,
            1 => SettingIP6ConfigAddrGenMode::StablePrivacy,
            value => SettingIP6ConfigAddrGenMode::__Unknown(value),
        }
    }
}

impl StaticType for SettingIP6ConfigAddrGenMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_ip6_config_addr_gen_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SettingIP6ConfigAddrGenMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SettingIP6ConfigAddrGenMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SettingIP6ConfigAddrGenMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum SettingIP6ConfigPrivacy {
    Unknown,
    Disabled,
    PreferPublicAddr,
    PreferTempAddr,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for SettingIP6ConfigPrivacy {
    type GlibType = ffi::NMSettingIP6ConfigPrivacy;

    fn to_glib(&self) -> ffi::NMSettingIP6ConfigPrivacy {
        match *self {
            SettingIP6ConfigPrivacy::Unknown => ffi::NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN,
            SettingIP6ConfigPrivacy::Disabled => ffi::NM_SETTING_IP6_CONFIG_PRIVACY_DISABLED,
            SettingIP6ConfigPrivacy::PreferPublicAddr => {
                ffi::NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR
            }
            SettingIP6ConfigPrivacy::PreferTempAddr => {
                ffi::NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR
            }
            SettingIP6ConfigPrivacy::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingIP6ConfigPrivacy> for SettingIP6ConfigPrivacy {
    fn from_glib(value: ffi::NMSettingIP6ConfigPrivacy) -> Self {
        match value {
            -1 => SettingIP6ConfigPrivacy::Unknown,
            0 => SettingIP6ConfigPrivacy::Disabled,
            1 => SettingIP6ConfigPrivacy::PreferPublicAddr,
            2 => SettingIP6ConfigPrivacy::PreferTempAddr,
            value => SettingIP6ConfigPrivacy::__Unknown(value),
        }
    }
}

impl StaticType for SettingIP6ConfigPrivacy {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_ip6_config_privacy_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SettingIP6ConfigPrivacy {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SettingIP6ConfigPrivacy {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SettingIP6ConfigPrivacy {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum SettingMacRandomization {
    Default,
    Never,
    Always,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for SettingMacRandomization {
    type GlibType = ffi::NMSettingMacRandomization;

    fn to_glib(&self) -> ffi::NMSettingMacRandomization {
        match *self {
            SettingMacRandomization::Default => ffi::NM_SETTING_MAC_RANDOMIZATION_DEFAULT,
            SettingMacRandomization::Never => ffi::NM_SETTING_MAC_RANDOMIZATION_NEVER,
            SettingMacRandomization::Always => ffi::NM_SETTING_MAC_RANDOMIZATION_ALWAYS,
            SettingMacRandomization::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingMacRandomization> for SettingMacRandomization {
    fn from_glib(value: ffi::NMSettingMacRandomization) -> Self {
        match value {
            0 => SettingMacRandomization::Default,
            1 => SettingMacRandomization::Never,
            2 => SettingMacRandomization::Always,
            value => SettingMacRandomization::__Unknown(value),
        }
    }
}

impl StaticType for SettingMacRandomization {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_mac_randomization_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SettingMacRandomization {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SettingMacRandomization {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SettingMacRandomization {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum SettingMacsecMode {
    Psk,
    Eap,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for SettingMacsecMode {
    type GlibType = ffi::NMSettingMacsecMode;

    fn to_glib(&self) -> ffi::NMSettingMacsecMode {
        match *self {
            SettingMacsecMode::Psk => ffi::NM_SETTING_MACSEC_MODE_PSK,
            SettingMacsecMode::Eap => ffi::NM_SETTING_MACSEC_MODE_EAP,
            SettingMacsecMode::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingMacsecMode> for SettingMacsecMode {
    fn from_glib(value: ffi::NMSettingMacsecMode) -> Self {
        match value {
            0 => SettingMacsecMode::Psk,
            1 => SettingMacsecMode::Eap,
            value => SettingMacsecMode::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl StaticType for SettingMacsecMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_macsec_mode_get_type()) }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl<'a> FromValueOptional<'a> for SettingMacsecMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl<'a> FromValue<'a> for SettingMacsecMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl SetValue for SettingMacsecMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum SettingMacsecValidation {
    Disable,
    Check,
    Strict,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for SettingMacsecValidation {
    type GlibType = ffi::NMSettingMacsecValidation;

    fn to_glib(&self) -> ffi::NMSettingMacsecValidation {
        match *self {
            SettingMacsecValidation::Disable => ffi::NM_SETTING_MACSEC_VALIDATION_DISABLE,
            SettingMacsecValidation::Check => ffi::NM_SETTING_MACSEC_VALIDATION_CHECK,
            SettingMacsecValidation::Strict => ffi::NM_SETTING_MACSEC_VALIDATION_STRICT,
            SettingMacsecValidation::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingMacsecValidation> for SettingMacsecValidation {
    fn from_glib(value: ffi::NMSettingMacsecValidation) -> Self {
        match value {
            0 => SettingMacsecValidation::Disable,
            1 => SettingMacsecValidation::Check,
            2 => SettingMacsecValidation::Strict,
            value => SettingMacsecValidation::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl StaticType for SettingMacsecValidation {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_macsec_validation_get_type()) }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl<'a> FromValueOptional<'a> for SettingMacsecValidation {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl<'a> FromValue<'a> for SettingMacsecValidation {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl SetValue for SettingMacsecValidation {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum SettingMacvlanMode {
    Unknown,
    Vepa,
    Bridge,
    Private,
    Passthru,
    Source,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for SettingMacvlanMode {
    type GlibType = ffi::NMSettingMacvlanMode;

    fn to_glib(&self) -> ffi::NMSettingMacvlanMode {
        match *self {
            SettingMacvlanMode::Unknown => ffi::NM_SETTING_MACVLAN_MODE_UNKNOWN,
            SettingMacvlanMode::Vepa => ffi::NM_SETTING_MACVLAN_MODE_VEPA,
            SettingMacvlanMode::Bridge => ffi::NM_SETTING_MACVLAN_MODE_BRIDGE,
            SettingMacvlanMode::Private => ffi::NM_SETTING_MACVLAN_MODE_PRIVATE,
            SettingMacvlanMode::Passthru => ffi::NM_SETTING_MACVLAN_MODE_PASSTHRU,
            SettingMacvlanMode::Source => ffi::NM_SETTING_MACVLAN_MODE_SOURCE,
            SettingMacvlanMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingMacvlanMode> for SettingMacvlanMode {
    fn from_glib(value: ffi::NMSettingMacvlanMode) -> Self {
        match value {
            0 => SettingMacvlanMode::Unknown,
            1 => SettingMacvlanMode::Vepa,
            2 => SettingMacvlanMode::Bridge,
            3 => SettingMacvlanMode::Private,
            4 => SettingMacvlanMode::Passthru,
            5 => SettingMacvlanMode::Source,
            value => SettingMacvlanMode::__Unknown(value),
        }
    }
}

impl StaticType for SettingMacvlanMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_macvlan_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SettingMacvlanMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SettingMacvlanMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SettingMacvlanMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum SettingProxyMethod {
    None,
    Auto,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for SettingProxyMethod {
    type GlibType = ffi::NMSettingProxyMethod;

    fn to_glib(&self) -> ffi::NMSettingProxyMethod {
        match *self {
            SettingProxyMethod::None => ffi::NM_SETTING_PROXY_METHOD_NONE,
            SettingProxyMethod::Auto => ffi::NM_SETTING_PROXY_METHOD_AUTO,
            SettingProxyMethod::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingProxyMethod> for SettingProxyMethod {
    fn from_glib(value: ffi::NMSettingProxyMethod) -> Self {
        match value {
            0 => SettingProxyMethod::None,
            1 => SettingProxyMethod::Auto,
            value => SettingProxyMethod::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl StaticType for SettingProxyMethod {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_proxy_method_get_type()) }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl<'a> FromValueOptional<'a> for SettingProxyMethod {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl<'a> FromValue<'a> for SettingProxyMethod {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
impl SetValue for SettingProxyMethod {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum SettingSerialParity {
    None,
    Even,
    Odd,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for SettingSerialParity {
    type GlibType = ffi::NMSettingSerialParity;

    fn to_glib(&self) -> ffi::NMSettingSerialParity {
        match *self {
            SettingSerialParity::None => ffi::NM_SETTING_SERIAL_PARITY_NONE,
            SettingSerialParity::Even => ffi::NM_SETTING_SERIAL_PARITY_EVEN,
            SettingSerialParity::Odd => ffi::NM_SETTING_SERIAL_PARITY_ODD,
            SettingSerialParity::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingSerialParity> for SettingSerialParity {
    fn from_glib(value: ffi::NMSettingSerialParity) -> Self {
        match value {
            0 => SettingSerialParity::None,
            1 => SettingSerialParity::Even,
            2 => SettingSerialParity::Odd,
            value => SettingSerialParity::__Unknown(value),
        }
    }
}

impl StaticType for SettingSerialParity {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_serial_parity_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SettingSerialParity {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SettingSerialParity {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SettingSerialParity {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum SettingTunMode {
    Unknown,
    Tun,
    Tap,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for SettingTunMode {
    type GlibType = ffi::NMSettingTunMode;

    fn to_glib(&self) -> ffi::NMSettingTunMode {
        match *self {
            SettingTunMode::Unknown => ffi::NM_SETTING_TUN_MODE_UNKNOWN,
            SettingTunMode::Tun => ffi::NM_SETTING_TUN_MODE_TUN,
            SettingTunMode::Tap => ffi::NM_SETTING_TUN_MODE_TAP,
            SettingTunMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingTunMode> for SettingTunMode {
    fn from_glib(value: ffi::NMSettingTunMode) -> Self {
        match value {
            0 => SettingTunMode::Unknown,
            1 => SettingTunMode::Tun,
            2 => SettingTunMode::Tap,
            value => SettingTunMode::__Unknown(value),
        }
    }
}

impl StaticType for SettingTunMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_tun_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SettingTunMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SettingTunMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SettingTunMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum SettingWirelessSecurityFils {
    Default,
    Disable,
    Optional,
    Required,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for SettingWirelessSecurityFils {
    type GlibType = ffi::NMSettingWirelessSecurityFils;

    fn to_glib(&self) -> ffi::NMSettingWirelessSecurityFils {
        match *self {
            SettingWirelessSecurityFils::Default => ffi::NM_SETTING_WIRELESS_SECURITY_FILS_DEFAULT,
            SettingWirelessSecurityFils::Disable => ffi::NM_SETTING_WIRELESS_SECURITY_FILS_DISABLE,
            SettingWirelessSecurityFils::Optional => {
                ffi::NM_SETTING_WIRELESS_SECURITY_FILS_OPTIONAL
            }
            SettingWirelessSecurityFils::Required => {
                ffi::NM_SETTING_WIRELESS_SECURITY_FILS_REQUIRED
            }
            SettingWirelessSecurityFils::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingWirelessSecurityFils> for SettingWirelessSecurityFils {
    fn from_glib(value: ffi::NMSettingWirelessSecurityFils) -> Self {
        match value {
            0 => SettingWirelessSecurityFils::Default,
            1 => SettingWirelessSecurityFils::Disable,
            2 => SettingWirelessSecurityFils::Optional,
            3 => SettingWirelessSecurityFils::Required,
            value => SettingWirelessSecurityFils::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl StaticType for SettingWirelessSecurityFils {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_wireless_security_fils_get_type()) }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl<'a> FromValueOptional<'a> for SettingWirelessSecurityFils {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl<'a> FromValue<'a> for SettingWirelessSecurityFils {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl SetValue for SettingWirelessSecurityFils {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum SettingWirelessSecurityPmf {
    Default,
    Disable,
    Optional,
    Required,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for SettingWirelessSecurityPmf {
    type GlibType = ffi::NMSettingWirelessSecurityPmf;

    fn to_glib(&self) -> ffi::NMSettingWirelessSecurityPmf {
        match *self {
            SettingWirelessSecurityPmf::Default => ffi::NM_SETTING_WIRELESS_SECURITY_PMF_DEFAULT,
            SettingWirelessSecurityPmf::Disable => ffi::NM_SETTING_WIRELESS_SECURITY_PMF_DISABLE,
            SettingWirelessSecurityPmf::Optional => ffi::NM_SETTING_WIRELESS_SECURITY_PMF_OPTIONAL,
            SettingWirelessSecurityPmf::Required => ffi::NM_SETTING_WIRELESS_SECURITY_PMF_REQUIRED,
            SettingWirelessSecurityPmf::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingWirelessSecurityPmf> for SettingWirelessSecurityPmf {
    fn from_glib(value: ffi::NMSettingWirelessSecurityPmf) -> Self {
        match value {
            0 => SettingWirelessSecurityPmf::Default,
            1 => SettingWirelessSecurityPmf::Disable,
            2 => SettingWirelessSecurityPmf::Optional,
            3 => SettingWirelessSecurityPmf::Required,
            value => SettingWirelessSecurityPmf::__Unknown(value),
        }
    }
}

impl StaticType for SettingWirelessSecurityPmf {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_wireless_security_pmf_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SettingWirelessSecurityPmf {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SettingWirelessSecurityPmf {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SettingWirelessSecurityPmf {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum SettingWirelessSecurityWpsMethod {
    Default,
    Disabled,
    Auto,
    Pbc,
    Pin,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for SettingWirelessSecurityWpsMethod {
    type GlibType = ffi::NMSettingWirelessSecurityWpsMethod;

    fn to_glib(&self) -> ffi::NMSettingWirelessSecurityWpsMethod {
        match *self {
            SettingWirelessSecurityWpsMethod::Default => {
                ffi::NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DEFAULT
            }
            SettingWirelessSecurityWpsMethod::Disabled => {
                ffi::NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DISABLED
            }
            SettingWirelessSecurityWpsMethod::Auto => {
                ffi::NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_AUTO
            }
            SettingWirelessSecurityWpsMethod::Pbc => {
                ffi::NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_PBC
            }
            SettingWirelessSecurityWpsMethod::Pin => {
                ffi::NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_PIN
            }
            SettingWirelessSecurityWpsMethod::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingWirelessSecurityWpsMethod> for SettingWirelessSecurityWpsMethod {
    fn from_glib(value: ffi::NMSettingWirelessSecurityWpsMethod) -> Self {
        match value {
            0 => SettingWirelessSecurityWpsMethod::Default,
            1 => SettingWirelessSecurityWpsMethod::Disabled,
            2 => SettingWirelessSecurityWpsMethod::Auto,
            4 => SettingWirelessSecurityWpsMethod::Pbc,
            8 => SettingWirelessSecurityWpsMethod::Pin,
            value => SettingWirelessSecurityWpsMethod::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
impl StaticType for SettingWirelessSecurityWpsMethod {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_setting_wireless_security_wps_method_get_type()) }
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
impl<'a> FromValueOptional<'a> for SettingWirelessSecurityWpsMethod {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
impl<'a> FromValue<'a> for SettingWirelessSecurityWpsMethod {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
impl SetValue for SettingWirelessSecurityWpsMethod {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum State {
    Unknown,
    Asleep,
    Disconnected,
    Disconnecting,
    Connecting,
    ConnectedLocal,
    ConnectedSite,
    ConnectedGlobal,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for State {
    type GlibType = ffi::NMState;

    fn to_glib(&self) -> ffi::NMState {
        match *self {
            State::Unknown => ffi::NM_STATE_UNKNOWN,
            State::Asleep => ffi::NM_STATE_ASLEEP,
            State::Disconnected => ffi::NM_STATE_DISCONNECTED,
            State::Disconnecting => ffi::NM_STATE_DISCONNECTING,
            State::Connecting => ffi::NM_STATE_CONNECTING,
            State::ConnectedLocal => ffi::NM_STATE_CONNECTED_LOCAL,
            State::ConnectedSite => ffi::NM_STATE_CONNECTED_SITE,
            State::ConnectedGlobal => ffi::NM_STATE_CONNECTED_GLOBAL,
            State::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMState> for State {
    fn from_glib(value: ffi::NMState) -> Self {
        match value {
            0 => State::Unknown,
            10 => State::Asleep,
            20 => State::Disconnected,
            30 => State::Disconnecting,
            40 => State::Connecting,
            50 => State::ConnectedLocal,
            60 => State::ConnectedSite,
            70 => State::ConnectedGlobal,
            value => State::__Unknown(value),
        }
    }
}

impl StaticType for State {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_state_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for State {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for State {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for State {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum VlanPriorityMap {
    IngressMap,
    EgressMap,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for VlanPriorityMap {
    type GlibType = ffi::NMVlanPriorityMap;

    fn to_glib(&self) -> ffi::NMVlanPriorityMap {
        match *self {
            VlanPriorityMap::IngressMap => ffi::NM_VLAN_INGRESS_MAP,
            VlanPriorityMap::EgressMap => ffi::NM_VLAN_EGRESS_MAP,
            VlanPriorityMap::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMVlanPriorityMap> for VlanPriorityMap {
    fn from_glib(value: ffi::NMVlanPriorityMap) -> Self {
        match value {
            0 => VlanPriorityMap::IngressMap,
            1 => VlanPriorityMap::EgressMap,
            value => VlanPriorityMap::__Unknown(value),
        }
    }
}

impl StaticType for VlanPriorityMap {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_vlan_priority_map_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for VlanPriorityMap {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for VlanPriorityMap {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for VlanPriorityMap {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum VpnConnectionState {
    Unknown,
    Prepare,
    NeedAuth,
    Connect,
    IpConfigGet,
    Activated,
    Failed,
    Disconnected,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for VpnConnectionState {
    type GlibType = ffi::NMVpnConnectionState;

    fn to_glib(&self) -> ffi::NMVpnConnectionState {
        match *self {
            VpnConnectionState::Unknown => ffi::NM_VPN_CONNECTION_STATE_UNKNOWN,
            VpnConnectionState::Prepare => ffi::NM_VPN_CONNECTION_STATE_PREPARE,
            VpnConnectionState::NeedAuth => ffi::NM_VPN_CONNECTION_STATE_NEED_AUTH,
            VpnConnectionState::Connect => ffi::NM_VPN_CONNECTION_STATE_CONNECT,
            VpnConnectionState::IpConfigGet => ffi::NM_VPN_CONNECTION_STATE_IP_CONFIG_GET,
            VpnConnectionState::Activated => ffi::NM_VPN_CONNECTION_STATE_ACTIVATED,
            VpnConnectionState::Failed => ffi::NM_VPN_CONNECTION_STATE_FAILED,
            VpnConnectionState::Disconnected => ffi::NM_VPN_CONNECTION_STATE_DISCONNECTED,
            VpnConnectionState::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMVpnConnectionState> for VpnConnectionState {
    fn from_glib(value: ffi::NMVpnConnectionState) -> Self {
        match value {
            0 => VpnConnectionState::Unknown,
            1 => VpnConnectionState::Prepare,
            2 => VpnConnectionState::NeedAuth,
            3 => VpnConnectionState::Connect,
            4 => VpnConnectionState::IpConfigGet,
            5 => VpnConnectionState::Activated,
            6 => VpnConnectionState::Failed,
            7 => VpnConnectionState::Disconnected,
            value => VpnConnectionState::__Unknown(value),
        }
    }
}

impl StaticType for VpnConnectionState {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_vpn_connection_state_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for VpnConnectionState {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for VpnConnectionState {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for VpnConnectionState {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum VpnPluginError {
    Failed,
    StartingInProgress,
    AlreadyStarted,
    StoppingInProgress,
    AlreadyStopped,
    WrongState,
    BadArguments,
    LaunchFailed,
    InvalidConnection,
    InteractiveNotSupported,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for VpnPluginError {
    type GlibType = ffi::NMVpnPluginError;

    fn to_glib(&self) -> ffi::NMVpnPluginError {
        match *self {
            VpnPluginError::Failed => ffi::NM_VPN_PLUGIN_ERROR_FAILED,
            VpnPluginError::StartingInProgress => ffi::NM_VPN_PLUGIN_ERROR_STARTING_IN_PROGRESS,
            VpnPluginError::AlreadyStarted => ffi::NM_VPN_PLUGIN_ERROR_ALREADY_STARTED,
            VpnPluginError::StoppingInProgress => ffi::NM_VPN_PLUGIN_ERROR_STOPPING_IN_PROGRESS,
            VpnPluginError::AlreadyStopped => ffi::NM_VPN_PLUGIN_ERROR_ALREADY_STOPPED,
            VpnPluginError::WrongState => ffi::NM_VPN_PLUGIN_ERROR_WRONG_STATE,
            VpnPluginError::BadArguments => ffi::NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,
            VpnPluginError::LaunchFailed => ffi::NM_VPN_PLUGIN_ERROR_LAUNCH_FAILED,
            VpnPluginError::InvalidConnection => ffi::NM_VPN_PLUGIN_ERROR_INVALID_CONNECTION,
            VpnPluginError::InteractiveNotSupported => {
                ffi::NM_VPN_PLUGIN_ERROR_INTERACTIVE_NOT_SUPPORTED
            }
            VpnPluginError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMVpnPluginError> for VpnPluginError {
    fn from_glib(value: ffi::NMVpnPluginError) -> Self {
        match value {
            0 => VpnPluginError::Failed,
            1 => VpnPluginError::StartingInProgress,
            2 => VpnPluginError::AlreadyStarted,
            3 => VpnPluginError::StoppingInProgress,
            4 => VpnPluginError::AlreadyStopped,
            5 => VpnPluginError::WrongState,
            6 => VpnPluginError::BadArguments,
            7 => VpnPluginError::LaunchFailed,
            8 => VpnPluginError::InvalidConnection,
            9 => VpnPluginError::InteractiveNotSupported,
            value => VpnPluginError::__Unknown(value),
        }
    }
}

impl ErrorDomain for VpnPluginError {
    fn domain() -> Quark {
        unsafe { from_glib(ffi::nm_vpn_plugin_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            0 => Some(VpnPluginError::Failed),
            1 => Some(VpnPluginError::StartingInProgress),
            2 => Some(VpnPluginError::AlreadyStarted),
            3 => Some(VpnPluginError::StoppingInProgress),
            4 => Some(VpnPluginError::AlreadyStopped),
            5 => Some(VpnPluginError::WrongState),
            6 => Some(VpnPluginError::BadArguments),
            7 => Some(VpnPluginError::LaunchFailed),
            8 => Some(VpnPluginError::InvalidConnection),
            9 => Some(VpnPluginError::InteractiveNotSupported),
            _ => Some(VpnPluginError::Failed),
        }
    }
}

impl StaticType for VpnPluginError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_vpn_plugin_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for VpnPluginError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for VpnPluginError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for VpnPluginError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum VpnPluginFailure {
    LoginFailed,
    ConnectFailed,
    BadIpConfig,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for VpnPluginFailure {
    type GlibType = ffi::NMVpnPluginFailure;

    fn to_glib(&self) -> ffi::NMVpnPluginFailure {
        match *self {
            VpnPluginFailure::LoginFailed => ffi::NM_VPN_PLUGIN_FAILURE_LOGIN_FAILED,
            VpnPluginFailure::ConnectFailed => ffi::NM_VPN_PLUGIN_FAILURE_CONNECT_FAILED,
            VpnPluginFailure::BadIpConfig => ffi::NM_VPN_PLUGIN_FAILURE_BAD_IP_CONFIG,
            VpnPluginFailure::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMVpnPluginFailure> for VpnPluginFailure {
    fn from_glib(value: ffi::NMVpnPluginFailure) -> Self {
        match value {
            0 => VpnPluginFailure::LoginFailed,
            1 => VpnPluginFailure::ConnectFailed,
            2 => VpnPluginFailure::BadIpConfig,
            value => VpnPluginFailure::__Unknown(value),
        }
    }
}

impl StaticType for VpnPluginFailure {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_vpn_plugin_failure_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for VpnPluginFailure {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for VpnPluginFailure {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for VpnPluginFailure {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum VpnServiceState {
    Unknown,
    Init,
    Shutdown,
    Starting,
    Started,
    Stopping,
    Stopped,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for VpnServiceState {
    type GlibType = ffi::NMVpnServiceState;

    fn to_glib(&self) -> ffi::NMVpnServiceState {
        match *self {
            VpnServiceState::Unknown => ffi::NM_VPN_SERVICE_STATE_UNKNOWN,
            VpnServiceState::Init => ffi::NM_VPN_SERVICE_STATE_INIT,
            VpnServiceState::Shutdown => ffi::NM_VPN_SERVICE_STATE_SHUTDOWN,
            VpnServiceState::Starting => ffi::NM_VPN_SERVICE_STATE_STARTING,
            VpnServiceState::Started => ffi::NM_VPN_SERVICE_STATE_STARTED,
            VpnServiceState::Stopping => ffi::NM_VPN_SERVICE_STATE_STOPPING,
            VpnServiceState::Stopped => ffi::NM_VPN_SERVICE_STATE_STOPPED,
            VpnServiceState::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMVpnServiceState> for VpnServiceState {
    fn from_glib(value: ffi::NMVpnServiceState) -> Self {
        match value {
            0 => VpnServiceState::Unknown,
            1 => VpnServiceState::Init,
            2 => VpnServiceState::Shutdown,
            3 => VpnServiceState::Starting,
            4 => VpnServiceState::Started,
            5 => VpnServiceState::Stopping,
            6 => VpnServiceState::Stopped,
            value => VpnServiceState::__Unknown(value),
        }
    }
}

impl StaticType for VpnServiceState {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_vpn_service_state_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for VpnServiceState {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for VpnServiceState {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for VpnServiceState {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
pub enum WepKeyType {
    Unknown,
    Key,
    Passphrase,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for WepKeyType {
    type GlibType = ffi::NMWepKeyType;

    fn to_glib(&self) -> ffi::NMWepKeyType {
        match *self {
            WepKeyType::Unknown => ffi::NM_WEP_KEY_TYPE_UNKNOWN,
            WepKeyType::Key => ffi::NM_WEP_KEY_TYPE_KEY,
            WepKeyType::Passphrase => ffi::NM_WEP_KEY_TYPE_PASSPHRASE,
            WepKeyType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMWepKeyType> for WepKeyType {
    fn from_glib(value: ffi::NMWepKeyType) -> Self {
        match value {
            0 => WepKeyType::Unknown,
            1 => WepKeyType::Key,
            2 => WepKeyType::Passphrase,
            value => WepKeyType::__Unknown(value),
        }
    }
}

impl StaticType for WepKeyType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nm_wep_key_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for WepKeyType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for WepKeyType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for WepKeyType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}
