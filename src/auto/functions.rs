// This file was generated by gir (https://github.com/gtk-rs/gir @ 609779c)
// from gir-files (https://github.com/gtk-rs/gir-files @ ???)
// DO NOT EDIT

use _80211ApFlags;
use _80211ApSecurityFlags;
use ffi;
use glib;
use glib::translate::*;
use std::mem;
use std::ptr;
use DeviceWifiCapabilities;
use Error;
#[cfg(any(feature = "v1_12", feature = "dox"))]
use TCQdisc;
#[cfg(any(feature = "v1_12", feature = "dox"))]
use TCTfilter;
use UtilsSecurityType;
use WepKeyType;

pub fn utils_ap_mode_security_valid(
    type_: UtilsSecurityType,
    wifi_caps: DeviceWifiCapabilities,
) -> bool {
    unsafe {
        from_glib(ffi::nm_utils_ap_mode_security_valid(
            type_.to_glib(),
            wifi_caps.to_glib(),
        ))
    }
}

pub fn utils_bond_mode_int_to_string(mode: i32) -> Option<String> {
    unsafe { from_glib_none(ffi::nm_utils_bond_mode_int_to_string(mode)) }
}

pub fn utils_bond_mode_string_to_int(mode: &str) -> i32 {
    unsafe { ffi::nm_utils_bond_mode_string_to_int(mode.to_glib_none().0) }
}

pub fn utils_check_virtual_device_compatibility(
    virtual_type: glib::types::Type,
    other_type: glib::types::Type,
) -> bool {
    unsafe {
        from_glib(ffi::nm_utils_check_virtual_device_compatibility(
            virtual_type.to_glib(),
            other_type.to_glib(),
        ))
    }
}

pub fn utils_enum_from_str(type_: glib::types::Type, str: &str) -> Option<(i32, String)> {
    unsafe {
        let mut out_value = mem::uninitialized();
        let mut err_token = ptr::null_mut();
        let ret = from_glib(ffi::nm_utils_enum_from_str(
            type_.to_glib(),
            str.to_glib_none().0,
            &mut out_value,
            &mut err_token,
        ));
        if ret {
            Some((out_value, from_glib_full(err_token)))
        } else {
            None
        }
    }
}

pub fn utils_enum_get_values(type_: glib::types::Type, from: i32, to: i32) -> Vec<String> {
    unsafe {
        FromGlibPtrContainer::from_glib_container(ffi::nm_utils_enum_get_values(
            type_.to_glib(),
            from,
            to,
        ))
    }
}

pub fn utils_enum_to_str(type_: glib::types::Type, value: i32) -> Option<String> {
    unsafe { from_glib_full(ffi::nm_utils_enum_to_str(type_.to_glib(), value)) }
}

pub fn utils_escape_ssid(ssid: &[u8]) -> Option<String> {
    let len = ssid.len() as usize;
    unsafe { from_glib_none(ffi::nm_utils_escape_ssid(ssid.to_glib_none().0, len)) }
}

pub fn utils_file_is_certificate(filename: &str) -> bool {
    unsafe { from_glib(ffi::nm_utils_file_is_certificate(filename.to_glib_none().0)) }
}

pub fn utils_file_is_pkcs12(filename: &str) -> bool {
    unsafe { from_glib(ffi::nm_utils_file_is_pkcs12(filename.to_glib_none().0)) }
}

pub fn utils_file_is_private_key(filename: &str) -> Option<bool> {
    unsafe {
        let mut out_encrypted = mem::uninitialized();
        let ret = from_glib(ffi::nm_utils_file_is_private_key(
            filename.to_glib_none().0,
            &mut out_encrypted,
        ));
        if ret {
            Some(from_glib(out_encrypted))
        } else {
            None
        }
    }
}

//pub fn utils_file_search_in_paths<'a, 'b, P: Into<Option<&'a str>>, Q: Into<Option<&'b str>>, R: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(progname: &str, try_first: P, paths: Q, file_test_flags: glib::FileTest, predicate: /*Unknown conversion*//*Unimplemented*/UtilsFileSearchInPathsPredicate, user_data: R) -> Result<String, Error> {
//    unsafe { TODO: call ffi::nm_utils_file_search_in_paths() }
//}

//pub fn utils_format_variant_attributes(attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 25 }/TypeId { ns_id: 0, id: 25 }, attr_separator: glib::Char, key_value_separator: glib::Char) -> Option<String> {
//    unsafe { TODO: call ffi::nm_utils_format_variant_attributes() }
//}

pub fn utils_get_timestamp_msec() -> i64 {
    unsafe { ffi::nm_utils_get_timestamp_msec() }
}

pub fn utils_hexstr2bin(hex: &str) -> Option<glib::Bytes> {
    unsafe { from_glib_full(ffi::nm_utils_hexstr2bin(hex.to_glib_none().0)) }
}

//pub fn utils_hwaddr_atoba(asc: &str) -> /*Ignored*/Option<glib::ByteArray> {
//    unsafe { TODO: call ffi::nm_utils_hwaddr_atoba() }
//}

pub fn utils_hwaddr_canonical(asc: &str) -> Option<String> {
    let length = asc.len() as isize;
    unsafe { from_glib_full(ffi::nm_utils_hwaddr_canonical(asc.to_glib_none().0, length)) }
}

pub fn utils_hwaddr_len(type_: i32) -> usize {
    unsafe { ffi::nm_utils_hwaddr_len(type_) }
}

//pub fn utils_hwaddr_matches<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>, Q: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(hwaddr1: P, hwaddr1_len: isize, hwaddr2: Q, hwaddr2_len: isize) -> bool {
//    unsafe { TODO: call ffi::nm_utils_hwaddr_matches() }
//}

pub fn utils_hwaddr_valid(asc: &str) -> bool {
    let length = asc.len() as isize;
    unsafe { from_glib(ffi::nm_utils_hwaddr_valid(asc.to_glib_none().0, length)) }
}

#[cfg_attr(feature = "v1_6", deprecated)]
pub fn utils_iface_valid_name(name: &str) -> bool {
    unsafe { from_glib(ffi::nm_utils_iface_valid_name(name.to_glib_none().0)) }
}

//pub fn utils_ip4_addresses_from_variant(value: &glib::Variant) -> (/*Unknown conversion*//*Unimplemented*/PtrArray TypeId { ns_id: 1, id: 137 }, String) {
//    unsafe { TODO: call ffi::nm_utils_ip4_addresses_from_variant() }
//}

//pub fn utils_ip4_addresses_to_variant<'a, P: Into<Option<&'a str>>>(addresses: /*Unknown conversion*//*Unimplemented*/PtrArray TypeId { ns_id: 1, id: 137 }, gateway: P) -> Option<glib::Variant> {
//    unsafe { TODO: call ffi::nm_utils_ip4_addresses_to_variant() }
//}

pub fn utils_ip4_get_default_prefix(ip: u32) -> u32 {
    unsafe { ffi::nm_utils_ip4_get_default_prefix(ip) }
}

pub fn utils_ip4_netmask_to_prefix(netmask: u32) -> u32 {
    unsafe { ffi::nm_utils_ip4_netmask_to_prefix(netmask) }
}

pub fn utils_ip4_prefix_to_netmask(prefix: u32) -> u32 {
    unsafe { ffi::nm_utils_ip4_prefix_to_netmask(prefix) }
}

//pub fn utils_ip4_routes_from_variant(value: &glib::Variant) -> /*Unknown conversion*//*Unimplemented*/PtrArray TypeId { ns_id: 1, id: 138 } {
//    unsafe { TODO: call ffi::nm_utils_ip4_routes_from_variant() }
//}

//pub fn utils_ip4_routes_to_variant(routes: /*Unknown conversion*//*Unimplemented*/PtrArray TypeId { ns_id: 1, id: 138 }) -> Option<glib::Variant> {
//    unsafe { TODO: call ffi::nm_utils_ip4_routes_to_variant() }
//}

//pub fn utils_ip6_addresses_from_variant(value: &glib::Variant) -> (/*Unknown conversion*//*Unimplemented*/PtrArray TypeId { ns_id: 1, id: 137 }, String) {
//    unsafe { TODO: call ffi::nm_utils_ip6_addresses_from_variant() }
//}

//pub fn utils_ip6_addresses_to_variant<'a, P: Into<Option<&'a str>>>(addresses: /*Unknown conversion*//*Unimplemented*/PtrArray TypeId { ns_id: 1, id: 137 }, gateway: P) -> Option<glib::Variant> {
//    unsafe { TODO: call ffi::nm_utils_ip6_addresses_to_variant() }
//}

//pub fn utils_ip6_routes_from_variant(value: &glib::Variant) -> /*Unknown conversion*//*Unimplemented*/PtrArray TypeId { ns_id: 1, id: 138 } {
//    unsafe { TODO: call ffi::nm_utils_ip6_routes_from_variant() }
//}

//pub fn utils_ip6_routes_to_variant(routes: /*Unknown conversion*//*Unimplemented*/PtrArray TypeId { ns_id: 1, id: 138 }) -> Option<glib::Variant> {
//    unsafe { TODO: call ffi::nm_utils_ip6_routes_to_variant() }
//}

//pub fn utils_ip_addresses_from_variant(value: &glib::Variant, family: i32) -> /*Unknown conversion*//*Unimplemented*/PtrArray TypeId { ns_id: 1, id: 137 } {
//    unsafe { TODO: call ffi::nm_utils_ip_addresses_from_variant() }
//}

//pub fn utils_ip_addresses_to_variant(addresses: /*Unknown conversion*//*Unimplemented*/PtrArray TypeId { ns_id: 1, id: 137 }) -> Option<glib::Variant> {
//    unsafe { TODO: call ffi::nm_utils_ip_addresses_to_variant() }
//}

//pub fn utils_ip_routes_from_variant(value: &glib::Variant, family: i32) -> /*Unknown conversion*//*Unimplemented*/PtrArray TypeId { ns_id: 1, id: 138 } {
//    unsafe { TODO: call ffi::nm_utils_ip_routes_from_variant() }
//}

//pub fn utils_ip_routes_to_variant(routes: /*Unknown conversion*//*Unimplemented*/PtrArray TypeId { ns_id: 1, id: 138 }) -> Option<glib::Variant> {
//    unsafe { TODO: call ffi::nm_utils_ip_routes_to_variant() }
//}

pub fn utils_ipaddr_valid(family: i32, ip: &str) -> bool {
    unsafe { from_glib(ffi::nm_utils_ipaddr_valid(family, ip.to_glib_none().0)) }
}

pub fn utils_is_empty_ssid(ssid: &[u8]) -> bool {
    let len = ssid.len() as usize;
    unsafe { from_glib(ffi::nm_utils_is_empty_ssid(ssid.to_glib_none().0, len)) }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
pub fn utils_is_json_object(str: &str) -> Result<(), Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let _ = ffi::nm_utils_is_json_object(str.to_glib_none().0, &mut error);
        if error.is_null() {
            Ok(())
        } else {
            Err(from_glib_full(error))
        }
    }
}

pub fn utils_is_uuid(str: &str) -> bool {
    unsafe { from_glib(ffi::nm_utils_is_uuid(str.to_glib_none().0)) }
}

pub fn utils_is_valid_iface_name(name: &str) -> Result<(), Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let _ = ffi::nm_utils_is_valid_iface_name(name.to_glib_none().0, &mut error);
        if error.is_null() {
            Ok(())
        } else {
            Err(from_glib_full(error))
        }
    }
}

//#[cfg(any(feature = "v1_8", feature = "dox"))]
//pub fn utils_parse_variant_attributes(string: &str, attr_separator: glib::Char, key_value_separator: glib::Char, ignore_unknown: bool, spec: /*Ignored*/&VariantAttributeSpec) -> Result</*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 2, id: 179 }, Error> {
//    unsafe { TODO: call ffi::nm_utils_parse_variant_attributes() }
//}

pub fn utils_same_ssid(ssid1: &[u8], ssid2: &[u8], ignore_trailing_null: bool) -> bool {
    let len1 = ssid1.len() as usize;
    let len2 = ssid2.len() as usize;
    unsafe {
        from_glib(ffi::nm_utils_same_ssid(
            ssid1.to_glib_none().0,
            len1,
            ssid2.to_glib_none().0,
            len2,
            ignore_trailing_null.to_glib(),
        ))
    }
}

pub fn utils_security_valid(
    type_: UtilsSecurityType,
    wifi_caps: DeviceWifiCapabilities,
    have_ap: bool,
    adhoc: bool,
    ap_flags: _80211ApFlags,
    ap_wpa: _80211ApSecurityFlags,
    ap_rsn: _80211ApSecurityFlags,
) -> bool {
    unsafe {
        from_glib(ffi::nm_utils_security_valid(
            type_.to_glib(),
            wifi_caps.to_glib(),
            have_ap.to_glib(),
            adhoc.to_glib(),
            ap_flags.to_glib(),
            ap_wpa.to_glib(),
            ap_rsn.to_glib(),
        ))
    }
}

pub fn utils_ssid_to_utf8(ssid: &[u8]) -> Option<String> {
    let len = ssid.len() as usize;
    unsafe { from_glib_full(ffi::nm_utils_ssid_to_utf8(ssid.to_glib_none().0, len)) }
}

//#[cfg(any(feature = "v1_12", feature = "dox"))]
//pub fn utils_tc_action_from_str(str: &str) -> Result</*Ignored*/TCAction, Error> {
//    unsafe { TODO: call ffi::nm_utils_tc_action_from_str() }
//}

//#[cfg(any(feature = "v1_12", feature = "dox"))]
//pub fn utils_tc_action_to_str(action: /*Ignored*/&TCAction) -> Result<String, Error> {
//    unsafe { TODO: call ffi::nm_utils_tc_action_to_str() }
//}

#[cfg(any(feature = "v1_12", feature = "dox"))]
pub fn utils_tc_qdisc_from_str(str: &str) -> Result<TCQdisc, Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let ret = ffi::nm_utils_tc_qdisc_from_str(str.to_glib_none().0, &mut error);
        if error.is_null() {
            Ok(from_glib_full(ret))
        } else {
            Err(from_glib_full(error))
        }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
pub fn utils_tc_qdisc_to_str(qdisc: &TCQdisc) -> Result<String, Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let ret = ffi::nm_utils_tc_qdisc_to_str(qdisc.to_glib_none().0, &mut error);
        if error.is_null() {
            Ok(from_glib_full(ret))
        } else {
            Err(from_glib_full(error))
        }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
pub fn utils_tc_tfilter_from_str(str: &str) -> Result<TCTfilter, Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let ret = ffi::nm_utils_tc_tfilter_from_str(str.to_glib_none().0, &mut error);
        if error.is_null() {
            Ok(from_glib_full(ret))
        } else {
            Err(from_glib_full(error))
        }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
pub fn utils_tc_tfilter_to_str(tfilter: &TCTfilter) -> Result<String, Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let ret = ffi::nm_utils_tc_tfilter_to_str(tfilter.to_glib_none().0, &mut error);
        if error.is_null() {
            Ok(from_glib_full(ret))
        } else {
            Err(from_glib_full(error))
        }
    }
}

#[cfg(any(feature = "v1_6", feature = "dox"))]
pub fn utils_version() -> u32 {
    unsafe { ffi::nm_utils_version() }
}

pub fn utils_wep_key_valid(key: &str, wep_type: WepKeyType) -> bool {
    unsafe {
        from_glib(ffi::nm_utils_wep_key_valid(
            key.to_glib_none().0,
            wep_type.to_glib(),
        ))
    }
}

pub fn utils_wifi_channel_to_freq(channel: u32, band: &str) -> u32 {
    unsafe { ffi::nm_utils_wifi_channel_to_freq(channel, band.to_glib_none().0) }
}

pub fn utils_wifi_find_next_channel(channel: u32, direction: i32, band: &str) -> u32 {
    unsafe { ffi::nm_utils_wifi_find_next_channel(channel, direction, band.to_glib_none().0) }
}

pub fn utils_wifi_freq_to_channel(freq: u32) -> u32 {
    unsafe { ffi::nm_utils_wifi_freq_to_channel(freq) }
}

pub fn utils_wifi_is_channel_valid(channel: u32, band: &str) -> bool {
    unsafe {
        from_glib(ffi::nm_utils_wifi_is_channel_valid(
            channel,
            band.to_glib_none().0,
        ))
    }
}

pub fn utils_wifi_strength_bars(strength: u8) -> Option<String> {
    unsafe { from_glib_none(ffi::nm_utils_wifi_strength_bars(strength)) }
}

pub fn utils_wpa_psk_valid(psk: &str) -> bool {
    unsafe { from_glib(ffi::nm_utils_wpa_psk_valid(psk.to_glib_none().0)) }
}
